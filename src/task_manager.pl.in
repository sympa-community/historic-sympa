#! --PERL--

# task_manager.pl - This script runs as a daemon and processes periodical Sympa tasks
# RCS Identication ; $Revision$ ; $Date$ 
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

## Options :  F         -> do not detach TTY
##         :  d		-> debug -d is equiv to -dF

use lib '--modulesdir--';
use strict "vars";

use Data::Dumper;
use Getopt::Long;

use Conf;
use List;
use Log;
use SDM;
use Sympa::Constants;
use Task;
use TaskSpool;
use tools;
##XXXuse wwslib;

my $opt_d;
my $opt_F;
my %options;

unless (&GetOptions(\%main::options, 'debug|d', 'log_level=s', 'foreground')) {
    &Log::fatal_err("Unknown options.");
}

# $main::options{'debug2'} = 1 if ($main::options{'debug'});

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}
# Some option force foreground mode
$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'debug'} || $main::options{'foreground'});

my $Version = '0.1';

my $adrlist = {};

# Load sympa.conf
unless (defined Robot::get_robots()) {
    Log::fatal_err(
	'Unable to load sympa configuration, file %s or one of the virtual host robot.conf files contain errors. Exiting.',
	Conf::get_sympa_conf()
    );
}

&Log::do_openlog(Site->log_facility, Site->log_socket_type, 'task_manager');

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
	'info', 'Configuration file read, log level set using options : %s',
	$main::options{'log_level'}
    );
} else {
    Log::set_log_level(Site->log_level);
    Log::do_log(
	'info', 'Configuration file read, default log level %s',
	Site->log_level
    );
}

## Check databse connectivity
unless (&SDM::check_db_connect()) {
    &Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', $Conf{'db_name'});
}

## Check that the data structure is uptodate
unless (&Upgrade::data_structure_uptodate()) {
    &Log::fatal_err("error : data structure was not updated ; you should run sympa.pl to run the upgrade process.");
}

## Check for several files.
unless (&Conf::checkfiles()) {
    &Log::fatal_err("Missing files. Aborting.");
    ## No return.                                         
}

## Put ourselves in background if not in debug mode. 
                                             
unless ($main::options{'debug'} || $main::options{'foreground'}) {
     open(STDERR, ">> /dev/null");
     open(STDOUT, ">> /dev/null");
     if (open(TTY, "/dev/tty")) {
         ioctl(TTY, 0x20007471, 0);         #  s/b &TIOCNOTTY
#       ioctl(TTY, &TIOCNOTTY, 0);                                             
         close(TTY);
     }
                                       
     setpgrp(0, 0);
     if ((my $child_pid = fork) != 0) {                                        
         print STDOUT "Starting task_manager daemon, pid $_\n";	 
         exit(0);
     }     
 }

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
&tools::write_pid(Site->task_manager_pidfile, $$, $options);
unless ($options->{'stderr_to_tty'}) {
    &tools::direct_stderr_to_file(('pid' => $$));
}

## Set the UserID & GroupID for the process
$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
$< = $> = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
    &Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct($Conf{'umask'}));

## Change to list root
unless (chdir($Conf{'home'})) {
    &Log::do_log('err',"error : unable to change to directory $Conf{'home'}");
    exit (-1);
}

&TaskSpool::set_spool(); # force initialisation of $taskspool in module Task 

my $pinfo = &List::_apply_defaults();

## Generate traceback if crashed.
$SIG{'__DIE__'} = \&tools::crash_handler;

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

###### VARIABLES DECLARATION ######
undef my $log; # won't execute send_msg and delete_subs commands if true, only log
#$log = 1;


###### INFINITE LOOP SCANING THE SPOOL (unless a sig TERM is received) ######
while (!$end) {

    my $current_date = time; # current epoch date
    my $rep = &tools::adate ($current_date);


    ## Empty cache of the List.pm module
    &List::init_list_cache();
    &List::send_notify_to_listmaster(undef, undef, undef, 1); # Process grouped notifications
	
   ## List all tasks
    unless (&TaskSpool::list_tasks) {
	&List::send_notify_to_listmaster('intern_error',$Conf{'domain'},{'error' => "Failed to list task files in spool"});
	&Log::do_log ('err', "Failed to list task files in spool");
	exit -1;
    }

    &TaskSpool::create_required_tasks($current_date);

    ## Execute existing tasks
    ## processing of tasks anterior to the current date
    &Log::do_log ('debug2', 'processing of tasks anterior to the current date');
    foreach my $task ( &TaskSpool::get_task_list() ) {
        last if $end;
        next unless ($task->{'date'} <= $current_date);
        &Log::do_log ('debug2', 'processing of task %s, %s',$task->{'messagekey'},$task->get_description);
        if ($task->{'object'} ne '_global') { # list task
            $task->check_list_task_is_valid();
        }
        $task->execute;
    }
    sleep 30;
    ## Free zombie sendmail processes
    &mail::reaper;
}

## when we catch SIGTERM, just change the value of the loop variable.
sub sigterm {
    $end = 1;
}

&List::send_notify_to_listmaster(undef, undef, undef, undef, 1); # Purge grouped notifications

&Log::do_log ('notice', 'task_manager exited normally due to signal'); 
&tools::remove_pid(Site->task_manager_pidfile, $$);

exit(0);

