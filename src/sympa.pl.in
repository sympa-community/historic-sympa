#!--PERL--
# sympa.pl - This script is the main one ; it runs as a daemon and does
# the messages/commands processing
# RCS Identication ; $Revision$ ; $Date$ 
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use warnings;
use lib '--modulesdir--';
#use Getopt::Std;
use Getopt::Long;
use Mail::Address;
use File::Path;
use MIME::QuotedPrint;
use File::Copy;
# tentative
use Data::Dumper;

use Commands;
#use Conf; # load in Site - List - Commands
use Auth;
use SympaSession;
#use Language; # load in List
#use Log; # load in Conf
#use mail; # load in List - Auth
#use List; #load in Auth
use Message;
use admin;
use Config_XML;
use Family;
#use report; # load in Auth
#use tools; # load in Conf
#use tt2; # load in List
#use Sympa::Constants;
#use tracking; # not used
#use Sympaspool; # load in List
#use SDM; # load in Conf
use Upgrade;

# dirty global variables
my $is_signed = {}; 

## Internal tuning
# delay between each read of the digestqueue
my $digestsleep = 5;

## Init random engine
srand (time());

my $version_string =
    sprintf("Sympa version is %s\n", Sympa::Constants::VERSION);

my $daemon_name = &Log::set_daemon($0);
my $ip;
$ip = $ENV{'REMOTE_HOST'};
$ip = $ENV{'REMOTE_ADDR'} unless ($ip);

my $usage_string = "Usage:
   $0 [OPTIONS]

Options:
   --add_list=family_name --robot=robot_name --input_file=/path/to/file.xml
                                         : add the list described by the file.xml under robot_name, to the family
                                           family_name.
   --change_user_email --current_email=xx --new_email=xx : changes a user email address in all Sympa 
                                           databases (subscriber_table, list config, etc) for all virtual robots.
   --close_family=family_name --robot=robot_name 
                                         : close lists of family_name family under robot_name.      

   --close_list=listname\@robot          : close a list
   --conf_2_db			         : load in database, sympa;conf, wwsympa.conf and each robot.conf
   --config=FILE, -f                     : uses an alternative configuration file
   --create_list --robot=robot_name --input_file=/path/to/file.xml 
                                         : create a list with the xml file under robot_name
   --debug, -d                           : sets Sympa in debug mode 
   --dump=list\@dom|ALL                  : dumps subscribers 
   --foreground                          : the process remains attached to the TTY
   --help, -h                            : print this help
   --import=list\@dom                    : import subscribers (read from STDIN)
   --instantiate_family=family_name  --robot=robot_name --input_file=/path/to/file.xml [--close_unknown] [--quiet]
                                         : instantiate family_name lists described in the file.xml under robot_name,
                                           the family directory must exist ;
                                           automatically close undefined lists in a new instantation if --close_unknown specified,
                                           do not print report if --quiet specified.
   --keepcopy=dir, -k                    : keep a copy of incoming message
   --lang=LANG, -l                       : use a language catalog for Sympa
   --log_level=LEVEL                     : sets Sympa log level
   --lowercase                           : lowercase email addresses in database
   --mail, -m                            : log calls to sendmail
   --make_alias_file                     : create file in /tmp with all aliases (usefull when aliases.tpl is changed)
   --md5_digest=password                 : output a MD5 digest of a password (usefull for SOAP client trusted application)
   --md5_encode_password                 : rewrite password in database using md5 fingerprint. YOU CAN'T UNDO unless you save this table first
   --modify_list=family_name --robot=robot_name --input_file=/path/to/file.xml
                                         : modify the existing list installed under the robot_name robot and that 
                                           belongs to family_name family. The new description is in the file.xml
   --purge_list=listname\@robot          : remove a list no backup is possible
   --reload_list_config [--list=mylist\@mydom] [--robot=mydom]
                                         : recreates all config.bin files. You should run this command if you edit authorization scenarios. The list and robot parameters are optional.
   --rename_list=listname\@robot --new_listname=newlistname --new_listrobot=newrobot : renames a list or move it to another virtual robot
   --service=process_command|process_message|process_creation  : process dedicated to messages distribution, commands or to automatic lists creation (default three of them)
   --sync_include=listname\@robot        : trigger the list members update
   --test_database_message_buffer        : test the database message buffer size
   --upgrade [--from=X] [--to=Y]             : runs Sympa maintenance script to upgrade from version X to version Y
   --upgrade_shared  --[listname=X] --[robot=Y] : rename files in shared.
   --version                         : print version number

Sympa is a mailinglists manager and comes with a complete (user and admin)
web interface. Sympa  can be linked to an LDAP directory or an RDBMS to 
create dynamic mailing lists. Sympa provides S/MIME and HTTPS based authentication and
encryption.
";

## Check --dump option
my %options;
unless (&GetOptions(\%main::options, 'dump=s', 'debug|d', ,'log_level=s','foreground','config|f=s', 
            'lang|l=s', 'mail|m', 'keepcopy|k=s', 'help', 'version', 'import=s','make_alias_file','lowercase','sync_list_db','md5_encode_password',
		    'close_list=s','rename_list=s','new_listname=s','new_listrobot=s','purge_list=s','create_list','instantiate_family=s',
		    'robot=s','add_list=s','modify_list=s','close_family=s','md5_digest=s','change_user_email','current_email=s','new_email=s',
		    'input_file=s','sync_include=s','upgrade','upgrade_shared','from=s','to=s','reload_list_config','list=s','quiet','close_unknown','test_database_message_buffer','conf_2_db','export_list')) {
    &Log::fatal_err("Unknown options.");
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}
## Batch mode, ie NOT daemon
$main::options{'batch'} = 1 if ($main::options{'dump'} || 
				$main::options{'help'} ||
				$main::options{'version'} || 
				$main::options{'import'} || 
				$main::options{'make_alias_file'} ||
				$main::options{'lowercase'} ||
				$main::options{'md5_encode_password'} ||
				$main::options{'change_user_email'} ||
				$main::options{'close_list'} ||
				$main::options{'purge_list'} ||
				$main::options{'create_list'} ||
				$main::options{'rename_list'} ||
				$main::options{'instantiate_family'} ||
				$main::options{'add_list'} ||
				$main::options{'modify_list'} ||
				$main::options{'close_family'} ||
				$main::options{'md5_digest'} || 
				$main::options{'sync_include'} ||
				$main::options{'upgrade'} ||
				$main::options{'upgrade_shared'} ||
				$main::options{'test_database_message_buffer'} || 
				$main::options{'conf_2_db'} || 
				$main::options{'reload_list_config'} ||
				$main::options{'sync_list_db'}
				 );

# Some option force foreground mode
$main::options{'foreground'} = 1 if ($main::options{'debug'} || $main::options{'batch'});

$main::options{'log_to_stderr'} = 1 unless ($main::options{'batch'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'upgrade'} || $main::options{'reload_list_config'} || $main::options{'test_database_message_buffer'} || $main::options{'conf_2_db'});

my %loop_info;
my %msgid_table;
my $latest_msgid_table_cleanup = time;

# this loop is run foreach HUP signal received
my $signal = 0;

while ($signal ne 'term') { #as long as a SIGTERM is not received }

## Load configuration file. Ignoring database config for now: it avoids trying to load a database that could not exist yet.
unless (defined Robot::get_robots('force_reload' => 1, 'no_db' => 1)) {
    &Log::fatal_err(
	'Unable to load sympa configuration, file %s or one of the virtual host robot.conf files contain errors. Exiting.',
	Conf::get_sympa_conf()
    );  
}

## Open the syslog and say we're read out stuff.
Log::do_openlog(Site->syslog, Site->log_socket_type, 'sympa');

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
	'info', 'Configuration file read, log level set using options : %s',
	$main::options{'log_level'}
    ); 
} else {
    Log::set_log_level(Site->log_level);
    Log::do_log(
	'info', 'Configuration file read, default log level %s',
	Site->log_level
    ); 
}

## Probe Db if defined
if (Site->db_name and Site->db_type) {
    unless (SDM::probe_db()) {
	&Log::fatal_err(
	    'Database %s defined in sympa.conf has not the right structure or is unreachable. verify db_xxx parameters in sympa.conf',
	    Site->db_name
	);
    }
}

## Now trying to load full config (including database)
unless (defined Robot::get_robots()) {
    Log::fatal_err(
	'Configuration file %s has errors.',
	Conf::get_sympa_conf()
    );
   
}

&tools::ciphersaber_installed();

if (&tools::cookie_changed(Site->cookie)) {
     &Log::fatal_err('sympa.conf/cookie parameter has changed. You may have severe inconsitencies into password storage. Restore previous cookie or write some tool to re-encrypt password in database and check spools contents (look at %s/cookies.history file)', Site->etc);
}

## Set locale configuration
$main::options{'lang'} =~ s/\.cat$// if defined ($main::options{'lang'}); ## Compatibility with version < 2.3.3
$Language::default_lang = $main::options{'lang'} || Site->lang;

## Main program
if (!chdir(Site->home)) {
   &Log::fatal_err("Can't chdir to %s: %m", Site->home);
   ## Function never returns.
}

## Check for several files.
unless (&Conf::checkfiles_as_root()) {
   &Log::fatal_err("output checkfiles_as_root : Missing files. Aborting.");
   ## No return.
}

## Check that the data structure is uptodate
unless ($main::options{'upgrade'} || $main::options{'help'}) {
    unless (SDM::data_structure_uptodate()) {
	&Log::fatal_err("error : data structure was not updated ; you should run sympa.pl --upgrade to run the upgrade process.");
    }
}


if (Site->voot_feature eq 'on') {
    unless ( eval "require OAuthProvider" ){
	&Log::fatal_err("VOOT feature is on, but Sympa was Unable to load OAuthProvider module: $@");
	return undef;
    }
    require OAuthProvider;
    unless ( eval "require OAuthConsumer" ){
	&Log::fatal_err("VOOT feature is on, but Sympa was Unable to load OAuthConsumer module: $@");
	return undef;
    }
    require OAuthConsumer;
    unless ( eval "require VOOTProvider" ){
	&Log::fatal_err("VOOT feature is on, but Sympa was Unable to load VOOTProvider module: $@");
	return undef;
    }
    require VOOTProvider;
    unless ( eval "require VOOTConsumer" ){
	&Log::fatal_err("VOOT feature is on, but Sympa was Unable to load module: $@");
	return undef;
    }
    require VOOTConsumer;
}else {
#XXX    &Log::do_log('err','Sympa is configured to use VOOT but the required modules are not accessible.');
}

if ($signal ne 'hup') {
    ## Put ourselves in background if we're not in debug mode. That method
    ## works on many systems, although, it seems that Unix conceptors have
    ## decided that there won't be a single and easy way to detach a process
    ## from its controlling tty.
    unless ($main::options{'foreground'}) {
	if (open(TTY, "/dev/tty")) {
	    ioctl(TTY, 0x20007471, 0);         # XXX s/b &TIOCNOTTY
	    #       ioctl(TTY, &TIOCNOTTY, 0);
	    close(TTY);
	}
	open(STDIN, ">> /dev/null");
	open(STDOUT, ">> /dev/null");
	open(STDERR, ">> /dev/null");

	setpgrp(0, 0);
	# start the main sympa.pl daemon


	&Log::do_log('debug', "Starting server $0");
	if ((my $child_pid = fork) != 0) {
	    &Log::do_log('info', "Server started $0 pid $child_pid");
	    &Log::do_log('debug', "$0 server started, pid $child_pid, exiting from initial process");
	    exit(0);
	}
    }

    &Log::do_openlog(Site->syslog, Site->log_socket_type, 'sympa');

    &Log::do_log('debug', "Running server $$");
    unless ($main::options{'batch'} ) {

	## Create and write the pidfile
	my $file = Site->pidfile;
	## If process is running in foreground, don't write STDERR to a dedicated file
	my $options;
	$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
	&tools::write_pid($file, $$, $options);
	unless ($options->{'stderr_to_tty'}) {
	    &tools::direct_stderr_to_file(('pid' => $$));
	}
    }	


    # Set the UserID & GroupID for the process
    $( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
    $< = $> = (getpwnam(Sympa::Constants::USER))[2];

    ## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
    &POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
    &POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

    ## Check if the UID has correctly been set (usefull on OS X)
    unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
	&Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
    }

    # Sets the UMASK
    umask(oct(Site->umask));

 ## Most initializations have now been done.
    &Log::do_log('notice', "Sympa %s started", Sympa::Constants::VERSION);
}else{
    &Log::do_log('notice', "Sympa %s reload config", Sympa::Constants::VERSION);
    $signal = '0';
}

unless (&Conf::checkfiles()) {
    fatal_err("Missing files. Aborting.");
}

## Daemon called for dumping subscribers list
if ($main::options{'dump'}) {
    
    my ($all_lists, $list);
    if ($main::options{'dump'} eq 'ALL') {
	$all_lists = List::get_lists();
    }else {	
	
	## The parameter can be a list address
	unless ($main::options{'dump'} =~ /\@/) {
	    &Log::do_log('err','Incorrect list address %s', $main::options{'dump'});
	    
	    exit;
	} 

	my $list = new List ($main::options{'dump'});
	unless (defined $list) {
	    &Log::do_log('err','Unknown list %s', $main::options{'dump'});
	    
	    exit;
	}
	push @$all_lists, $list;
    }

    foreach my $list (@$all_lists) {
	unless ($list->dump()) {
	    printf STDERR "Could not dump list(s)\n";
	}
    }

    exit 0;
}elsif ($main::options{'help'}) {
    print $usage_string;
    exit 0;
}elsif ($main::options{'make_alias_file'}) {
    my $all_lists = List::get_lists();
    unless (open TMP, '>', Site->tmpdir . "/sympa_aliases.$$") {
	printf STDERR "Unable to create " . Site->tmpdir . "/sympa_aliases.$$, exiting\n";
	exit;
    }
    printf TMP "#\n#\tAliases for all Sympa lists open (but not for robots)\n#\n";
    close TMP;
    foreach my $list (@$all_lists) {
	my $cmd = sprintf '%s add %s %s %s/sympa_aliases.%s',
	    Site->alias_manager, $list->name, $list->domain,
	    Site->tmpdir, $$;
	system($cmd) if $list->status eq 'open';
    }
    printf "Sympa aliases file is %s/sympa_aliases.%s file made, you probably need to installed it in your SMTP engine\n", Site->tmpdir, $$;
    
    exit 0;
}elsif ($main::options{'version'}) {
    print $version_string;
    
    exit 0;
}elsif ($main::options{'md5_digest'}) {
    my $md5 = &tools::md5_fingerprint($main::options{'md5_digest'});
    printf "md5 digest : $md5 \n";
    
    exit 0;
}elsif ($main::options{'import'}) {
    my ($list, $total);

    ## The parameter should be a list address
    unless ($main::options{'import'} =~ /\@/) {
	&Log::do_log('err','Incorrect list address %s', $main::options{'import'});
	exit;
    } 


    unless ($list = new List ($main::options{'import'})) {
	&Log::fatal_err('Unknown list name %s', $main::options{'import'});
    }

    ## Read imported data from STDIN
    while (<STDIN>) {
	next if /^\s*$/;
	next if /^\s*\#/;

	unless (/^\s*((\S+|\".*\")@\S+)(\s*(\S.*))?\s*$/) {
	    printf STDERR "Not an email address: %s\n", $_;
	}

	my $email = lc($1);
	my $gecos = $4;
	my $u;
	my $defaults = $list->default_user_options;
	%{$u} = %{$defaults};
	$u->{'email'} = $email;
	$u->{'gecos'} = $gecos;

	$list->add_list_member($u);
	if (defined $list->{'add_outcome'}{'errors'}) {
	    printf STDERR "\nCould not add %s. %s\n", $email,$list->{'add_outcome'}{'errors'}{'error_message'};
	    next;
	}
	print STDERR '+';
	
	$total++;	
    }
    
    printf STDERR "Total imported subscribers: %d\n", $total;

    exit 0;
}elsif ($main::options{'md5_encode_password'}) {

    unless ($Site::use_db) {
	&Log::fatal_err("You don't have a database setup, can't lowercase email addresses");
    }
    
    my $total=&Upgrade::md5_encode_password();
    printf STDERR "Total password re-encoded using md5: %d\n", $total;
    
    exit 0;
    
}elsif ($main::options{'lowercase'}) {
    
    unless ($Site::use_db) {
	&Log::fatal_err("You don't have a database setup, can't lowercase email addresses");
    }

    print STDERR "Working on user_table...\n";
    my $total = &List::lowercase_field('user_table', 'email_user');

    print STDERR "Working on subscriber_table...\n";
    $total += &List::lowercase_field('subscriber_table', 'user_subscriber');

    unless (defined $total) {
	&Log::fatal_err("Could not work on dabatase");
    }

    printf STDERR "Total lowercased rows: %d\n", $total;

    exit 0;
}elsif ($main::options{'close_list'}) {

    my ($listname, $robotname) = split /\@/, $main::options{'close_list'};
    my $list = new List ($listname, $robotname);

    unless (defined $list) {
	print STDERR "Incorrect list name $main::options{'close_list'}\n";
	exit 1;
    }

    if ($list->family_name) {
 	unless($list->set_status_family_closed('close_list', $list->name)) {
 	    print STDERR "Could not close list $main::options{'close_list'}\n";
 	    exit 1;	
 	}
    } else {
	unless ($list->close_list()) {
	    print STDERR "Could not close list $main::options{'close_list'}\n";
	    exit 1;	
	}
    }

    printf STDOUT "List %s has been closed, aliases have been removed\n", $list->name;
    
    exit 0;
}elsif ($main::options{'change_user_email'}) {

    unless ($main::options{'current_email'} && $main::options{'new_email'}) {
	print STDERR "Missing current_email or new_email parameter\n";
	exit 1;
    }

    foreach my $robot_object (@{Robot::get_robots()}) {
	printf STDOUT "Doing processing for virtual robot %s...\n",
	    $robot_object->name;
	my ($status, $failed_for) = admin::change_user_email(
	    'current_email' => $main::options{'current_email'}, 
	    'new_email' => $main::options{'new_email'},
	    'robot' => $robot_object
	);
	unless (defined $status) {
	    printf STDERR "Failed to change user email address in virtual robot %s'}\n",
		$robot_object->name;
	    exit 1;
	}
	
	foreach my $failed_list (@$failed_for) {
	    printf STDERR "Failed to change user email address for list %s'}\n", $failed_list->{'name'};
	}
    }

    printf STDOUT "Email address %s has been changed to %s\n", $main::options{'current_email'}, $main::options{'new_email'};
    
    exit 0;
}elsif ($main::options{'purge_list'}) {

    my ($listname, $robotname) = split /\@/, $main::options{'purge_list'};
    my $list = new List ($listname, $robotname);

    unless (defined $list) {
	print STDERR "Incorrect list name $main::options{'purge_list'}\n";
	exit 1;
    }

    if ($list->family_name) {
 	unless($list->set_status_family_closed('purge_list', $list->name)) {
 	    print STDERR "Could not purge list $main::options{'purge_list'}\n";
 	    exit 1;	
 	}
    } else {
	unless ($list->purge()) {
	    print STDERR "Could not purge list $main::options{'close_list'}\n";
	    exit 1;	
	}
    }

    printf STDOUT "List %s has been closed, aliases have been removed\n", $list->name;
    
    exit 0;
}elsif ($main::options{'rename_list'}) {

  ## TODO A completer
  
    my ($listname, $robotname) = split /\@/, $main::options{'rename_list'};
    my $list = new List ($listname, $robotname);

    unless (defined $list) {
	print STDERR "Incorrect list name $main::options{'rename_list'}\n";
	exit 1;
    }

    unless ($main::options{'new_listname'}) {
      print STDERR "Missing parameter new_listname\n";
      exit 1;
    }
    
    unless ($main::options{'new_listrobot'}) {
      print STDERR "Missing parameter new_listrobot\n";
      exit 1;
    }
    
    my ($new_listname, $new_robotname) = ($main::options{'new_listname'}, $main::options{'new_listrobot'});
    
    my $result = &admin::rename_list(list => $list,
				     new_listname => $new_listname,
				     new_robot => $new_robotname,
				     options => {'skip_authz' => 1},
				     user_email => 'listmaster@'.$robotname,
				    );

    unless($result == 1) {
      printf STDERR "Could not rename list %s to %s: %s\@%s\n", $main::options{'rename_list'}, $main::options{'new_listname'}, $main::options{'new_listrobot'}, $result;
      exit 1;	
    }

    printf STDOUT "List %s has been renamed to %s\@%s\n", $main::options{'rename_list'}, $main::options{'new_listname'}, $main::options{'new_listrobot'};
    
    exit 0;

}elsif ($main::options{'test_database_message_buffer'}) {
    my $size = 0;   
    printf "Sympa is going to store messages bigger and bigger to test the limit with its database. This may be very long \n";
    $size = &Sympaspool::store_test(21000); ## will test message until a 21 Mo message.
    if ($size == 21000) {
	printf "The maximum message size ($size Ko) testing was successful \n";
    }else{
	printf "maximun message size that can be stored in database : $size Ko\n";
    }
    exit 1;
    
}elsif ($main::options{'conf_2_db'}) {
    printf "Sympa is going to store %s in database conf_table. This operation do NOT remove original files\n", Conf::get_sympa_conf();
    if (Conf::conf_2_db()) {
	printf "Done";
    }else{
	printf "an error occur";
    }
    exit 1;
    
}elsif ($main::options{'create_list'}) {    
    my $robot = $main::options{'robot'} || Site->host;
    
    unless ($main::options{'input_file'}) {
 	print STDERR "Error : missing 'input_file' parameter\n";
 	exit 1;
    }

    unless (open INFILE, $main::options{'input_file'}) {
	print STDERR "Unable to open $main::options{'input_file'}) file";
 	exit 1;	
    }
    
    my $config = new Config_XML(\*INFILE);
    unless (defined $config->createHash()) {
 	print STDERR "Error in representation data with these xml data\n";
 	exit 1;
    } 
    
    my $hash = $config->getHash();
    
    close INFILE;

    my $resul = &admin::create_list_old($hash->{'config'},$hash->{'type'},$robot,"command_line");
    unless (defined $resul) {
 	print STDERR "Could not create list with these xml data\n";
 	exit 1;
    }
    
    if (! defined($resul->{'aliases'}) || $resul->{'aliases'} == 1) {
 	printf STDOUT "List has been created \n";
 	exit 0;
    }else {
 	printf STDOUT "List has been created, required aliases :\n $resul->{'aliases'} \n";
 	exit 0;
    }
}elsif ($main::options{'instantiate_family'}) {
    
    my $robot = $main::options{'robot'} || Site->host;

    my $family_name;
    unless ($family_name = $main::options{'instantiate_family'}) {
 	print STDERR "Error : missing family parameter\n";
 	exit 1;
    }
    my $family;
    unless ($family = new Family($family_name,$robot)) {
 	print STDERR "The family $family_name does not exist, impossible instantiation\n";
 	exit 1;
    }

    unless ($main::options{'input_file'}) {
 	print STDERR "Error : missing input_file parameter\n";
 	exit 1;
    }

    unless (-r $main::options{'input_file'}) {
	print STDERR "Unable to read $main::options{'input_file'} file";
 	exit 1;	
    }

    unless ($family->instantiate($main::options{'input_file'}, $main::options{'close_unknown'})) {
 	print STDERR "\nImpossible family instantiation : action stopped \n";
 	exit 1;
    } 
        
    my %result;
    my $err = $family->get_instantiation_results(\%result);
    close INFILE;

    unless ($main::options{'quiet'}) {
        print STDOUT "@{$result{'info'}}";
        print STDOUT "@{$result{'warn'}}";
    }
    if ($err) {
        print STDERR "@{$result{'errors'}}";
    }
    
    exit 0;
}elsif ($main::options{'add_list'}) {
     
    my $robot = $main::options{'robot'} || Site->host;

    my $family_name;
    unless ($family_name = $main::options{'add_list'}) {
	print STDERR "Error : missing family parameter\n";
 	exit 1;
    }
    
    print STDOUT "\n************************************************************\n";
    
    my $family;
    unless ($family = new Family($family_name,$robot)) {
 	print STDERR "The family $family_name does not exist, impossible to add a list\n";
 	exit 1;
    }
    
    unless ($main::options{'input_file'}) {
 	print STDERR "Error : missing 'input_file' parameter\n";
 	exit 1;
    }

    unless (open INFILE, $main::options{'input_file'}) {
	print STDERR "\n Impossible to open input file  : $! \n";
 	exit 1;	
    }

    my $result;
    unless ($result = $family->add_list(\*INFILE)) {
 	print STDERR "\nImpossible to add a list to the family : action stopped \n";
 	exit 1;
    } 
    
    print STDOUT "\n************************************************************\n";
    
    unless (defined $result->{'ok'}) {
 	printf STDERR "\n%s\n", join ("\n", @{$result->{'string_info'}});
 	print STDERR "\n The action has been stopped because of error :\n";
 	printf STDERR "\n%s\n", join ("\n", @{$result->{'string_error'}});
 	exit 1;
    }
    
    close INFILE;

    print STDOUT "\n%s\n", join ("\n", @{$result->{'string_info'}});
    exit 0;
}elsif ($main::options{'sync_include'}) {

    my $list = new List ($main::options{'sync_include'});

    unless (defined $list) {
	print STDERR "Incorrect list name $main::options{'sync_include'}\n";
	exit 1;
    }

    unless (defined $list->sync_include()) {
	print STDERR "Failed to synchronize list members\n";
	exit 1;
    }

    printf "Members of list %s have been successfully update.\n", $list->get_list_address();
    exit 0;
## Migration from one version to another
}elsif ($main::options{'upgrade'}) {
    
    &Log::do_log('notice', "Upgrade process...");

    $main::options{'from'} ||= &Upgrade::get_previous_version();
    $main::options{'to'} ||= Sympa::Constants::VERSION;

    if ($main::options{'from'} eq $main::options{'to'}) {
	&Log::do_log('err', "Current version : %s ; no upgrade is required.", $main::options{'to'});
	exit 0;
    }else {
	&Log::do_log('notice', "Upgrading from %s to %s...", $main::options{'from'}, $main::options{'to'});
    }

    unless (&Upgrade::upgrade($main::options{'from'}, $main::options{'to'})) {
	&Log::do_log('err',  "Migration from %s to %s failed", $main::options{'from'}, $main::options{'to'});
 	exit 1;
    }

    &Log::do_log('notice', "Upgrade process finished.");    
    &Upgrade::update_version();

    exit 0;

## rename file names that may be incorrectly encoded because of previous Sympa versions
}elsif ($main::options{'upgrade_shared'}) {
    
    &Log::do_log('notice', "Upgrade shared process...");

    my $listname; my $robot;

    unless (($main::options{'list'}) || ($main::options{'robot'})){
	&Log::do_log('err', "listname and domain are required, use --list= --robot= options");
	exit 0;
    }
    $listname = $main::options{'list'} ;
    $robot = $main::options{'robot'} ;

    &Log::do_log('notice', "Upgrading share for list=%s robot=%s",$listname,$robot);
    

    my $list = new List ($listname,$robot);
    
    unless (defined $list) {
	printf STDERR "Incorrect list or domain name : %s %s\n",$listname,$robot;
	exit 1;
    }

    if (-d $list->dir . '/shared') {
	&Log::do_log('notice','  Processing list %s...', $list);
	
	## Determine default lang for this list
	## It should tell us what character encoding was used for filenames
	&Language::SetLang($list->lang);
	my $list_encoding = &Language::GetCharset();
	
	my $count = &tools::qencode_hierarchy($list->dir . '/shared', $list_encoding);
	
	if ($count) {
	    &Log::do_log('notice', 'List %s : %d filenames has been changed', $list, $count);
	}
    }
    &Log::do_log('notice', "Upgrade_shared process finished.");    

    exit 0;

}elsif ($main::options{'reload_list_config'}) {
    my $listname = $main::options{'list'};
    my $robot = $main::options{'robot'} || '';
    $listname = '' unless defined $listname;
    if ($listname =~ s/\@(.+)$//) {
	$robot = $1;
    }

    if (length $listname) {
	Log::do_log('notice', 'Loading list %s...', $listname);
	my $robot_object = Robot->new($robot || Site->domain);
	unless (defined $robot_object) {
	    print STDERR "Error : incorrect robot name '$robot'\n";
	    exit 1;
	}
	unless (List->new($listname, $robot_object, {'reload_config' => 1})) {
	    print STDERR "Error : incorrect list name '$listname'\n";
	    exit 1;
	}
    } else {
	my $that;
	if ($robot) {
	    Log::do_log('notice', 'Loading all lists in %s...', $robot);
	    $that = Robot->new($robot);
	    unless (defined $that) {
		print STDERR "Error : incorrect robot name '$robot'\n";
		exit 1;
	    }
	} else {
	    Log::do_log('notice', 'Loading ALL lists...');
	    $that = 'Site';
	}
	List::get_lists($that, { 'reload_config' => 1 });
    }
    Log::do_log('notice', '...Done.');

    exit 0;
}

##########################################
elsif ($main::options{'modify_list'}) {
    
    my $robot = $main::options{'robot'} || Site->host;

    my $family_name;
    unless ($family_name = $main::options{'modify_list'}) {
 	print STDERR "Error : missing family parameter\n";
 	exit 1;
    }
    
    print STDOUT "\n************************************************************\n";
    
    my $family;
    unless ($family = new Family($family_name,$robot)) {
 	print STDERR "The family $family_name does not exist, impossible to modify the list.\n";
 	exit 1;
    }
    
    unless ($main::options{'input_file'}) {
 	print STDERR "Error : missing input_file parameter\n";
 	exit 1;
    }

    unless (open INFILE, $main::options{'input_file'}) {
	print STDERR "Unable to open $main::options{'input_file'}) file";
 	exit 1;	
    }

    my $result;
    unless ($result = $family->modify_list(\*INFILE)) {
 	print STDERR "\nImpossible to modify the family list : action stopped. \n";
 	exit 1;
    } 
    
    print STDOUT "\n************************************************************\n";
    
    unless (defined $result->{'ok'}) {
 	printf STDERR "\n%s\n", join ("\n", @{$result->{'string_info'}});
 	print STDERR "\nThe action has been stopped because of error :\n";
 	printf STDERR "\n%s\n", join ("\n", @{$result->{'string_error'}});
 	exit 1;
    }

    close INFILE;
    
    printf STDOUT "\n%s\n", join ("\n", @{$result->{'string_info'}});
    exit 0;
}

##########################################
elsif ($main::options{'close_family'}) {
    
    my $robot = $main::options{'robot'} || Site->host;

    my $family_name;
    unless ($family_name = $main::options{'close_family'}) {
 	print STDERR $usage_string;
 	exit 1;
    }
    my $family;
    unless ($family = new Family($family_name,$robot)) {
 	print STDERR "The family $family_name does not exist, impossible family closure\n";
 	exit 1;
    }
    
    my $string;
    unless ($string = $family->close_family()) {
 	print STDERR "\nImpossible family closure : action stopped \n";
 	exit 1;
    } 
    
    print STDOUT $string;
    exit 0;
}
##########################################
elsif ($main::options{'sync_list_db'}) {       
    print STDERR "--sync_list_db was deprecated.  Use --reload_list_config.\n";
       exit 1;
}
##########################################
elsif ($main::options{'export_list'}) {
    my $robot = $main::options{'robot'} || '*';
    my $all_lists = List::get_lists($robot);
    exit 1 unless defined $all_lists;
        foreach my $list (@$all_lists) {
	printf "%s\n", $list->name;
        }
    exit 0;
}

## Do we have right access in the directory
if ($main::options{'keepcopy'}) {
    if (! -d $main::options{'keepcopy'}) {
	&Log::do_log('notice', 'Cannot keep a copy of incoming messages : %s is not a directory', $main::options{'keepcopy'});
	delete $main::options{'keepcopy'};
    }elsif (! -w $main::options{'keepcopy'}) {
	&Log::do_log('notice','Cannot keep a copy of incoming messages : no write access to %s', $main::options{'keepcopy'});
	delete $main::options{'keepcopy'};
    }
}

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'HUP'} = 'sighup';
$SIG{'PIPE'} = 'IGNORE'; ## Ignore SIGPIPE ; prevents sympa.pl from dying

my $index_queuedigest = 0; # verify the digest queue
my $index_cleanqueue = 0; 
my @qfile;

my $spoolname = 'msg';
my $spool = new Sympaspool ($spoolname);
## This is the main loop : look for files in the directory, handles
## them, sleeps a while and continues the good job.
while (!$signal) {

    &Language::SetLang($Language::default_lang);

    &List::init_list_cache();
    # Process grouped notifications
    Site->send_notify_to_listmaster(undef, undef, 1, undef);

    ## Scan queuedigest it should be performed by task manager !
    if ($index_queuedigest++ >=$digestsleep){
	$index_queuedigest=0;
	&SendDigest();
    }

    # it should be performed by task manager !
    ## Clean queue (bad)
    if ($index_cleanqueue++ >= 1000){
	$index_cleanqueue=0;
	&Log::do_log('debug','Cleaning spools');
	my $msg_bad = new Sympaspool('msg','bad'); 
	$msg_bad->clean({'delay'=>Site->clean_delay_queue});
	my $archive_bad = new Sympaspool('archive','bad'); 
	$archive_bad->clean({'delay'=>Site->clean_delay_queueoutgoing});
	my $queuebounce_bad = new Sympaspool('bounce','bad'); 
	$queuebounce_bad->clean({'delay'=>Site->clean_delay_queuebounce});
	my $queuemod = new Sympaspool('mod');
	$queuemod->clean({'delay'=> Site->clean_delay_queuemod});
	my $queueauth = new Sympaspool('auth');
	$queueauth->clean({'delay'=> Site->clean_delay_queueauth});
	my $queuetopic = new Sympaspool('topic');
	$queuetopic->clean({'delay'=> Site->clean_delay_queuetopic});
	my $queuesubscribe = new Sympaspool('subscribe');
	$queuesubscribe->clean({'delay'=> Site->clean_delay_queuesubscribe});
	my $queuesignoff = new Sympaspool('signoff');
	$queuesignoff->clean({'delay'=> Site->clean_delay_queuesignoff});
	my $queueautomatic = new Sympaspool('automatic');
	$queueautomatic->clean({'delay'=> Site->clean_delay_queueautomatic});
	# this is not a message spool
	&tools::CleanDir(Site->tmpdir, Site->clean_delay_tmpdir);
    }	    				          
    ## Cleanup in-memory msgid table, only in a while
    if (time > $latest_msgid_table_cleanup + Site->msgid_table_cleanup_frequency) {
	&clean_msgid_table();
	$latest_msgid_table_cleanup = time;
    }
    
    &mail::reaper; # finish terminated process
    
    my $message_in_spool = $spool->next;
    
    unless (($message_in_spool)||(defined $message_in_spool && defined $message_in_spool->{'priority'} && $message_in_spool->{'priority'} eq 'z')) {
	sleep(Site->sleep);
	next;
    }
    my $listname = $message_in_spool->{'list'};
    my $robot = $message_in_spool->{'robot'};
    &Log::do_log('debug', "Processing message # %s for list = %s robot = %s reception_date = %s", $message_in_spool->{'messagekey'},$listname,$robot,$message_in_spool->{'date'}) ;

    if ($main::options{'mail'} != 1) {
	$main::options{'mail'} = $robot if (&Conf::get_robot_conf($robot, 'log_smtp'));
    }

    ## Set NLS default lang for current message
    $Language::default_lang = $main::options{'lang'} || &Conf::get_robot_conf($robot, 'lang');

    my $status = &process_message($message_in_spool);

    if (defined($status)) {
	&Log::do_log('debug', "Message key %s  processed for list = %s robot = %s reception_date = %s", $message_in_spool->{'messagekey'},$listname,$robot,$message_in_spool->{'date'}) ;
	# Do not remove message task_manager will purge database removing messages in spool distribute that have no links with bulkspool_stable
	# $spool->remove_message({'messagekey' => $message_in_spool->{'messagekey'}});
    }else{
        # move message to bad.      
	$spool->update({'messagekey' => $message_in_spool->{'messagekey'}},{"message_status" => 'bad','messagelock'=> 'NULL'});
	&Log::do_log('debug', "Message # %s  moved to spool bad (message for list = %s robot = %s reception_date = %s)", $message_in_spool->{'messagekey'},$listname,$robot,$message_in_spool->{'date'}) ;
	}	
} ## END of infinite loop

# Purge grouped notifications
Site->send_notify_to_listmaster(undef, undef, undef, 1);

## Dump of User files in DB
#List::dump();

## Disconnect from Database
SDM::db_disconnect;

} #end of block while ($signal ne 'term'){

&Log::do_log('notice', 'Sympa exited normally due to signal');
my $file = Site->pidfile;
&tools::remove_pid($file, $$);

exit(0);


############################################################
# sigterm
############################################################
#  When we catch SIGTERM, just changes the value of the $signal 
#  loop variable.
#  
# IN : -
#      
# OUT : -
#
############################################################
sub sigterm {
    &Log::do_log('notice', 'signal TERM received, still processing current task');
    $signal = 'term';
}


############################################################
# sighup
############################################################
#  When we catch SIGHUP, changes the value of the $signal 
#  loop variable and puts the "-mail" logging option
#  
# IN : -
#      
# OUT : -
#
###########################################################
sub sighup {
    if ($main::options{'mail'}) {
	&Log::do_log('notice', 'signal HUP received, switch of the "-mail" logging option and continue current task');
	undef $main::options{'mail'};
    }else{
	&Log::do_log('notice', 'signal HUP received, switch on the "-mail" logging option and continue current task');
	$main::options{'mail'} = 1;
    }
    $signal = 'hup';
}



############################################################
#  process_message
############################################################
#  Handles a file received and files in the queue directory. 
#  This will read the file, separate the header and the body 
#  of the message and call the adequate function wether we 
#  have received a command or a message to be redistributed 
#  to a list.
#  
# IN : -$file (+): the file to handle
#      
# OUT : $status
#     | undef
#
##############################################################
sub process_message {
    my $message_in_spool = shift;
    &Log::do_log('debug', 'process_message()');

    my $listname;
    my $robot;
    my $status;

    my $message = new Message({'message_in_spool' => $message_in_spool});
    
    unless (defined $message) {
	Log::do_log('err',
	    'Unable to create Message object message : %s',
	    $message_in_spool->{'messagekey'});
	&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'process_message','target_email' => "",'msg_id' => '','status' => 'error','error_type' => 'unable_create_message','user_email' => '','client' => $ip,'daemon' => $daemon_name});
	return undef;
    }

    my $msg = $message->{'msg'};
    my $hdr = $msg->head;
    my $rcpt = $message->{'rcpt'};

    ## get listname & robot
    ($listname, $robot) = split(/\@/,$rcpt);
    $robot = lc($robot);
    $listname = lc($listname);
    $robot ||= Site->host; #FIXME: is "domain" better?

    ## Ignoring messages with no sender
    my $sender = $message->{'sender'};
    unless ($sender) {
	Log::do_log('err', 'No From found in message, skipping.');
	Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'no_sender','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }

    Log::do_log('notice', 'Processing: sender: %s ; message-id: %s',
	$sender, $hdr->get('Message-ID'));

    my $robot_object;
    ## Unknown robot
    unless ($robot_object = Robot->new($robot)) {
	Log::do_log('err', 'robot %s does not exist', $robot);
	Site->send_dsn($message, {'recipient' => $rcpt}, '5.1.2');
	Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'unknown_robot','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }

    my $type;
    ($listname, $type) = $robot_object->split_listname($listname);
	
    if ( $message->{'md5_check'} ) { 
	# message contain a valid checksum, it comes from wwsympa, so
        #  mail it without other proceding unless it is for a valid list
	return (&DoSendMessage ($message,$robot)) unless(&Conf::valid_robot($robot, {'just_try' => 1})) ;
	return (&DoSendMessage ($message,$robot)) unless( new List ($listname, $robot, {'just_try' => 1}));	    	    
    }

    # setting log_level using conf unless it is set by calling option
    unless ($main::options{'log_level'}) {
	Log::set_log_level($robot_object->log_level);
	Log::do_log('debug',
	    'Setting log level with robot %s configuration (or sympa.conf) : %d',
	    $robot_object->log_level
	);
    }

    ## Strip of the initial X-Sympa-To and X-Sympa-Checksum internal headers
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-Checksum');
    
    ## Initialize command report
    &report::init_report_cmd();

    my ($dyn_list_family, $dyn_just_created);	
    ## Maybe demon is handling an automatic list
    if($message->{'create_list_if_needed'}){
	# we care of fake headers. If we put it, it's the 1st one.
	if ($hdr->as_string() =~ /^X-Sympa-Family/mo) {
	    $dyn_list_family = $hdr->get('X-Sympa-Family');
	    chomp $dyn_list_family;
	}
    }
    $hdr->delete('X-Sympa-Family');

    my $list_address;

    my ($list, $host, $name);   

    my $conf_email = $robot_object->email;
    my $conf_host = $robot_object->host;
    my $site_email = Site->listmaster_email;
    my $site_host = Site->host;
    if ($listname =~ /^(sympa|$site_email|$conf_email)(\@$conf_host)?$/i) {
	$host = $conf_host;
	$name = $listname;
	$list_address = $name.'@'.$host;
    }else{
	$list = new List ($listname, $robot);
	unless (defined $list) {
	    unless ($dyn_list_family) {
		&Log::do_log('err', 'list %s does not exist',$listname);
		$robot_object->send_dsn(
		    $message, {'listname' => $listname}, '5.1.1'
		);
		&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'unknown_list','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		return undef;
	    }

	    ## Automatic creation of a mailing list, based on a family
            my $dyn_family;
            unless ($dyn_family = new Family($dyn_list_family,$robot)) {
                &Log::do_log(
		    'err',
		    "Failed to process message: family $dyn_list_family does not exist, impossible to create the dynamic list."
		);
		$robot_object->send_notify_to_listmaster(
		    'automatic_list_creation_failed',
		    "Failed to process message : family $dyn_list_family does not exist, impossible to create the dynamic list."
		);
		$robot_object->send_dsn(
		    $message, {'listname' => $listname}, '5.3.5'
		);
		return undef;
            }
            
	    my $auth_level =  'smtp';
	    $auth_level = 'dkim' if $message->{'dkim_pass'};
	    $auth_level = 'md5' if $message->{'md5_check'};
	    $auth_level = 'smime' if $message->{'smime_signed'};
	    my $result = Scenario::request_action($robot_object,
		'automatic_list_creation', $auth_level,
		{   'sender' => $sender, 'message' => $message, 
		    'family' => $dyn_list_family,
		    'automatic_listname' => $listname
		}
	    );
	    my $r_action;
	    unless (defined $result) {
		&Log::do_log(
		    'err', 'message (%s) ignored because unable to evaluate scenario "automatic_list_creation" for list %s',
		    $hdr->get('Message-Id'), $listname
		);
		&report::reject_report_msg(
		    'intern',
		    'Message ignored because scenario "automatic_list_creation" cannot be evaluated',
		    $sender,
		    {'msg_id' => $hdr->get('Message-Id'), 'message' => $message},
		    $robot, $message->{'msg_as_string'}
		);
		$robot_object->send_notify_to_listmaster(
		    'automatic_list_creation_failed',
		    "Failed to process message"
		);
		&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message',
			      'parameters' => $hdr->get('Message-Id').",$robot",'target_email' => '','msg_id' => hdr->get('Message-Id'),'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		return undef ;
            }
            $list = new List ($listname, $robot);
            unless (defined $list) {
                &Log::do_log(
		    'err', 'dynamic list %s could not be created',
		    $listname
		);
		$robot_object->send_dsn(
		    $message, {'listname' => $listname}, '4.2.1'
		);
		$robot_object->send_notify_to_listmaster(
		    'automatic_list_creation_failed',
		    "Failed to process $file."
		);
		return undef;
            }
	    $dyn_just_created = 1;
        }
	$host = $list->host;
	$name = $list->name;
	$list_address = $list->get_list_address();
    }
    ## Loop prevention
    if ($list and $list->reject_mail_from_automates_feature eq 'on') {
		my $conf_loop_prevention_regex;
	$conf_loop_prevention_regex = $list->loop_prevention_regex ||
	    $robot_object->loop_prevention_regex;
		if ($sender =~ /^($conf_loop_prevention_regex)(\@|$)/mio) {
			&Log::do_log('err','Ignoring message which would cause a loop, sent by %s; matches loop_prevention_regex', $sender);
			return undef;
		}
	
		## Ignore messages that would cause a loop
		## Content-Identifier: Auto-replied is generated by some non standard X400 mailer
		if ($hdr->get('Content-Identifier') =~ /Auto-replied/i ||
		$hdr->get('X400-Content-Identifier') =~ /Auto Reply to/i ||
		($hdr->get('Auto-Submitted') && $hdr->get('Auto-Submitted') ne 'no')) {
			&Log::do_log('err', "Ignoring message which would cause a loop; message appears to be an auto-reply");
			return undef;
		}
	}

    ## Q- and B-decode subject
    my $subject_field = $message->{'decoded_subject'};

    ## Loop prevention
    my $loop;
    foreach $loop ($hdr->get('X-Loop')) {
	chomp $loop;
	&Log::do_log('debug2','X-Loop: %s', $loop);
	#foreach my $l (split(/[\s,]+/, lc($loop))) {
	    if ($loop eq lc($list_address)) {
		&Log::do_log('err', "Ignoring message which would cause a loop (X-Loop: $loop)");
		return undef;
	    }
	#}
    }
    
    ## S/MIME or DKIM signed messages
    if ($message->{'smime_signed'}) {
	$is_signed = {'subject' => $message->{'smime_subject'},# subject semantic is relater to X509 (subject is the private key owner, not the message Subject header !)
		      'body' => 'smime'};
    }else{
	undef $is_signed;
    }
	
    #  anti-virus
    my $rc= &tools::virus_infected($message->{'msg'});
    if ($rc) {
	if ($robot_object->antivirus_notify eq 'sender') {
	    unless ($robot_object->send_file(
		'your_infected_msg', $sender,
		{'virus_name' => $rc,
										   'recipient' => $list_address,
		'lang' => ($robot_object->lang || 'en'),
		'auto_submitted' => 'auto-replied'}
	    )) {
		&Log::do_log('notice',"Unable to send template 'your infected_msg' to $sender");
	    }
	}
	&Log::do_log('notice', "Message for %s from %s ignored, virus %s found", $list_address, $sender, $rc);
	&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'virus','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;

    }elsif (! defined($rc)) {
 	unless ($robot_object->send_notify_to_listmaster(
	    'antivirus_failed',
	    "Could not scan message; The message has been saved as BAD."
	)) {
 	    &Log::do_log('notice', 'Unable to send notify "antivirus_failed" to listmaster');
 	}

	return undef;
    }

    if (Site->automatic_list_feature eq 'on')  {
        if ($dyn_list_family && $dyn_just_created) {
            unless (defined $list->sync_include()) {
		&Log::do_log(
		    'err', 'Failed to synchronize list members of dynamic list %s from %s family',
		     $listname, $dyn_list_family
		);
		$robot_object->send_dsn(
		    $message, {'listname' => $listname}, '4.2.1'
		);
		#FIXME: Notify listmaster?
		&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'dyn_cant_sync','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		# purge the unwanted empty automatic list
		if (Site->automatic_list_removal =~ /if_empty/i) {
		    $list->close_list();
		    $list->purge(); # verifier pour tt ce bloc si supprime bien tout
		    }
                return undef;
            }
            unless ($list->total > 0) {
		&Log::do_log(
		    'err',
		    'Dynamic list %s from %s family has ZERO subscribers',
		    $list, $dyn_list_family
		);
		$list->send_dsn($message, {}, '4.2.4');
		&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message','target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'error','error_type' => 'list_unknown','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		# purge the unwanted empty automatic list
		if (Site->automatic_list_removal =~ /if_empty/i) {
		    $list->close_list();
		    $list->purge(); # verifier pour tt ce bloc si supprime bien tout
		    }
                return undef;
            }
            &Log::do_log('info', 'Successfully create list %s with %s subscribers', $listname, $list->total);
        }
    } 

    if ($rcpt =~ /^listmaster(\@(\S+))?$/) {
	$status = &DoForward('sympa', 'listmaster', $robot, $message);

	## Mail adressed to the robot and mail 
	## to <list>-subscribe or <list>-unsubscribe are commands
    }elsif (($rcpt =~ /^(sympa|$conf_email)(\@\S+)?$/i) || ($type =~ /^(subscribe|unsubscribe)$/o)) {
	$status = &DoCommand($rcpt, $robot, $message);
	
	## forward mails to <list>-request <list>-owner etc
    }elsif ($type =~ /^(request|owner|editor)$/o) {
	
	## Simulate Smartlist behaviour with command in subject
	if (($type eq 'request') and ($subject_field =~ /^\s*(subscribe|unsubscribe)(\s*$listname)?\s*$/i) ) {
	    my $command = $1;
	    
	    $status = &DoCommand("$listname-$command", $robot, $message);
	}else {
	    $status = &DoForward($listname, $type, $robot, $message);
	}         
    }else {	
	$status =  &DoMessage($rcpt, $message, $robot);
    }

    ## Mail back the result.
    if (&report::is_there_any_report_cmd()) {

	## Loop prevention

	## Count reports sent to $sender
	$loop_info{$sender}{'count'}++;
	
	## Sampling delay 
	if ((time - $loop_info{$sender}{'date_init'}) <
	    Site->loop_command_sampling_delay) {

	    ## Notify listmaster of first rejection
	    if ($loop_info{$sender}{'count'} == Site->loop_command_max) {
		## Notify listmaster
		unless ($robot_object->send_notify_to_listmaster(
		    'loop_command', {'msg' => $file}
		)) {
		    &Log::do_log(
			'notice',
			'Unable to send notify "loop_command" to listmaster'
		    );
		}
	    }
	    
	    ## Too many reports sent => message skipped !!
	    if ($loop_info{$sender}{'count'} >= Site->loop_command_max) {
		&Log::do_log('err', 'Ignoring message which would cause a loop, %d messages sent to %s; loop_command_max exceeded', $loop_info{$sender}{'count'}, $sender);
		
		return undef;
	    }
	}else {
	    ## Sampling delay is over, reinit
	    $loop_info{$sender}{'date_init'} = time;

	    ## We apply Decrease factor if a loop occured
	    $loop_info{$sender}{'count'} *=
		Site->loop_command_decrease_factor;
	}

	## Send the reply message
	&report::send_report_cmd($sender,$robot);
	&Log::db_log({'robot' => $robot,'list' => $listname,'action' => 'Process_message','parameters' => "$file",'target_email' => "",'msg_id' => $hdr->get('Message-ID'),'status' => 'success','error_type' => '','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});

    }
    
    return $status;
}


############################################################
#  DoSendMessage
############################################################
#  Send a message pushed in spool by another process. 
#  
# IN : -$msg (+): ref(MIME::Entity)
#      -$robot (+) :robot
#      
# OUT : 1 
#     | undef
#
############################################################## 
sub DoSendMessage {
    my $message = shift;
    my $robot = shift;
    &Log::do_log('debug', 'DoSendMessage()');

    my $hdr = $message->{'msg'}->head;
    
    my $chksum = $hdr->get('X-Sympa-Checksum');
    my $rcpt = $hdr->get('X-Sympa-To');
    my $from = $hdr->get('X-Sympa-From');
    chomp $rcpt; chomp $chksum; chomp $from;

    &Log::do_log('info', "Processing web message for %s", $rcpt);
    
    my $string = $message->{'msg'}->as_string;
    my $msg_id = $hdr->get('Message-ID');
    my $sender = $hdr->get('From');

    $hdr->delete('X-Sympa-Checksum');
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-From');
    
    ## Multiple recepients
    my @rcpts = split /,/,$rcpt; #/
   
    unless (&mail::mail_forward($message,$from,\@rcpts,$robot)) {
	&Log::do_log('err',"sympa::DoSendMessage(): Impossible to forward mail from $from");
	&report::reject_report_msg('intern','Impossible to forward a message pushed in spool by another process than sympa.pl.',$sender,
			  {'msg_id' => $msg_id,'message' => $message->{'msg'}},$robot,$string,'');
	&Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'sendMessage','parameters' => "$msg_id,$rcpt",'target_email' => '','msg_id' => $msg_id,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }

    &Log::do_log('info', "Message for %s sent", $rcpt);
    &Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'sendMessage','parameters' => "$msg_id,$rcpt",'target_email' => '','msg_id' => $msg_id,'status' => 'succes','error_type' => '','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});

    return 1;
}

############################################################
#  DoForward                             
############################################################
#  Handles a message sent to [list]-editor : the list editor, 
#  [list]-request : the list owner or the listmaster. 
#  Message is forwarded according to $function
#  
# IN : -$name : list name (+) if ($function <> 'listmaster')
#      -$function (+): 'listmaster'|'request'|'editor'
#      -$robot (+): robot
#      -$msg (+): ref(message object).
#
# OUT : 1 
#     | undef
#
############################################################
sub DoForward {
    &Log::do_log('debug2', '(%s, %s, %s, ...)', @_);
    my($name, $function, $robot, $message) = @_;
    &Log::do_log('debug', 'DoForward(%s, %s)', $name, $function);

    my $robot_object = Robot->new($robot);

    my $msg = $message->{'msg'};
    my $hdr = $msg->head;
    my $messageid = $hdr->get('Message-Id');
    chomp $messageid;
    my $msg_string = $msg->as_string;
    my $sender = $hdr->get('From');
    chomp $sender;

    if ($message->{'spam_status'} eq 'spam'){
	&Log::do_log('notice', "Message for %s-%s ignored, because tagued as spam (Message-id: %s)",$name, $function,$messageid);
	return undef;
    }

    ##  Search for the list
    my ($list, $host, $recepient, $priority);

    if ($function eq 'listmaster') {
        $recepient = $robot_object->listmaster_email;
        $host = $robot_object->host;
	$priority = 0;
    }else {
	unless ($list = new List ($name, $robot)) {
	    &Log::do_log(
		'notice',
		'Message for %s-%s ignored, unknown list %s (Message-id: %s)',
		$name, $function, $name, $messageid
	    );
	    $robot_object->send_dsn(
		$message, {'listname' => $name, 'function' => $function},
		'5.1.1'
	    );
	    return undef;
	}
	
	$host = $list->host;
        $recepient="$name-$function";
	$priority = $list->priority;
    }

    my @rcpt;
    
    &Log::do_log('info', "Processing message for %s with priority %s, (Message-id:%s)", $recepient, $priority, $messageid );
    
    $hdr->add('X-Loop', "$name-$function\@$host");
    $hdr->delete('X-Sympa-To');
    $hdr->delete('X-Sympa-Family');

    if ($function eq "listmaster") {
	@rcpt = @{$robot_object->listmasters};
	&Log::do_log('notice', 'Warning : no listmaster defined in sympa.conf') 
	    unless (@rcpt);
    }elsif ($function eq "request") {
	@rcpt = $list->get_owners_email();

	&Log::do_log('notice', 'Warning : no owner defined or all of them use nomail option in list %s', $name ) 
	    unless (@rcpt);

    }elsif ($function eq "editor") {
	@rcpt = $list->get_editors_email();

	&Log::do_log('notice', 'Warning : no owner and editor defined or all of them use nomail option in list %s', $name ) 
	    unless (@rcpt);
    }

    ## Did we find a recipient?
    if ($#rcpt < 0) {
	if ($function ne "listmaster") {
	    &Log::do_log('err', "No recipient available for %s-%s in list %s. Trying to proceed ignoring nomail option (message-id %s)", $name, $function, $name,$messageid);
	    
	    if ($function eq "request") {
		@rcpt = $list->get_owners_email({'ignore_nomail',1});
		
		&Log::do_log('notice', 'Warning : no owner defined at all in list %s', $name ) 
		    unless (@rcpt);
		
	    }elsif ($function eq "editor") {
		@rcpt = $list->get_editors_email({'ignore_nomail',1});
		
		&Log::do_log('notice', 'Warning : no owner and editor defined at all in list %s', $name ) 
		    unless (@rcpt);
	    }
	}
        ## Could we find a recipient by ignoring the "nomail" option?
	if ($#rcpt >= 0) {
	    &Log::do_log('notice', 'All the intended recipients of message %s in list %s have set the "nomail" option. Ignoring it and sending it to all of them.', $messageid, $name );
	}
	else {
	    &Log::do_log('err', "sympa::DoForward(): Message for %s-%s ignored, %s undefined in list %s", $name, $function, $function, $name);
	    my $string = sprintf 'Impossible to forward a message to %s-%s : undefined in this list',$name,$function;
	    &report::reject_report_msg('intern',$string,$sender,
				       {'msg_id' => $messageid,
					'entry' => 'forward',
					'function' => $function,
					'message' => $msg }
				       ,$robot,$msg_string,$list);
	    &Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoForward','parameters' => "$name,$function",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	    return undef;
	}
    }
    
    # my $msg_copy = $msg->dup;
    $message->{'msg'} = $msg;    
    unless (mail::mail_forward($message,
	$robot_object->get_address('owner'), \@rcpt, $robot_object
    )) {
	&Log::do_log('err',"Impossible to forward mail for $name-$function  ");
	my $string = sprintf 'Impossible to forward a message for %s-%s',$name,$function;
	&report::reject_report_msg('intern',$string,$sender,
			  {'msg_id' => $messageid,
			   'entry' => 'forward',
			   'function' => $function,
			   'message' => $msg}
			  ,$robot,$msg_string,$list);
	&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoForward','parameters' => "$name,$function",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }
    &Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoForward','parameters' => "$name,$function",'target_email' => '','msg_id' => $messageid,'status' => 'success','error_type' => '','user_email' => $sender, 'client' => $ip,'daemon' => $daemon_name});

    return 1;
}

####################################################
#  DoMessage                             
####################################################
#  Handles a message sent to a list. (Those that can 
#  make loop and those containing a command are 
#  rejected)
#  
# IN : -$which (+): 'listname@hostname' - concerned list
#      -$message (+): ref(Message) - sent message
#      -$robot (+): robot
#
# OUT : 1 if ok (in order to remove the file from the queue)
#     | undef
#
####################################################
sub DoMessage{
    my($which, $message, $robot) = @_;
    &Log::do_log('debug', 'DoMessage(%s, %s, %s, msg from %s, %s, %s)', $which, $message->{'msg'}, $robot, $message->{'sender'}, $message->{'size'},  $message->{'smime_crypted'});

    my $robot_object = Robot->new($robot);
    
    ## List and host.
	    my($listname, $host) = split(/[@\s]+/, $which);
	    
	    my $hdr = $message->{'msg'}->head;


	    my $messageid = $hdr->get('Message-Id');
    chomp $messageid;
	    my $msg = $message->{'msg'};
	    my $msg_string = $msg->as_string;
	    
	    my $sender = $message->{'sender'};

    my $list;
	    ## List unknown
    unless ($list = List->new($listname, $robot_object)) {
		&Log::do_log('notice', 'Unknown list %s', $listname);
	$robot_object->send_dsn(
	    $message, {'listname' => $listname}, '5.1.1'
	);
		return undef;
	    }

    ($listname, $host) = ($list->name, $list->host);
	    my $start_time = time;
    &Language::SetLang($list->lang);

	    ## Now check if the sender is an authorized address.

    &Log::do_log('info',
	'Processing message for %s with priority %s, %s',
	$list, $list->priority, $messageid);

    if ($msgid_table{$list->get_list_id()}{$messageid}) {
		&Log::do_log('err', 'Found known Message-ID, ignoring message which would cause a loop');
		&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'known_message','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		return undef;
    }
	
    # Reject messages with commands
    if (Site->misaddressed_commands =~ /reject/i) {
	## Check the message for commands and catch them.
	if (&tools::checkcommand($message->{'msg'}, $sender, $robot)) {
	    &Log::do_log('err', 'sympa::DoMessage(): Found command in message, ignoring message');
	    &report::reject_report_msg('user','routing_error',$sender,{'message' => $message},$robot,$msg_string,$list);
	    &Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'routing_error','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	    return undef;
	}
    }
	
    ## Check if the message is too large
    # my $max_size = $list->get_max_size() || $robot_object->max_size;
    my $max_size = $list->get_max_size();

    if ($max_size && $message->{'size'} > $max_size) {
		&Log::do_log(
		    'info', 'Message for %s from %s rejected because too large (%d > %d)',
		    $listname, $sender, $message->{'size'}, $max_size
		);
		$list->send_dsn(
		    $message,
		    {   'msg_size' => int($message->{'size'} / 1024),
			'max_size' => int($max_size / 1024) },
		    '5.2.3'
		);
		&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'message_too_large','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		return undef;
   }
    
    my $rc;
	
    my $context =  {'sender' => $sender,
		    'message' => $message };
	
    ## list msg topic	
    if ($list->is_there_msg_topic()) {

	my $info_msg_topic = $list->load_msg_topic($messageid);

	# is msg already tagged ?	
	if (ref($info_msg_topic) eq "HASH") { 
	    if ($info_msg_topic->{'method'} eq "sender") {
		$context->{'topic_sender'} =  $info_msg_topic->{'topic'};
		
	    }elsif ($info_msg_topic->{'method'} eq "editor") {
		$context->{'topic_editor'} =  $info_msg_topic->{'topic'};
	    
	    }elsif ($info_msg_topic->{'method'} eq "auto") {
		$context->{'topic_auto'} =  $info_msg_topic->{'topic'};
	    }

	# not already tagged   
	} else {
	    $context->{'topic_auto'} = $list->automatic_tag($message->{'msg'},$robot);
	}

	$context->{'topic'} = $context->{'topic_auto'} || $context->{'topic_sender'} || $context->{'topic_editor'};
	$context->{'topic_needed'} = (!$context->{'topic'} && $list->is_msg_topic_tagging_required());
    }
	
    ## Call scenarii : auth_method MD5 do not have any sense in send
    ## scenarii because auth is perfom by distribute or reject command.
	
    my $action;
    my $result;	

    # the order of the following 3 lines is important ! SMIME > DKIM > SMTP
    my $auth_method = 'smtp';   
    $auth_method = 'dkim' if ($message->{'dkim_pass'});
    $auth_method = 'md5' if ($message->{'md5_check'});
    $auth_method = 'smime' if ($is_signed->{'body'}) ;
    
    $result = Scenario::request_action($list, 'send', $auth_method, $context);
    $action = $result->{'action'} if (ref($result) eq 'HASH');

    unless (defined $action) {
	&Log::do_log('err', 'sympa::DoMessage(): message (%s) ignored because unable to evaluate scenario "send" for list %s',$messageid,$listname);
	&report::reject_report_msg('intern','Message ignored because scenario "send" cannot be evaluated',$sender,
			  {'msg_id' => $messageid,'message' => $message},
			  $robot,$msg_string,$list);
	&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef ;
    }

    ## message topic context	
    if (($action =~ /^do_it/) && ($context->{'topic_needed'})) {
	$action = 'editorkey'
	    if $list->msg_topic_tagging eq 'required_moderator';
	$action = 'request_auth'
	    if $list->msg_topic_tagging eq 'required_sender';
    }

    if ($action =~ /^do_it/) {
	my $apply_dkim_signature = 'off';
	$apply_dkim_signature = 'on'
	    if &tools::is_in_array($list->dkim_signature_apply_on, 'any');
	$apply_dkim_signature = 'on'
	    if &tools::is_in_array($list->dkim_signature_apply_on,
		'smime_authenticated_messages') and
	    $is_signed->{'body'};
	$apply_dkim_signature = 'on'
	    if &tools::is_in_array($list->dkim_signature_apply_on,
		'dkim_authenticated_messages');
	
	my $numsmtp;
	eval {
	    $numsmtp = $list->distribute_msg('message' => $message,
		'apply_dkim_signature' => $apply_dkim_signature);
	};
	if ($@) {
	    &Log::do_log('err',
		'FATAL: Failed to distribute message: %s', $@);
	}
	## Keep track of known message IDs...if any
	$msgid_table{$list->get_list_id()}{$messageid} = time if ($messageid);
	
	unless (defined($numsmtp)) {
	    &Log::do_log('err','sympa::DoMessage(): Unable to send message to list %s', $listname);
	    &report::reject_report_msg('intern','',$sender,{'msg_id' => $messageid,'message' => $message},$robot,$msg_string,$list);
	    &Log::db_log({'robot' => $robot, 'list' => $list->name, 'action' => 'DoMessage', 'parameters' => "$which, $messageid, $robot", 'target_email' => '', 'msg_id' => $messageid, 'status' => 'error', 'error_type' => 'internal', 'user_email' => $sender, 'client' => $ip, 'daemon' => $daemon_name});
	    return undef;
	}
	&Log::do_log('info', 'Message for %s from %s accepted (%d seconds, %d sessions, %d subscribers), message-id=%s, size=%d', $list, $sender, time - $start_time, $numsmtp, $list->total, $messageid, $message->{'size'});
	
	return 1;
	
    }elsif($action =~ /^request_auth/){
    	my $key = $list->send_auth($message);
	
	unless (defined $key) {
	    &Log::do_log('err','sympa::DoMessage(): Calling to send_auth function failed for user %s in list %s', $sender, $list);
	    &report::reject_report_msg('intern', 'The request authentication sending failed',$sender,{'msg_id' => $messageid, 'message' => $message}, $robot, $msg_string, $list);
	    &Log::db_log({'robot' => $robot, 'list' => $list->name, 'action' => 'DoMessage', 'parameters' => "$which, $messageid, $robot", 'target_email' => '', 'msg_id' => $messageid, 'status' => 'error', 'error_type' => 'internal', 'user_email' => $sender, 'client' => $ip, 'daemon' => $daemon_name});
	    return undef
	}
	&Log::do_log('notice', 'Message for %s from %s kept for authentication with key %s', $list, $sender, $key);
	&Log::db_log({'robot' => $robot, 'list' => $list->name, 'action' => 'DoMessage', 'parameters' => "$which, $messageid, $robot", 'target_email' => '', 'msg_id' => $messageid, 'status' => 'success', 'error_type' => 'kept_for_auth', 'user_email' => $sender, 'client' => $ip, 'daemon' => $daemon_name});
	return 1;
    } elsif ($action =~ /^editorkey((?:\s*,\s*quiet)?)/) {
	my $is_quiet = $1 || undef;
	my $key = $list->send_to_editor('md5',$message);

	unless (defined $key) {
	    &Log::do_log('err', 'sympa::DoMessage(): Calling to send_to_editor() function failed for user %s in list %s', $sender, $list);
	    &report::reject_report_msg('intern', 'The request moderation sending to moderator failed.', $sender, {'msg_id' => $messageid, 'message' => $message}, $robot, $msg_string, $list);
	    &Log::db_log({'robot' => $robot, 'list' => $list->name, 'action' => 'DoMessage', 'parameters' => "$which, $messageid, $robot", 'target_email' => '','msg_id' => $messageid, 'status' => 'error', 'error_type' => 'internal', 'user_email' => $sender, 'client' => $ip, 'daemon' => $daemon_name});
	    return undef
	}

	&Log::do_log('info', 'Key %s for list %s from %s sent to editors, %s', $key, $list, $sender, $message->{'filename'});
	
	# do not report to the sender if the message was tagged as a spam
	unless ($is_quiet or $message->{'spam_status'} eq 'spam') {
	    unless (&report::notice_report_msg('moderating_message',$sender,{'message' => $message},$robot,$list)) {
		&Log::do_log('notice', 'Unable to send template "message_report", entry "moderating_message" to %s', $sender);
	    }
	}
	return 1;
    } elsif ($action =~ /^editor((?:\s*,\s*quiet)?)/) {
	my $is_quiet = $1 || undef;
	my $key = $list->send_to_editor('smtp', $message);

	unless (defined $key) {
	    &Log::do_log('err','sympa::DoMessage(): Calling to send_to_editor() function failed for user %s in list %s', $sender, $list);
	    &report::reject_report_msg('intern','The request moderation sending to moderator failed.',$sender,{'msg_id' => $messageid,'message' => $message},$robot,$msg_string,$list);
	    &Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	    return undef
	}

	&Log::do_log('info', 'Message for %s from %s sent to editors', $list, $sender);
	
	# do not report to the sender if the message was tagged as a spam
	unless ($is_quiet or $message->{'spam_status'} eq 'spam') {
	    unless (&report::notice_report_msg('moderating_message',$sender,{'message' => $message},$robot,$list)) {
		&Log::do_log('notice', 'Unable to send template "message_report", type "success", entry "moderating_message" to %s', $sender);
	    }
	}
	return 1;
    } elsif ($action =~ /^reject((?:\s*,\s*quiet)?)/) {
	my $is_quiet = $1 || undef;
	&Log::do_log('notice', 'Message for %s from %s rejected(%s) because sender not allowed', $list, $sender, $result->{'tt2'});

	# do not report to the sender if the message was tagued as a spam
	unless ($is_quiet or $message->{'spam_status'} eq 'spam') {
	    if (defined $result->{'tt2'}) {
		unless ($list->send_file($result->{'tt2'}, $sender, {'auto_submitted' => 'auto-replied'})) {
		    &Log::do_log('notice',"sympa::DoMessage(): Unable to send template '$result->{'tt2'}' to $sender");
		}
	    }else {
		unless (&report::reject_report_msg('auth',$result->{'reason'},$sender,{'message' => $message},$robot,$msg_string,$list)) {
		    &Log::do_log('notice',"sympa::DoMessage(): Unable to send template 'message_report', type 'auth' to $sender");
		}
	    }
	}
	&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'rejected_authorization','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }else {
	&Log::do_log('err','sympa::DoMessage(): unknown action %s returned by the scenario "send"', $action);
	&report::reject_report_msg('intern','Unknown action returned by the scenario "send"',$sender,{'msg_id' => $messageid,'message' => $message},$robot,$msg_string,$list);
	&Log::db_log({'robot' => $robot,'list' => $list->name,'action' => 'DoMessage','parameters' => "$which,$messageid,$robot",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'internal','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }
}

############################################################
#  DoCommand
############################################################
#  Handles a command sent to the list manager.
#  
# IN : -$rcpt : recepient | <listname>-<subscribe|unsubscribe> 
#      -$robot (+): robot
#      -$message : ref(Message) with :
#        ->msg (+): ref(MIME::Entity) : message containing command
#        ->filename (+): file containing message
#      
# OUT : $success
#     | undef
#
############################################################## 
sub DoCommand {
    my($rcpt, $robot, $message) = @_;
    my $msg = $message->{'msg'};
    my $file = $message->{'filename'};
    &Log::do_log('debug', 'DoCommand(%s %s %s %s) ', $rcpt, $robot, $msg, $file);
    
    ## boolean
    my $cmd_found = 0;
    
    ## Now check if the sender is an authorized address.
    my $hdr = $msg->head;
    
    ## Decode headers
    #$hdr->decode();
    
    my $messageid = $hdr->get('Message-Id');
    chomp $messageid;
    my ($success, $status);
    
    &Log::do_log('debug', "Processing command with priority %s, %s", Site->sympa_priority, $messageid );
    
    my $sender = $message->{'sender'};

    if ($msg->{'spam_status'} eq 'spam'){
	&Log::do_log('notice', "Message for robot %s@%s ignored, because tagged as spam (Message-id: %s)",$rcpt,$robot,$messageid);
	return undef;
    }

    ## Detect loops
    if ($msgid_table{'sympa@'.$robot}{$messageid}) {
	&Log::do_log('err', 'Found known Message-ID, ignoring command which would cause a loop');
	&Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'known_message','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }## Clean old files from spool
    
    ## Keep track of known message IDs...if any
    $msgid_table{'sympa@'.$robot}{$messageid} = time
	if ($messageid);

    ## If X-Sympa-To = <listname>-<subscribe|unsubscribe> parse as a unique command
    if ($rcpt =~ /^(\S+)-(subscribe|unsubscribe)(\@(\S+))?$/o) {
	&Log::do_log('debug',"processing message for $1-$2");
	my $auth_level ;
	$auth_level = 'dkim' if $message->{'dkim_pass'}; # at this point $message->{'dkim_pass'} does not verify that Subject: is part of the signature. It SHOULD !
	&Commands::parse($sender,$robot,"$2 $1",$auth_level ,$message);
	&Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'success','error_type' => '','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return 1; 
    }
    
    ## Process the Subject of the message
    ## Search and process a command in the Subject field
    my $subject_field = $message->{'decoded_subject'};
    $subject_field =~ s/\n//mg; ## multiline subjects
    my $re_regexp = tools::get_regexp('re');
    $subject_field =~ s/^\s*(?:$re_regexp)?\s*(.*)\s*$/$1/i;

    my $auth_level = 'dkim' if ($message->{'dkim_pass'});
    $auth_level = $is_signed->{'subject'} if ($is_signed->{'subject'}) ;

    $success ||= &Commands::parse($sender, $robot, $subject_field, $auth_level, $message) ;

    unless ($success eq 'unknown_cmd') {
	$cmd_found = 1;
    }

    ## Make multipart singlepart
    if ($msg->is_multipart()) {
	my $status = &tools::as_singlepart($msg, 'text/plain');

	unless (defined $status) {
	    &Log::do_log('err', 'Could not change multipart to singlepart');
	    &report::global_report_cmd('user','error_content_type',{});
	    &Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'error_content_type','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	    return undef;
	}

	if ($status) {
	    &Log::do_log('debug', 'Multipart message changed to singlepart');
	}
    }

    my $i;
    my $size;

    ## Process the body of the message
    ## unless subject contained commands or message has no body
    if ( (!$cmd_found) && (defined $msg->bodyhandle)) { 

	## check Content-type
	my $mime = $hdr->get('Mime-Version') ;
	my $content_type = $msg->effective_type;
	## Get charset
	my $cset =
	    MIME::Charset->new($hdr->mime_attr('Content-Type.Charset'));
	unless ($cset->decoder) {
	    # Charset is unknown.  Detect 7-bit charset.
	    my ($dummy, $charset) =
		MIME::Charset::body_encode($msg->bodyhandle->as_string,
					   '', Detect7Bit => 'YES');
	    $cset = MIME::Charset->new($charset);
	}
	if ($cset->decoder) {
	    $cset->encoder('UTF-8');
	} else {
	    $cset = MIME::Charset->new('US-ASCII');
	}

	unless (($content_type =~ /text/i and !$mime)
		or !($content_type) 
		or ($content_type =~ /text\/plain/i)) {
	    &Log::do_log('err', "Ignoring message body not in text/plain, Content-type: %s", $content_type);
	    &report::global_report_cmd('user','error_content_type',{});
	    &Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'error_content_type','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	    return $success; 
	}
	
	my @body = $msg->bodyhandle->as_lines();
	foreach $i (@body) {
	    $i = $cset->encode($i);

	    last if ($i =~ /^-- $/); ## ignore signature
	    last if ($i =~ /^-- $/); ## ignore signature
	    $i =~ s/^\s*>?\s*(.*)\s*$/$1/g;
	    next if ($i =~ /^$/); ## skip empty lines
	    next if ($i =~ /^\s*\#/) ;
	    
	    &Log::do_log('debug2',"is_signed->body $is_signed->{'body'}");
	    
	    $auth_level = 'dkim' if ($message->{'dkim_pass'});
	    $auth_level = $is_signed->{'body'} if ($is_signed->{'body'}) ;
	    $status = &Commands::parse($sender, $robot, $i, $auth_level, $message);

	    $cmd_found = 1; # if problem no_cmd_understood is sent here
	    if ($status eq 'unknown_cmd') {
		&Log::do_log('notice', "Unknown command found :%s", $i);
		&report::reject_report_cmd('user', 'not_understood', {}, $i);
		&Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'not_understood','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
		last;
	    }	    
	    if ($i =~ /^(quit|end|stop|-)\s*$/io) {
		last;
	    }
	    
	    $success ||= $status;
	}
    }

    ## No command found
    unless ($cmd_found == 1) {
	&Log::do_log('info', "No command found in message");
	&report::global_report_cmd('user','no_cmd_found',{});
	&Log::db_log({'robot' => $robot,'list' => $rcpt,'action' => 'DoCommand','parameters' => "$rcpt,$robot,$message",'target_email' => '','msg_id' => $messageid,'status' => 'error','error_type' => 'no_cmd_found','user_email' => $sender,'client' => $ip,'daemon' => $daemon_name});
	return undef;
    }
    
    return $success;
}

############################################################
#  SendDigest
############################################################
#  Read the queuedigest and send old digests to the subscribers 
#  with the digest option.
#  
# IN : -
#      
# OUT : -
#     | undef
#
############################################################## 
sub SendDigest{
    &Log::do_log('debug', 'SendDigest()');

    my $digestspool = new Sympaspool('digest');

    foreach my $digest ($digestspool->get_content({'selection'=>'messagekey,list,robot,date'})){
 	my $list = new List ($digest->{'list'}, $digest->{'robot'});
	unless ($list) {
	    &Log::do_log('info', 'Unknown list %s, (robot %s), deleting digest (messagekey %s)',$digest->{'list'}, $digest->{'messagekey'} );
	    &Log::db_log({'robot' => $digest->{'robot'},'list' => $digest->{'list'},'action' => 'SendDigest','parameters' => "$digest->{'messagekey'}",'target_email' => '','msg_id' => '','status' => 'error','error_type' => 'unknown_list','user_email' => '','client' => $ip,'daemon' => $daemon_name});
	    $digestspool->remove_message({'messagekey'=>$digest->{'messagekey'}});
	    next;
	}

	&Language::SetLang($list->lang);

	if ($list->get_nextdigest($digest->{'date'})){
	    ## Blindly send the message to all users.
	    &Log::do_log('info', 'Sending digest to list %s', $list);
	    my $start_time = time;
	    $list->send_msg_digest($digest->{'messagekey'});

	    &Log::do_log('info', 'Digest of the list %s sent (%d seconds)', $list, time - $start_time);
	    &Log::db_log({'robot' => $list->{'robot'},'list' => $list->name,'action' => 'SendDigest','parameters' => "",'target_email' => '','msg_id' => '','status' => 'success','error_type' => '','user_email' => '','client' => $ip,'daemon' => $daemon_name});
	    $digestspool->remove_message({'messagekey'=>$digest->{'messagekey'}});
	}
    }
}

## Cleanup the msgid_table every 'msgid_table_cleanup_frequency' sec
## Removes all entries older than 'msgid_table_cleanup_ttl' sec
sub clean_msgid_table {
	
	foreach my $rcpt (keys %msgid_table) {
		foreach my $msgid (keys %{$msgid_table{$rcpt}}) {
			if (time > $msgid_table{$rcpt}{$msgid} + Site->msgid_table_cleanup_ttl) {
				delete $msgid_table{$rcpt}{$msgid};
			}	
		}	
	}
	
	return 1;
}

1;
