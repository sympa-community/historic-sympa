#!--PERL--
# -*- indent-tabs-mode: t; -*-
# vim:ft=perl:noet:sw=8:wrap:textwidth=78
# $Id$

# archived.pl - This script does the web archives building for Sympa
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

## Options :  F         -> do not detach TTY
##         :  d		-> debug -d is equiv to -dF
## Now, it is impossible to use -dF but you have to write it -d -F

=pod 

=head1 NAME 

I<archived.pl> - Daemon running the web archive building.

=head1 DESCRIPTION 

This script must be run along with sympa. It regularly checks the 'outgoing' spool and picks the messages it finds in it. It then calls MHonArc to build the HTML version of archives and add an SMTP text version (i.e. an ASCII file including headers and body) to the appropriate directory.

=cut 

use strict;
use lib '--modulesdir--';

use Digest::MD5;
use English qw(-no_match_vars);
use Getopt::Long;

use Sympa::Archive;
use Sympa::Configuration;
use Sympa::Constants;
use Sympa::Language;
use Sympa::List;
use Sympa::Log;
use Sympa::Message;
use Sympa::SDM;
use Sympa::Spool;
use Sympa::Tools;
use Sympa::Tools::Time;
use Sympa::Tools::File;
use Sympa::Tools::Daemon;
use Sympa::WWSympa;

my $daemon_name = Sympa::Log::set_daemon($0);
my $ip = $ENV{'REMOTE_HOST'};

#getopts('dF');

## Check options
my %options;
unless (&GetOptions(\%main::options, 'debug|d', 'foreground|F')) {
    Sympa::Log::fatal_err("Unknown options.");
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'debug'} || $main::options{'foreground'});

my $wwsympa_conf    = Sympa::Constants::WWSCONFIG;
my $sympa_conf_file = Sympa::Constants::CONFIG;

my $wwsconf = {};

# Load WWSympa configuration
unless ($wwsconf = Sympa::WWSympa::load_config($wwsympa_conf)) {
    print STDERR 'unable to load config file';
    exit -1;
}

# Load sympa.conf
unless (Sympa::Configuration::load($sympa_conf_file)) {
    Sympa::Log::fatal_err("Unable to load sympa configuration, file $sympa_conf_file has errors.");
}

## Check databse connectivity
unless (Sympa::SDM::check_db_connect()) {
    Sympa::Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', $Sympa::Configuration::Conf{'db_name'});
}

## Put ourselves in background if not in debug mode. 
unless ($main::options{'debug'} || $main::options{'foreground'}) {
   open(STDERR, ">> /dev/null");
   open(STDOUT, ">> /dev/null");
   if (open(TTY, "/dev/tty")) {
      ioctl(TTY, 0x20007471, 0);
      close(TTY);
   }
   setpgrp(0, 0);
   if ((my $child_pid = fork) != 0) {
      print STDOUT "Starting archive daemon, pid $_\n";

      exit(0);
   }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the pidfile
Sympa::Tools::Daemon::write_pid($wwsconf->{'archived_pidfile'}, $$, $options, $Sympa::Configuration::Conf{'lock_method'});
unless ($options->{'stderr_to_tty'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(('tmpdir' => $Sympa::Configuration::Conf{'tmpdir'}, 'pid' => $PID));
}

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    Sympa::Log::set_log_level($main::options{'log_level'});
    Sympa::Log::do_log('info', "Configuration file read, log level set using options : $main::options{'log_level'}"); 
}else{
    Sympa::Log::set_log_level($Sympa::Configuration::Conf{'log_level'});
    Sympa::Log::do_log('info', "Configuration file read, default log level $Sympa::Configuration::Conf{'log_level'}"); 
}

$wwsconf->{'log_facility'}||= $Sympa::Configuration::Conf{'syslog'};
Sympa::Log::do_openlog($wwsconf->{'log_facility'}, $Sympa::Configuration::Conf{'log_socket_type'}, 'archived');

## Set the UserID & GroupID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];


## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2]) && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    Sympa::Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct($Sympa::Configuration::Conf{'umask'}));

foreach my $robot (@{Sympa::Configuration::get_robots_list()}) {
    my $arc_dir = Sympa::Configuration::get_robot_conf($robot,'arc_path');
    ## Create arc_path if required
    if ($arc_dir) {
	unless (&directory_check($arc_dir)) {
	    Sympa::Log::do_log('err','No vailable directory to store archives. Exiting.');
	    exit -1;
	}
    }else{
	Sympa::Log::do_log('err','Robot %s has no archives directory. Check arc_path parameter in this robot.conf and in wwsympa.conf.');
	exit -1;
    }
}

## Change to list root
unless (chdir($Sympa::Configuration::Conf{'home'})) {
    Sympa::Log::do_log('err','unable to change directory');
    exit (-1);
}

my $pinfo = Sympa::List::_apply_defaults();

$Sympa::Language::default_lang = $Sympa::Configuration::Conf{'lang'};

Sympa::Log::do_log('notice', "archived %s Started", Sympa::Constants::VERSION);


## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $spoolarchive = Sympa::Spool->new('archive');

## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {

    Sympa::List::init_list_cache();
    sleep 1; 
    my $item = $spoolarchive->next;

    next unless $item;

    my @orders = split(/\n/,$item->{'messageasstring'} );
    
   Sympa::Log::do_log('debug',"orders[0] %s ",$orders[0] );

    if ($orders[0] =~ /^rebuild\s*$/ ) {
	Sympa::Log::do_log('debug',"rebuild found ");
	if ($item->{'list'} && $item->{'robot'}) {	
	    &rebuild($item->{'list'}.'@'.$item->{'robot'});
	    $spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}});
	}else{
	   Sympa::Log::do_log('err',"unable to rebuild archive for unkown list/robot.Move to bad");
	    $spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to rebuild archive for unkown list','lock'=>'NULL'});
	    next;
	}
    }elsif($orders[0]  =~ /^remove\.(\d\d\d\d\-\d\d)\.\d+$/ ) {
	my $yyyymm = $1;
	shift @orders;
	Sympa::Log::do_log('debug',"removed found ");
	unless($item->{'list'} && $item->{'robot'}){
	   Sympa::Log::do_log('err',"unable to remove messages from archive for unkown list/robot.Move to bad");
	    $spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to remove messages from archive, list name missing','lock'=>'NULL'});
	    next;
	}
	my $listadress = $item->{'list'}.'@'.$item->{'robot'}	;

	my $arclistdir = $listadress.'.'.$yyyymm;
	my $arcpath = "$wwsconf->{'arc_path'}/$listadress/$yyyymm";
	
Sympa::Log::do_log('debug',"start remove process :listadress :'$listadress' arclistdir '$arclistdir' arcpath '$arcpath'  yyyymm '$yyyymm'");
	    
	my $list;
	unless ($list = Sympa::List->new($listadress)) {
	   Sympa::Log::do_log('err',"remove : unknown list $listadress");
	    $spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to remove messages from archive for unkown list','lock'=>'NULL'});
	    next;
	}
Sympa::Log::do_log('debug',"remove found : for $arclistdir");
	
	my $email_regexp = Sympa::Tools::get_regexp('email');

	foreach my $order (@orders) { 
	    unless($order =~ /(.*)\|\|($email_regexp)/){
	Sympa::Log::do_log ('err',"Ignoring remove_order $order not recognized format");   
		next;
	    }
	    my $msgid = $1;
	    my $sender = $2;
	    
	    chomp 	$msgid ;
	    if ($msgid =~ /NO-ID-FOUND\.mhonarc\.org/) {
	Sympa::Log::do_log('err','remove_arc: no message id found');
		next;
	    } 
	    
	    my $message ;
	    unless ($message = Sympa::Archive::search_msgid("$arcpath/arctxt",$msgid)){
	Sympa::Log::do_log('err','No message with message-id %s found in %s/arctxt',$msgid,$arcpath);
		next;
	    }
	    
	    unless ($list->am_i('privileged_owner',$sender)|| $list->am_i('owner',$sender)||$list->am_i('editor', $sender)||Sympa::List::is_listmaster($sender,$list->{'domain'} )){
		# if not list owner or list editor or listmaster,n check if sender of remove order is sender of the message to remove
		
		my $new_message;
		unless ($new_message = Sympa::Message->new({'file'=>"$arcpath/arctxt/$message",'noxsympato'=>'noxsympato'})) {
		   Sympa::Log::do_log('err',"unable to load new message $arcpath/arctxt/$message");
		    next;
		}
		my $messagesender = lc($new_message->{'sender'});
		
		unless ($sender == $messagesender) {
		    Sympa::Log::do_log('err', 'remove command by unauthorized sender');
		    next;
		}
	    }
	    # this point : requested command is from a authorized personn (message sender or list admin or listmaster	    
	    &remove($arclistdir,$msgid);
	    
	    my $url_dir = $list->{'dir'}.'/urlized/'.$msgid;
	    Sympa::Tools::File::remove_dir ($url_dir);
	    
	    unless (-d "$arcpath/deleted"){
		unless (mkdir ("$arcpath/deleted",0777)) {
		   Sympa::Log::do_log('info',"remove_arc: unable to create $arcpath/deleted : $ERRNO");
		    last;
		}
	    }
	    
	    unless (rename ("$arcpath/arctxt/$message","$arcpath/deleted/$message")) {
	Sympa::Log::do_log('info',"remove_arc: unable to rename message $arcpath/arctxt/$message");
		next;
	    }
	    
	    # remove directory if empty arctxt
	    unless (opendir (DIR,"$arcpath/arctxt")) {
	Sympa::Log::do_log('info',"remove_arc: unable to open dir $arcpath/arctxt");
		next;
	    }
	    my @files = grep(/^\d+$/, readdir( DIR ));
	    closedir (DIR);
	    if ($#files == -1) {
		Sympa::Tools::File::remove_dir ($arcpath); 
	    }
	}
	$spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}});
    }else{
Sympa::Log::do_log('notice',"Archiving message %s for list %s@%s",$item->{'messagekey'},$item->{'list'},$item->{'robot'});
	unless (mail2arc ($item)) {
	    $spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to rebuild archive for unkown list','lockdate'=>'NULL'});
	    Sympa::Log::do_log('err',"archiving_failed for message %s",$item->{'messagekey'});
	    unless (Sympa::List::send_notify_to_listmaster('archiving_failed',$item->{'robot'})) {
		Sympa::Log::do_log('notice',"Unable to send notify 'archiving_failed' to listmaster");
	    }
	}
	unless ($spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}})){
	   Sympa::Log::do_log ('err',"Couldn't remove message in archive spool %s . exiting to prevent infinite loop",$item->{'messagekey'});
	    last;
	}
    }
}

Sympa::List::send_notify_to_listmaster(undef, undef, undef, undef, 1); # Purge grouped notifications

Sympa::Log::do_log('notice', 'archived exited normally due to signal');
Sympa::Tools::Daemon::remove_pid($wwsconf->{'archived_pidfile'}, $$, undef, $Sympa::Configuration::Conf{'tmpdir'});

exit(0);


=pod 

=head1 SUBFUNCTIONS 

This is the description of the subfunctions contained by archived.pl.

=cut 

=pod 

=head2 sub sigterm()

Switches the loop control variable $end value to 1 when SIGTERM signal is caught.

=head3 Parameters 

=over 

=item * I<none> 

=back 

=head3 Return 

=over 

=item * I<none> 

=back 

=cut 

## When we catch SIGTERM, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

=pod 

=head2 sub remove(STRING $adrlist, STRING $msgid)

Removes the message having the identifier $msgid from the list named $adrlist.

=head3 Parameters 

=over 

=item * I<$adrlist>, a character string containing the list name.

=item * I<$msgid> , a character string containing the message identifier.

=back 

=head3 Return 

=over 

=item * I<none> 

=back 

=cut 

sub remove {
    my $adrlist = shift;
    my $msgid = shift;
    my $robot = shift;

   Sympa::Log::do_log ('debug',"remove ($adrlist, $msgid)");
    my $arc ;

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
	$adrlist = $1;
        $arc = $2;
    }

    Sympa::Log::do_log('notice',"Removing $msgid in list $adrlist section $2");

    Sympa::Log::db_stat_log({'robot' => $robot, 'list' => $adrlist, 'operation' => 'remove archive', 'parameter' => '', 'mail' => 'test@cru.fr','client' => $ip, 'daemon' => $daemon_name});

    unless(Sympa::Log::db_log({'robot' => $robot,'list' => $adrlist,'action' => 'remove','parameters' => $msgid.','.$adrlist,'target_email' => '','msg_id' => $msgid,'status' => 'succes','error_type' => '','user_email' =>'','client' => $ip,'daemon' => $daemon_name})){
	Sympa::Log::do_log('error','archived::remove: unable to log event');
    }
    my $arcpath = Sympa::Configuration::get_robot_conf($robot,'arc_path');
    $arc =~ /^(\d{4})-(\d{2})$/ ;
    my $yyyy = $1 ;
    my $mm = $2 ;
    
    $msgid =~ s/\$/\\\$/g;
    system "$wwsconf->{'mhonarc'}  -outdir $arcpath/$adrlist/$yyyy-$mm -rmm $msgid";
}

=pod 

=head2 sub rebuild(STRING $adrlist)

Rebuilds archives for the list the name of which is given in the argument $adrlist.

=head3 Parameters 

=over 

=item * I<$adrlist>, a character string containing the name of the list the archives of which we want to rebuild.

=back 

=head3 Return 

=over 

=item * I<undef> if something goes wrong.

=back 

=cut 

sub rebuild {

    my $adrlist = shift;
    my $arc ;

    Sympa::Log::do_log ('debug2',"rebuild ($adrlist)");

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
	$adrlist = $1;
        $arc = $2;
    }

    my ($listname, $hostname);
    if ($adrlist =~ /^(.*)\@(.*)$/) {
	$listname = $1;
	$hostname = $2;
    }else {
	Sympa::Log::do_log('err',"Match of list address '$adrlist' failed");
	       return undef;
    }

    my $tag = &get_tag($listname);

    my $list = Sympa::List->new($listname, $hostname);
    my $robot = $list->{'domain'};
    my $arcpath = Sympa::Configuration::get_robot_conf($robot,'arc_path');
    Sympa::Log::do_log('debug',"Rebuilding $adrlist archive ($2)");

    my $mhonarc_ressources = Sympa::Tools::get_filename('etc',{},'mhonarc-ressources.tt2',$list->{'domain'}, $list, $Sympa::Configuration::Conf{'etc'});

    if (($list->{'admin'}{'web_archive_spam_protection'} ne 'none') && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
	&set_hidden_mode($tag);
    }else {
	&unset_hidden_mode();
    }

    Sympa::Log::do_log('notice',"Rebuilding  $arc with M2H_ADDRESSMODIFYCODE : %s",$ENV{'M2H_ADDRESSMODIFYCODE'});

    if ($arc) {
        Sympa::Log::do_log('notice',"Rebuilding  $arc of $adrlist archive");
	$arc =~ /^(\d{4})-(\d{2})$/ ;
	my $yyyy = $1 ;
	my $mm = $2 ;

	# remove empty directory
	my $arcdir = $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm ;
	my $arctxt = $arcdir.'/arctxt' ;
	if (opendir (DIR,$arctxt)) {
	    my @files = (grep(/^\d+$/,(readdir DIR )));
	    close (DIR);
	    if ($#files == -1) { 
		Sympa::Log::do_log('notice', "Removing empty directory $arcdir");
		Sympa::Tools::File::remove_dir ($arcdir);
		next ;	 
	    } 

	    ## index file was removed ; recreate it
	    my $index = $files[$#files];
	    &save_idx($arcdir.'/index', $index+1);
	}
	
	## recreate index file if needed
	unless (-f $arcdir.'/index') {
	    &create_idx($arcdir);
	}

	## Remove .mhonarc.db
	unlink $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm.'/.mhonarc.db';
	
	## Remove existing HTML files
	opendir HTML, "$arcpath/$adrlist/$yyyy-$mm";
	
	## Skip arctxt/ . and ..
	foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
	    unlink $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm.'/'.$html_file;
	}	
	closedir HTML;

	my $arcs_dir = Sympa::Archive::clean_archive_directory({'arc_root' => $wwsconf->{'arc_path'},'dir_to_rebuild' => "/$adrlist/$arc/arctxt"});
	my $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'} if($arcs_dir);

	my $cmd = "$wwsconf->{'mhonarc'} -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\' -rcfile $mhonarc_ressources -outdir $arcpath/$adrlist/$yyyy-$mm  -definevars \"listname='$listname' hostname=$hostname yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$arcpath base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} $dir_to_rebuild";

	Sympa::Log::do_log('debug',"System call : $cmd");
	my $exitcode = system($cmd);
	$exitcode = $exitcode / 256;

	# Delete temporary directory containing files with escaped HTML.
	if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
	    Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
	}
	
	## Remove lock if required
	if ($exitcode == 75) {
	    Sympa::Log::do_log('notice', 'Removing lock directory %s', $arcpath.'/'.$adrlist.'/'.$arc.'/.mhonarc.lck');
	    rmdir $arcpath.'/'.$adrlist.'/'.$arc.'/.mhonarc.lck';

	    $exitcode= system($cmd);
	    $exitcode = $exitcode / 256;	    
	}

	if ($exitcode) {
	    Sympa::Log::do_log('err',"Command $cmd failed with exit code $exitcode");
	}
    }else{
        Sympa::Log::do_log('notice',"Rebuilding $adrlist archive completely");

	if (!opendir(DIR, "$arcpath/$adrlist" )) {
	    Sympa::Log::do_log('err',"unable to open $arcpath/$adrlist to rebuild archive");
	    return ;
	}
	my @archives = (grep (/^\d{4}-\d{2}/, readdir(DIR)));
	close DIR ; 

	foreach my $arc (@archives) {
	    $arc =~ /^(\d{4})-(\d{2})$/ ;
	    my $yyyy = $1 ;
	    my $mm = $2 ;

	    my $arcdir = $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm;

	    ## Remove .mhonarc.db
	    unlink $arcdir.'/.mhonarc.db';
	    
	    ## Remove existing HTML files
	    opendir HTML, $arcdir;
	    ## Skip arctxt/ . and ..
	    foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
		unlink $arcdir.'/'.$html_file;
	    }	
	    closedir HTML;
	    my $dir_to_rebuild = "$wwsconf->{'arc_path'}/$adrlist/$arc/arctxt";
	    my $arcs_dir = Sympa::Archive::clean_archive_directory({'arc_root' => $wwsconf->{'arc_path'},'dir_to_rebuild' => "/$adrlist/$arc/arctxt"});
	    if($arcs_dir) {
		$dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'};
	    }
	    ## recreate index file if needed
	    unless (-f $arcdir.'/index') {
		&create_idx($arcdir);
	    }

	    my $cmd = "$wwsconf->{'mhonarc'} -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\'  -rcfile $mhonarc_ressources -outdir $arcdir  -definevars \"listname=$listname hostname=$hostname yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$arcpath base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} $dir_to_rebuild";
	    my $exitcode = system($cmd);
	    $exitcode = $exitcode / 256;

	    # Delete temporary directory containing files with escaped HTML.
	    if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
		Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
	    }

	    ## Remove lock if required
	    if ($exitcode == 75) {
		Sympa::Log::do_log('notice', 'Removing lock directory %s', $arcdir.'/.mhonarc.lck');
		rmdir $arcdir.'/.mhonarc.lck';
		
		$exitcode = system($cmd);
		$exitcode = $exitcode / 256;	    
	    }
	    if ($exitcode) {
		Sympa::Log::do_log('err',"Command $cmd failed with exit code $exitcode");
	    }
	    
	}
    }
}


=pod 

=head2 sub mail2arc(STRING $file,STRING $listname,STRING $hostname,STRING $yyyy,STRING $mm,STRING $dd,STRING $hh,STRING $min,STRING $ss)

Archives one message into one list archives directory.

=head3 Parameters 

=over 

=item * I<$file>: a character string containing the message filename.

=item * I<$listname>: a character string containing the name of the list in which to archive the message

=item * I<$hostname>: a character string containing the name of the virtual robot hosting the list.

=item * I<$yyyy>: a character string containing the year of the date when the message is archived (i.e. now)

=item * I<$mm>: a character string containing the month of the date when the message is archived (i.e. now)

=item * I<$dd>: a character string containing the day of the date when the message is archived (i.e. now)

=item * I<$hh>: a character string containing the hour of the date when the message is archived (i.e. now)

=item * I<$min>: a character string containing the minute of the date when the message is archived (i.e. now)

=item * I<$ss>: a character string containing the second of the date when the message is archived (i.e. now)

=back 

=head3 Return 

=over 

=item * I<undef> if something goes wrong.

=back 

=cut 


sub mail2arc {

    my $message_in_spool = shift;

    my $listname = $message_in_spool->{'list'};
    my $robot = $message_in_spool->{'robot'};
    my ($yyyy, $mm, $dd, $hh, $min, $ss) = @_;
    my $txtdate = Sympa::Tools::Time::epoch2yyyymmjj_hhmmss ($message_in_spool->{'date'});
    if ($txtdate =~ /(\d\d\d\d)\-(\d\d)\-(\d\d)\s*(\d\d)\:(\d\d)/){
	$yyyy = $1; $mm = $2; $dd = $3; $hh = $4; $min = $5; $ss = $6;
    }else{
	Sympa::Log::do_log('err',"could not scan date");
	return undef;
    }

    my $newfile;

    my $list = Sympa::List->new($listname, $robot);
    my $arcpath = Sympa::Configuration::get_robot_conf($list->{'domain'},'arc_path');

    unless (defined $list) {
	Sympa::Log::do_log('err', 'Unknown list %s@%s', $listname, $robot);
	return undef;
    }

    my $tag = &get_tag($listname);

    if (($list->{'admin'}{'web_archive_spam_protection'} ne 'none') && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
	&set_hidden_mode($tag);
    }else {
	&unset_hidden_mode();
    } 

   Sympa::Log::do_log('debug',"mail2arc  for %s yyyy:$yyyy, mm:$mm dd:$dd hh:$hh min$min ss:$ss", $list->get_list_id());
    #    chdir($wwsconf->{'arc_path'});


    if ($wwsconf->{'custom_archiver'}) {
	my $file = $Sympa::Configuration::Conf{'tmpdir'}."/arc.".$listname.'@'.$robot.'.'.$message_in_spool->{'messagekey'} ;
	open (DUMP, "> $file");
	printf DUMP $message_in_spool->{'messageasstring'};	
	`$wwsconf->{'custom_archiver'} --list=$listname\@$robot --file=$file`;
	return 1;
    }else{
	my $basedir = $arcpath.'/'.$list->get_list_id();
	
	if (! -d $basedir) {
	    unless (mkdir $basedir, 0775) {
		Sympa::Log::do_log('err', 'Cannot create directory %s', $basedir);
		unless (Sympa::List::send_notify_to_listmaster('unable_to_create_dir',$robot,{'dir' => "$basedir"})) {
		    Sympa::Log::do_log('notice',"Unable to send notify 'unable_to_create_dir' to listmaster");
		}
	    }
	    Sympa::Log::do_log('debug',"mkdir $basedir");
	}
	
	## Check quota
	if ($list->{'admin'}{'web_archive'}{'quota'}) {
	    my $used = $list->get_arc_size("$arcpath") ;
	    
	    if ($used >= $list->{'admin'}{'web_archive'}{'quota'} * 1024){
		Sympa::Log::do_log('err',"archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}");
		unless ($list->send_notify_to_owner('arc_quota_exceeded',{'size' => $used})) {
		    Sympa::Log::do_log('notice',"Unable to send notify 'arc_quota_exceeded' to $list->{'name'} owner");	
		}
		return undef;
	    }
	    if ($used >= ($list->{'admin'}{'web_archive'}{'quota'} * 1024 * 0.95)){
		Sympa::Log::do_log('err',"archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}");
		unless ($list->send_notify_to_owner('arc_quota_95',{'size' => $used,
								    'rate' => int($used * 100 / ($list->{'admin'}{'web_archive'}{'quota'} * 1024 ))})) {
		    Sympa::Log::do_log('notice',"Unable to send notify 'arc_quota_95' to $list->{'name'} owner");	
		}
	    }
	}
	
	my $monthdir = $basedir."/$yyyy-$mm";
	
	if (! -d $monthdir) {
	    unless (mkdir ($monthdir, 0775)) {
		Sympa::Log::do_log('err', 'Cannot create directory %s', $monthdir);
		return undef;
	    }
	    
	    Sympa::Log::do_log('debug',"mkdir $arcpath/%s/$yyyy-$mm", $list->get_list_id());
	    
	    if ($list->{'admin'}{'web_archive'}{'max_month'}){ # maybe need to remove some old archive
		if (opendir DIR,$arcpath.'/'.$list->get_list_id()) {
		    my @archives = (sort {$a cmp $b} grep (/^\d{4}-\d{2}/, readdir(DIR)));	
		    closedir DIR;
		    my $nb_month = $#archives + 1 ;
		    my $i = 0 ;
		    while ( $nb_month >  $list->{'admin'}{'web_archive'}{'max_month'}) {
			Sympa::Log::do_log('info',"removing  $arcpath/%s/$archives[$i]", $list->get_list_id());
			Sympa::Tools::File::remove_dir ($arcpath.'/'.$list->get_list_id().'/'.$archives[$i]);
			$i ++; $nb_month --;		    
		    }
		}
	    }
	}
	
	my $arctxtdir = $monthdir."/arctxt";
	
	if (! -d $arctxtdir) {
	    unless (mkdir ($arctxtdir, 0775)) {
		Sympa::Log::do_log('err', 'Cannot create directory %s', $arctxtdir);
		return undef;
	    }
	    Sympa::Log::do_log('debug',"mkdir $arctxtdir");
	}
	
	## fetch next message number in archive arctxt .
	if( -f $monthdir."/index" ){
	    open(IDX,"<$monthdir/index") || Sympa::Log::fatal_err("couldn't read index for $listname");
	    $newfile = <IDX>;
	    chomp($newfile);
	    $newfile++;
	    close IDX;
	}else{
	    ## recreate index file if needed and update it
	    $newfile = &create_idx($monthdir) + 1;
	}

	# savee arctxt dump of original message.
	my $file = $monthdir.'/arctxt/'.$newfile ;
	my $output = $Sympa::Configuration::Conf{'tmpdir'}.'/arc'.$newfile;
	open (DUMP, "> $file");
	printf DUMP $message_in_spool->{'messageasstring'};
	close DUMP;

	
	# prepare a temporary file with clean message content (htlm parts are cleaned) 
	my $safe = Sympa::Archive::clean_archived_message({'input'=>$file,'output' => $output });
	unless ($safe) {
	   Sympa::Log::do_log('err',"Could not clean message, ignoring message");
	    next;
	}

	my $mhonarc_ressources = Sympa::Tools::get_filename('etc',{},'mhonarc-ressources.tt2',$list->{'domain'}, $list, $Sympa::Configuration::Conf{'etc'});
	
	Sympa::Log::do_log ('debug',"calling $wwsconf->{'mhonarc'} for list %s", $list->get_list_id() ) ;
	
	# call mhonarc on cleaned message source to make clean htlm view of message
	my $cmd = "$wwsconf->{'mhonarc'} -add -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\'  -rcfile $mhonarc_ressources -outdir $monthdir  -definevars \"listname='$listname' hostname=$robot yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$wwsconf->{'arc_path'} base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} < $output";
	
	Sympa::Log::do_log('debug',"System call : %s",$cmd);
	
	my $exitcode = system($cmd);
	$exitcode = $exitcode / 256;
	
	## Remove lock if required
	if ($exitcode == 75) {
	    Sympa::Log::do_log('notice', 'Removing lock directory %s', $monthdir.'/.mhonarc.lck');
	    rmdir $monthdir.'/.mhonarc.lck';
	    
	    $exitcode = system($cmd);
	    $exitcode = $exitcode / 256;	    
	}
	if ($exitcode) {
	    Sympa::Log::do_log('err',"Command $cmd failed with exit code $exitcode");
	}
	
	&save_idx("$monthdir/index",$newfile);
    }
}


=pod 

=head2 sub set_hidden_mode(STRING $tag)

Sets the value of $ENV{'M2H_ADDRESSMODIFYCODE'} and $ENV{'M2H_MODIFYBODYADDRESSES'}

=head3 Parameters 

=over 

=item * I<$tag> a character string (containing the result of get_tag($listname))

=back 

=head3 Return 

=over 

=item * I<none> 

=back 

=cut 

sub set_hidden_mode {
    my $tag = shift; ## tag is used as variable elements in tags to prevent message contents to be parsed

    ## $ENV{'M2H_MODIFYBODYADDRESSES'} à positionner si le corps du message est parse
    $ENV{'M2H_ADDRESSMODIFYCODE'} = "s|^([^\@]+)\@([^\@]+)\$|\($tag\%hidden_head\%$tag\)\$1\($tag\%hidden_at\%$tag\)\$2\($tag\%hidden_end\%$tag\)|g";
    $ENV{'M2H_MODIFYBODYADDRESSES'} = 1;
}

=pod 

=head2 sub unset_hidden_mode()

Empties $ENV{'M2H_ADDRESSMODIFYCODE'}.

=head3 Parameters 

=over 

=item * I<none> 

=back 

=head3 Return 

=over 

=item * I<none> 

=back 

=cut 

sub unset_hidden_mode {
    
    ## Be carefull, the .mhonarc.db file keeps track of previous M2H_ADDRESSMODIFYCODE setup
    $ENV{'M2H_ADDRESSMODIFYCODE'} = '';
}

=pod 

=head2 sub save_idx(STRING $index,STRING $lst)

Saves the archives index file

=head3 Parameters 

=over 

=item * I<$index>, a string corresponding to the file name to which save an index.

=item * I<$lst>, a character string

=back 

=head3 Return 

=over 

=item * I<none> 

=back 

=cut 

sub save_idx {
    my ($index,$lst) = @_;
#    Sympa::Log::do_log('notice', "save_idx($index,$lst)");
    
    open(INDEXF,">$index") || Sympa::Log::fatal_err("couldn't overwrite index $index");
    print INDEXF "$lst\n";
    close INDEXF;
    #   Sympa::Log::do_log('debug',"last arc entry for $index is $lst");
}

## Create the 'index' file for one archive subdir
sub create_idx {
    my $arc_dir = shift; ## corresponds to the yyyy-mm directory

    my $arc_txt_dir = $arc_dir.'/arctxt';

    unless (opendir (DIR, $arc_txt_dir)) {
	Sympa::Log::do_log('err', "Failed to open directory '$arc_txt_dir'");
	return undef;
    }

    my @files = (sort { $a <=> $b;}  grep(/^\d+$/,(readdir DIR ))) ;
    my $index = $files[$#files];
    &save_idx($arc_dir.'/index', $index);

    closedir DIR;

    return $index;
}

=pod 

=head2 sub get_tag(STRING $listname)

Returns a tag derived from the listname.

=head3 Parameters 

=over 

=item * I<$listname>, a character string correspondiong to the list name.

=back 

=head3 Return 

=over 

=item * I<a character string>, corresponding to the 10 last characters of a 32 bytes string containing the MD5 digest of the concatenation of the following strings (in this order):

=over 4

=item - the cookie config parameter

=item - a slash: "/"

=item - the I<$listname> argument

=back 

=cut 

sub get_tag {
    my $listname = shift;
    
    return (substr(Digest::MD5::md5_hex(join('/', $Sympa::Configuration::Conf{'cookie'}, $listname)), -10)) ;
}


# Checks if directory exists and we have write and read accec to it.
sub directory_check {
    my $dir = shift;
    unless (-d $dir) {
	printf STDERR "Creating missing %s directory\n", $dir;
	unless (mkdir $dir, 0775) {
	    Sympa::Log::do_log('err','Unable to create directory %s',$dir);
	    return undef;
	}
	unless (Sympa::Tools::File::set_file_rights(file => $dir,
					 user  => Sympa::Constants::USER,
					 group => Sympa::Constants::GROUP,
					 mode  => 0775,
					 ))
	{
	    Sympa::Log::do_log('err','Unable to set rights on %s',$dir);
	    return undef;
	}
    }
    unless ((-r $dir) && (-w $dir)) {
	Sympa::Log::do_log('err', 'Unsufficient access to %s directory', $dir);
	return undef;
    }
    return 1;
}
=pod 

=head1 AUTHORS 

=over 

=item * Serge Aumont <sa AT cru.fr> 

=item * Olivier Salaun <os AT cru.fr> 

=back 

=cut 
