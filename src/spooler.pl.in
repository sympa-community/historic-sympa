#!--PERL--
# sympa.pl - This script is the main one ; it runs as a daemon and does
# the messages/commands processing
# RCS Identication ; $Revision: 6671 $ ; $Date: 2010-09-07 11:03:18 +0200 (mar 07 sep 2010) $ 
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

use strict;
use lib '--modulesdir--';

use File::Copy;
use File::Path;
use Getopt::Long;
use Mail::Address;
use MIME::QuotedPrint;

use Commands;
use Family;
use Language;
use Log;
use Lock;
use List;
use Message;
use SDM;
use Sympa::Conf;
use Sympa::Constants;
use Sympa::Spool;
use Sympa::Tools;
use Sympa::Tools::Daemon;

## Internal tuning
# delay between each read of the digestqueue
my $digestsleep = 5; 

## Init random engine
srand (time());

my $version_string =
    sprintf("Sympa version is %s\n", Sympa::Constants::VERSION);

my $daemon_name = &Log::set_daemon($0);

my $usage_string = "Usage:
   $0 [OPTIONS]

Options:
   -d, --debug                           : sets Sympa in debug mode 
   -f, --config=FILE                     : uses an alternative configuration file
   --foreground                          : the process remains attached to the TTY
   -k, --keepcopy=dir                    : keep a copy of incoming message
   --log_level=LEVEL                     : sets Sympa log level
   --queue=PATH_TO_SPOOL                 : overright queue sympa parameter in order to choose spool location.
   -h, --help                            : print this help
   -v, --version                         : print version number

This demon is the Sympa spooler that load into database (table spool_table) messages from incomming spool
";

## Check --dump option
my %options;
unless (&GetOptions(\%main::options, 'debug|d', ,'log_level=s','foreground','keepcopy|k=s', 'queue=s', 'help', 'version')) {
    &fatal_err("Unknown options.");
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}
## Batch mode, ie NOT daemon
$main::options{'batch'} = 1 if ($main::options{'help'}||$main::options{'version'});

# Some option force foreground mode
$main::options{'foreground'} = 1 if ($main::options{'debug'} || $main::options{'batch'});

$main::options{'log_to_stderr'} = 1 unless ($main::options{'batch'});

my %loop_info;

# this loop is run foreach HUP signal received
my $signal = 0;

local $main::daemon_usage; 

while ($signal ne 'term') { #as long as a SIGTERM is not received }

my $config_file = $main::options{'config'} || Sympa::Constants::CONFIG;

## Load configuration file. Ignoring database config for now: it avoids trying to load a database that could not exist yet.
unless (Sympa::Conf::load($config_file,1)) {
   &fatal_err("Configuration file $config_file has errors.");  
}


## Open the syslog and say we're read out stuff.
&Log::do_openlog($Conf{'syslog'}, $Conf{'log_socket_type'}, 'spooler');

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    &Log::set_log_level($main::options{'log_level'});
    &Log::do_log('info', "Configuration file read, log level set using options : $main::options{'log_level'}"); 
}else{
    &Log::set_log_level($Conf{'log_level'});
    &Log::do_log('info', "Configuration file read, default log level $Conf{'log_level'}"); 
}

## Probe Db if defined
if ($Conf{'db_name'} and $Conf{'db_type'}) {
    unless (&Upgrade::probe_db()) {
	&Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable. verify db_xxx parameters in sympa.conf', $Conf{'db_name'});
    }
}

## Now trying to load full config (including database)
unless (Sympa::Conf::load($config_file)) {
   &Log::fatal_err("Configuration file $config_file has errors.");
   
}

## Apply defaults to %List::pinfo
&List::_apply_defaults();


## Main program
if (!chdir($Conf{'home'})) {
   &Log::fatal_err("Can't chdir to %s: %m", $Conf{'home'});
   ## Function never returns.
}

## Check for several files.
unless (&Sympa::Conf::checkfiles_as_root()) {
   &Log::fatal_err("output checkfiles_as_root : Missing files. Aborting.");
   ## No return.
}

## Check that the data structure is uptodate
unless ($main::options{'upgrade'} || $main::options{'help'}) {
    unless (&Upgrade::data_structure_uptodate()) {
	&Log::fatal_err("error : data structure was not updated ; you should run sympa.pl --upgrade to run the upgrade process.");
    }
}
my $spooldir;
my %distinct_spools;
if ($signal ne 'hup') {
    ## Put ourselves in background if we're not in debug mode. That method
    ## works on many systems, although, it seems that Unix conceptors have
    ## decided that there won't be a single and easy way to detach a process
    ## from its controlling tty.
    unless ($main::options{'foreground'}) {
	if (open(TTY, "/dev/tty")) {
	    ioctl(TTY, 0x20007471, 0);         # XXX s/b &TIOCNOTTY
	    #       ioctl(TTY, &TIOCNOTTY, 0);
	    close(TTY);
	}
	open(STDIN, ">> /dev/null");
	open(STDOUT, ">> /dev/null");
	open(STDERR, ">> /dev/null");

	setpgrp(0, 0);
	# start a spooler.pl daemon for the spool location specified by option --queue= or for each distinct spool find in sympa.conf

	if ($main::options{'queue'}){
	    $distinct_spools{$main::options{'queue'}}= 1;
	}else{
	    foreach my $possible_spool ('queue', 'bouncequeue', 'queueautomatic'){
		$distinct_spools{$Conf{$possible_spool}} = 1 if ($Conf{$possible_spool});
	    }
	}
	my $master = 1;
	foreach my $distinct_spool (keys %distinct_spools) {
	    $spooldir = $distinct_spool;
	    if ($master) { # only master process fork child process
		if ((my $child_pid = fork) != 0) {
		   &Log::do_log('debug', "Master daemon fork child %s",$child_pid);		
		}else{
		   &Log::do_log('info', "Child process PID %s spooler for spool %s",$$,$spooldir);
		    $master = 0;
		    last;
		}
	    }
	}
	if ($master) {
	   &Log::do_log('debug', "Fork, exiting from initial process");
	    exit (0);
	}
	

	&Log::do_openlog($Conf{'syslog'}, $Conf{'log_socket_type'}, 'spooler');

	&Log::do_log('debug', "Running server $$ for spooler purpose ");

	unless ($main::options{'batch'} ) {
	    
	    ## Create and write the pidfile
	    my $file = $Conf{'pidfile_spooler'};
	    
	    ## If process is running in foreground, don't write STDERR to a dedicated file
	    my $options;
	    $options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
	    $options->{'multiple_process'} = 1 ;
	    &Sympa::Tools::Daemon::write_pid($file, $$, $options);
	}	
	
	
	# Set the UserID & GroupID for the process
	$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
	$< = $> = (getpwnam(Sympa::Constants::USER))[2];
	
	## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
	&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
	&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);
	
	## Check if the UID has correctly been set (usefull on OS X)
	unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
	    &fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
	}
	
	# Sets the UMASK
	umask(oct($Conf{'umask'}));
	
	## Most initializations have now been done.
	&Log::do_log('notice', "Sympa spooler %s started", Sympa::Constants::VERSION);
    }else{
	&Log::do_log('notice', "Sympa spooler %s reload config", Sympa::Constants::VERSION);
	$signal = '0';
    }

## Check for several files.
## Prevent that 2 processes perform checks at the same time...
if ($main::daemon_usage == DAEMON_ALL) {
    unless (&Sympa::Conf::checkfiles()) {
	&Log::fatal_err("Missing files. Aborting.");
	## No return.
    }
}else {
    sleep 1; ## wait until main process has created required directories
}
if ($main::options{'help'}) {
    print $usage_string;
    exit 0;
}elsif ($main::options{'version'}) {
    print $version_string;    
    exit 0;
}
## Do we have right access in the directory
if ($main::options{'keepcopy'}) {
    if (! -d $main::options{'keepcopy'}) {
	&Log::do_log('notice', 'Cannot keep a copy of incoming messages : %s is not a directory', $main::options{'keepcopy'});
	delete $main::options{'keepcopy'};
    }elsif (! -w $main::options{'keepcopy'}) {
	&Log::do_log('notice','Cannot keep a copy of incoming messages : no write access to %s', $main::options{'keepcopy'});
	delete $main::options{'keepcopy'};
    }
}

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'HUP'} = 'sighup';
$SIG{'PIPE'} = 'IGNORE'; ## Ignore SIGPIPE ; prevents sympa.pl from dying

my @qfile;

my $msgspool = new Sympa::Spool('msg');
my $bouncespool = new Sympa::Spool('bounce');

## This is the main loop : look for files in the directory, handles
## them, sleeps a while and continues the good job.
while (!$signal) {

    if (!opendir(DIR, $spooldir)) {
	&Log::fatal_err("Can't open dir %s: %m", $spooldir); ## No return.
    }
    @qfile = sort tools::by_date grep (!/^\./,readdir(DIR));
    closedir(DIR);
    my $filename;
    my $listname;
    my $robot;

    my $t_spool = $spooldir; ## in single mode we may have to supervise automatic spool
    
    ## Scans files in queue
    foreach my $filename (sort @qfile) {
	my $type;
	my $list;
	my ($listname, $robot);	
	my %meta ;
	my $spool;

	## z and Z are a null priority, so file stay in queue and are processed
	## only if renamed by administrator
        next unless ($filename =~ /^(\S+)\.(\d+)\.\w+$/);
        next if ($filename =~ /\.lock$/);

	## Don't process temporary files created by queue (T.xxx)
	next if ($filename =~ /^T\./);


	## Lock file
	my $lock = new Lock ($spooldir.'/'.$filename);
	unless (defined $lock) {
	    &Log::do_log('err','Could not create new lock');
	    next;
	}
	$lock->set_timeout(2); 
	unless ($lock->lock('write')) {
	    next;
	}   

	($listname, $robot) = split(/\@/,$1);
	$meta{'date'} = $2;

	# spooler is able to recognize if message is bounce or automatic family list creation.'
	if ($listname =~ /Sympa_Bounce\./) {
	    $listname =~ s/Sympa_Bounce\.// ;
	    $spool = $bouncespool;
	}else{
	    $spool = $msgspool;
	    if ($listname =~ /Sympa_Automatic\./) {
		$listname =~ s/Sympa_Automatic\.// ;
		$meta{'create_list_if_needed'} = 1;		
	    }else{
		$meta{'create_list_if_needed'} = 0;		
	    }
	}
	
	$listname = lc($listname);
	if ($robot) {
	    $robot=lc($robot);
	}else{
	    $robot = lc(&Sympa::Conf::get_robot_conf($robot, 'host'));
	}

	my $list_check_regexp = &Sympa::Conf::get_robot_conf($robot,'list_check_regexp');

	if ($listname =~ /^(\S+)-($list_check_regexp)$/) {
	    ($listname, $type) = ($1, $2);
	}
	my $email = &Sympa::Conf::get_robot_conf($robot, 'email');	

	my $priority;

	if ($listname eq $Conf{'listmaster_email'}) {
	    $priority = 0;
	}elsif ($type eq 'request') {
	    $priority = &Sympa::Conf::get_robot_conf($robot, 'request_priority');
	}elsif ($type eq 'owner') {
	    $priority = &Sympa::Conf::get_robot_conf($robot, 'owner_priority');
	}elsif ($listname =~ /^(sympa|$email)(\@$Conf{'host'})?$/i) {	
	    $priority = &Sympa::Conf::get_robot_conf($robot,'sympa_priority');
	    $listname ='';
	}
	my $list =  new List ($listname, $robot, {'just_try' => 1});
	if ($list) {
	    $priority = $list->{'admin'}{'priority'};
	}else {
	    $priority = &Sympa::Conf::get_robot_conf($robot, 'default_list_priority');
	}

	$meta{'robot'} = $robot if $robot;
	$meta{'list'} = $listname if $listname;
	if ($priority) {
	    $meta{'priority'} = $priority ;
	}else{ 
	    $meta{'priority'} = 1;
	}
	$meta{'type'} = $type if $type;
	
	my $message = new Message({'file'=>$spooldir.'/'.$filename});

        #use Data::Dumper;
#	my $dump = &Dumper($message->{'msg_as_string'}); open (DUMP,">>/tmp/dumper"); printf DUMP 'Storing in db spool message \n%s',$dump ; close DUMP; 
	my $messagekey = $spool->store($message->{'msg_as_string'},\%meta);
	unless($messagekey) {
	   &Log::do_log('err',"Could not load message %s/%s in db spool",$spooldir, $filename);
	    next;
	}

	if ($main::options{'keepcopy'}) {
	    unless (&File::Copy::copy($t_spool.'/'.$filename, $main::options{'keepcopy'}.'/'.$filename) ) {
 		&Log::do_log('notice', 'Could not rename %s to %s: %s', "$t_spool/$filename", $main::options{'keepcopy'}."/$filename", $!);
	    }
	}
	
	## Release the lock
	$lock->unlock();
	unless (unlink ($spooldir.'/'.$filename)) {
	   &Log::do_log('err',"Could not unlink message %s/%s . Exiting",$spooldir, $filename);
	    exit;
	}	
    } 

    unless ($filename) {
	sleep(&Sympa::Conf::get_robot_conf($robot, 'sleep'));
	next;
    }
}

## Disconnect from Database
SDM::db_disconnect;

}
&Log::do_log('notice', 'spooler exited normally due to signal');
my $file = $Conf{'pidfile_spooler'};
&Sympa::Tools::Daemon::remove_pid($file, $$, undef, $Sympa::Conf::Conf{'tmpdir'});

exit(0);
}

############################################################
# sigterm
############################################################
#  When we catch SIGTERM, just changes the value of the $signal 
#  loop variable.
#  
# IN : -
#      
# OUT : -
#
############################################################
sub sigterm {
    &Log::do_log('notice', 'signal TERM received, still processing current task');
    $signal = 'term';
}


############################################################
# sighup
############################################################
#  When we catch SIGHUP, changes the value of the $signal 
#  loop variable and puts the "-mail" logging option
#  
# IN : -
#      
# OUT : -
#
###########################################################
sub sighup {
    if ($main::options{'mail'}) {
	&Log::do_log('notice', 'signal HUP received, switch of the "-mail" logging option and continue current task');
	undef $main::options{'mail'};
    }else{
	&Log::do_log('notice', 'signal HUP received, switch on the "-mail" logging option and continue current task');
	$main::options{'mail'} = 1;
    }
    $signal = 'hup';
}

1;
