#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997-1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997-2011 Comite Reseau des Universites
# Copyright (c) 2011-2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=encoding utf-8

=head1 NAME

sympa, sympa.pl - A Modern Mailing List Manager

=head1 SYNOPSIS

B<sympa.pl>
    S<[ B<-d, --debug> ]>
    S<[ B<-f, --config>=I<another.sympa.conf> ]>
    S<[ B<-l, --lang>=I<lang> ]>
    S<[ B<--log-level>=I<level> ]>
    S<[ B<--foreground> ]>
    S<[ B<-k, --keepcopy>=I<directory> ]>
    S<[ B<-m, --mail> ]>

B<sympa.pl> B<-h, --help>

B<sympa.pl> B<-v, --version>

=head1 DESCRIPTION

B<Sympa> is scalable and highly customizable mailing list manager. 
It can cope with big lists (200,000 subscribers) and comes with 
a complete (user and admin) Web interface. It is 
internationalized, and supports the us, fr, de, es, it, fi, and 
chinese locales. A scripting language allows you to extend the 
behavior of commands. B<Sympa> can be linked to an LDAP directory 
or an RDBMS to create dynamic mailing lists. B<Sympa> provides S/MIME 
and HTTPS based authentication and encryption.
Sympa is a modern mailing-list manager. It supports a lot of useful
features.

=head1 OPTIONS

F<sympa.pl> may run with following options:

=over 4

=item B<-d>, B<--debug>

Enable debug mode.

=item B<-f>, B<--config>=I<file>

Force Sympa to use an alternative configuration file instead
of F<--CONFIG-->.

=item B<-l>, B<--lang>=I<lang>

Set this option to use a language for Sympa. The corresponding
gettext catalog file must be located in F<--localedir-->
directory.

=item B<--log_level>=I<level>

Sets Sympa log level.

=item B<--foreground>

The process remains attached to the TTY.

=item B<-k>, B<--keepcopy>=F<directory>

This option tells Sympa to keep a copy of every incoming message, 
instead of deleting them. `directory' is the directory to 
store messages.

=item B<-m>, B<--mail>

Sympa will log calls to sendmail, including recipients. This option is
useful for keeping track of each mail sent (log files may grow faster
though).

=back

With following options F<sympa.pl> will print some information and exit.

=over 4

=item B<-h>, B<--help>

Print this help message.

=item B<-v>, B<--version>

Print the version number.

=back

=head1 FILES

F<--CONFIG--> main configuration file.

F<--piddir--/sympa.pid> this file contains the process ID
of F<sympa.pl>.

=head1 AVAILABILITY

Latest version of B<Sympa> is available from L<http://www.sympa.org/>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 AUTHORS

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

Contact authors at <sympa-authors@listes.renater.fr>

=head1 COPYRIGHT

Copyright E<169> 1997,1998,1999,2000,2001 ComitE<233> RE<233>seau des UniversitE<233>s

Copyright E<169> 1997,1998,1999 Institut Pasteur & Christophe Wolfhugel

You may distribute this software under the terms of the GNU General
Public License Version 2 (L<http://www.gnu.org/copyleft/gpl.html>)

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa.conf(5)>, L<sympa_wizard(1)>.

L<archived(8)>, L<bulk(8)>, L<bounced(8)>, L<spooler(8)>, L<task_manager(8)>.

L<sendmail(8)>, L<alias_manager(8)>.

L<wwsympa(8)>, L<sympa_soap_server(8)>.

=cut

use strict;
use warnings;
use lib '--modulesdir--';

use Carp qw(croak);
use English qw(-no_match_vars);
use Getopt::Long;
use MIME::Charset;
use Pod::Usage;
use POSIX qw();

use Sympa::Commands;
use Sympa::Conf;
use Sympa::Constants;
use Sympa::DatabaseManager;
use Sympa::Family;
use Sympa::Language;
use Sympa::List;
use Sympa::Log::Database;
use Sympa::Log::Syslog;
use Sympa::Mailer;
use Sympa::Message;
use Sympa::Report;
use Sympa::Robot;
use Sympa::Site;
use Sympa::Spool::File;
use Sympa::Spool::File::Message;
use Sympa::Tools;
use Sympa::Tools::Data;
use Sympa::Tools::Daemon;
use Sympa::Tools::File;
use Sympa::Tools::Message;
use Sympa::Tools::Password;

# dirty global variables
my $is_signed = {};

## Internal tuning
# delay between each read of the digestqueue
my $digestsleep = 5;

## Init random engine
srand(time());

my $version_string =
    sprintf("Sympa version is %s\n", Sympa::Constants::VERSION);

my $daemon_name = Sympa::Tools::Daemon::get_daemon_name($0);
my $ip;
$ip = $ENV{'REMOTE_HOST'};
$ip = $ENV{'REMOTE_ADDR'} unless ($ip);

my %options;
unless (
    GetOptions(
        \%options,
        'config|f=s',
        'debug|d',
        'foreground',
        'help|h',
        'keepcopy|k=s',
        'lang|l=s',
        'log_level=s',
        'mail|m',
        'version|v',
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($options{'debug'}) {
    $options{'log_level'} = 2 unless ($options{'log_level'});
}

# Some option force foreground mode
$options{'foreground'} = 1
    if ($options{'debug'});

$options{'log_to_stderr'} = 1;

if ($options{'help'}) {
    pod2usage(0);
} elsif ($options{'version'}) {
    print $version_string;
    exit 0;
}

## Main loop

my %loop_info;
my %msgid_table;
my $latest_msgid_table_cleanup = time;
my $default_lang;

# this loop is run foreach HUP signal received
my $signal = 0;

our $mailer = Sympa::Mailer->new(
    db_type         => Sympa::Site->db_type(),
    nrcpt_by_domain => Sympa::Site->nrcpt_by_domain(),
);

while ($signal ne 'term') {    #as long as a SIGTERM is not received }

    ## Load sympa.conf.
    unless (Sympa::Robot::get_robots()) {
        print STDERR
            "Unable to load Sympa configuration, file %s or any of the virtual host robot.conf files contain errors. Exiting.\n",
            Sympa::Conf::get_sympa_conf();
        exit 1;
    }

    ## Open the syslog and say we're read out stuff.
    Sympa::Log::Syslog::do_openlog(Sympa::Site->syslog, Sympa::Site->log_socket_type,
        'sympa');

    # setting log_level using conf unless it is set by calling option
    if ($options{'log_level'}) {
        Sympa::Log::Syslog::set_log_level($options{'log_level'});
        Sympa::Log::Syslog::do_log(
            'info',
            'Configuration file read, log level set using options : %s',
            $options{'log_level'}
        );
    } else {
        Sympa::Log::Syslog::set_log_level(Sympa::Site->log_level);
        Sympa::Log::Syslog::do_log('info',
            'Configuration file read, default log level %s',
            Sympa::Site->log_level);
    }

    Sympa::Tools::Password::ciphersaber_installed();

    if (Sympa::Tools::cookie_changed(Sympa::Site->cookie)) {
        Sympa::Log::Syslog::fatal_err(
            'sympa.conf/cookie parameter has changed. You may have severe inconsitencies into password storage. Restore previous cookie or write some tool to re-encrypt password in database and check spools contents (look at %s/cookies.history file)',
            Sympa::Site->etc
        );
    }

    ## Set locale configuration
    # Compatibility with version < 2.3.3
    $options{'lang'} =~ s/\.cat$//
        if defined $options{'lang'};
    $default_lang = $options{'lang'} || Sympa::Site->lang;
    Sympa::Language::SetLang($default_lang);

    ## Main program
    if (!chdir(Sympa::Site->home)) {
        Sympa::Log::Syslog::fatal_err("Can't chdir to %s: %m", Sympa::Site->home);
        ## Function never returns.
    }

    ## Check for several files.
    unless (Sympa::Conf::checkfiles_as_root()) {
        Sympa::Log::Syslog::fatal_err(
            "output checkfiles_as_root : Missing files. Aborting.");
        ## No return.
    }

    if ($signal ne 'hup') {
        ## Put ourselves in background if we're not in debug mode. That method
        ## works on many systems, although, it seems that Unix conceptors have
        ## decided that there won't be a single and easy way to detach a
        ## process from its controlling TTY.
        unless ($options{'foreground'}) {
            if (open(TTY, "/dev/tty")) {
                ioctl(TTY, 0x20007471, 0);    # XXX s/b &TIOCNOTTY
                close(TTY);
            }
            open(STDIN,  ">> /dev/null");
            open(STDOUT, ">> /dev/null");
            open(STDERR, ">> /dev/null");

            setpgrp(0, 0);

            # start the main sympa.pl daemon

            Sympa::Log::Syslog::do_log('debug', 'Starting server %s', $0);
            if ((my $child_pid = fork) != 0) {
                Sympa::Log::Syslog::do_log('info', 'Server started %s PID %s',
                    $0, $child_pid);
                Sympa::Log::Syslog::do_log(
                    'debug',
                    '%s server started, PID %s, exiting from initial process',
                    $0,
                    $child_pid
                );
                exit(0);
            }
        }

        Sympa::Log::Syslog::do_openlog(Sympa::Site->syslog, Sympa::Site->log_socket_type,
            'sympa');

        Sympa::Log::Syslog::do_log('debug', 'Running server %d', $PID);

        # check presence of a PID file from a previous execution
        Sympa::Tools::Daemon::check_old_pid_file(
            name   => 'sympa',
            piddir => Sympa::Constants::PIDDIR,
            tmpdir => Sympa::Site->tmpdir(),
        );

        # Create the PID file
        Sympa::Tools::Daemon::write_pid(
            name   => 'sympa',
            pid    => $PID,
            piddir => Sympa::Constants::PIDDIR,
            user   => Sympa::Constants::USER,
            group  => Sympa::Constants::GROUP,
        );
        # redirect STDERR to a file, unless the process is running in foreground
        unless ($options{'foreground'}) {
            Sympa::Tools::Daemon::direct_stderr_to_file(
                pid    => $PID,
                tmpdir => Sympa::Site->tmpdir(),
                user   => Sympa::Constants::USER,
                group  => Sympa::Constants::GROUP,
            );
        }

        # Set the User ID & Group ID for the process
        $GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
        $UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

        ## Required on FreeBSD to change ALL IDs
        ## (effective UID + real UID + saved UID)
        POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
        POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

        ## Check if the UID has correctly been set (useful on OS X)
        unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
            && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
            Sympa::Log::Syslog::fatal_err(
                "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo."
            );
        }

        # Sets the UMASK
        umask(oct(Sympa::Site->umask));

        ## Most initializations have now been done.
        Sympa::Log::Syslog::do_log('notice', "Sympa %s started",
            Sympa::Constants::VERSION);
    } else {
        Sympa::Log::Syslog::do_log('notice', "Sympa %s reload config",
            Sympa::Constants::VERSION);
        $signal = '0';
    }

    unless (Sympa::Conf::checkfiles()) {
        Sympa::Log::Syslog::fatal_err("Missing files. Aborting.");
    }

    ## Do we have right access in the directory
    if ($options{'keepcopy'}) {
        if (!-d $options{'keepcopy'}) {
            Sympa::Log::Syslog::do_log(
                'notice',
                'Cannot keep a copy of incoming messages : %s is not a directory',
                $options{'keepcopy'}
            );
            delete $options{'keepcopy'};
        } elsif (!-w $options{'keepcopy'}) {
            Sympa::Log::Syslog::do_log(
                'notice',
                'Cannot keep a copy of incoming messages : no write access to %s',
                $options{'keepcopy'}
            );
            delete $options{'keepcopy'};
        }
    }

    ## Catch SIGTERM, in order to exit cleanly, whenever possible.
    $SIG{'TERM'} = 'sigterm';
    $SIG{'HUP'}  = 'sighup';
    $SIG{'PIPE'} = 'IGNORE';  ## Ignore SIGPIPE ; prevents sympa.pl from dying

    my $index_queuedigest = 0;    # verify the digest queue
    my $index_cleanqueue  = 0;
    my @qfile;

    my $spool = Sympa::Spool::File::Message->new();
    ## This is the main loop : look for files in the directory, handles
    ## them, sleeps a while and continues the good job.
    while (!$signal) {

        Sympa::Language::SetLang($default_lang);

        Sympa::List::init_list_cache();

        # Process grouped notifications
        Sympa::Site->send_notify_to_listmaster(undef, undef, 1, undef);

        ## Scan queuedigest it should be performed by task manager !
        if ($index_queuedigest++ >= $digestsleep) {
            $index_queuedigest = 0;
            SendDigest();
        }

        # it should be performed by task manager !
        ## Clean queue (bad)
        if ($index_cleanqueue++ >= 1) {
            $index_cleanqueue = 0;
            Sympa::Log::Syslog::do_log('debug', 'Cleaning spools');
            my $msg_bad = Sympa::Spool::File->new('msg', 'bad');
            $msg_bad->clean({'delay' => Sympa::Site->clean_delay_queue});
            my $archive_bad = Sympa::Spool::File->new('outgoing', 'bad');
            $archive_bad->clean({'delay' => Sympa::Site->clean_delay_queueoutgoing});
            my $queuebounce_bad = Sympa::Spool::File->new('bounce', 'bad');
            $queuebounce_bad->clean(
                {'delay' => Sympa::Site->clean_delay_queuebounce});
            my $queuemod = Sympa::Spool::File->new('mod');
            $queuemod->clean({'delay' => Sympa::Site->clean_delay_queuemod});
            my $queueauth = Sympa::Spool::File->new('auth');
            $queueauth->clean({'delay' => Sympa::Site->clean_delay_queueauth});
            my $queuetopic = Sympa::Spool::File->new('topic');
            $queuetopic->clean({'delay' => Sympa::Site->clean_delay_queuetopic});
            my $queuesubscribe = Sympa::Spool::File->new('subscribe');
            $queuesubscribe->clean(
                {'delay' => Sympa::Site->clean_delay_queuesubscribe});
            my $queuesignoff = Sympa::Spool::File->new('signoff');
            $queuesignoff->clean({'delay' => Sympa::Site->clean_delay_queuesignoff});
            my $queueautomatic = Sympa::Spool::File->new('automatic');
            $queueautomatic->clean(
                {'delay' => Sympa::Site->clean_delay_queueautomatic});

            # this is not a message spool
            Sympa::Tools::File::CleanDir(Sympa::Site->tmpdir, Sympa::Site->clean_delay_tmpdir);
        }
        ## Cleanup in-memory msgid table, only in a while
        if (time >
            $latest_msgid_table_cleanup + Sympa::Site->msgid_table_cleanup_frequency)
        {
            clean_msgid_table();
            $latest_msgid_table_cleanup = time;
        }

        $mailer->reaper();    # finish terminated process

        my $message_in_spool = $spool->next;
        my $message;
        $message = Sympa::Message->new(%$message_in_spool)
            if $message_in_spool;
        unless ($message) {
            sleep(Sympa::Site->sleep);
            next;
        }
        my $list  = $message->get_list();
        my $robot = $message->get_robot();
        Sympa::Log::Syslog::do_log(
            'info', 'Processing message %s for %s function %s',
            $message,
            ($list || $robot),
            ($message->{'listtype'} || '(post)')
        );

        if (!defined $options{'mail'}
            or "$options{'mail'}" ne '1') {
            $options{'mail'} = $message->get_robot()->get_id
                if $message->get_robot()->log_smtp;
        }

        ## Set NLS default lang for current message
        $default_lang = $options{'lang'} || $message->get_robot()->lang;
        Sympa::Language::SetLang($default_lang);

        my $status = process_message($message);

        if (defined($status)) {
            Sympa::Log::Syslog::do_log(
                'info',
                'Done processing message %s for %s function %s',
                $message,
                ($list || $robot),
                ($message->{'listtype'} || '(post)')
            );
            $spool->remove_message($message_in_spool->{'messagekey'});
            ##$spool->unlock_message($message_in_spool->{'messagekey'});
        } else {

            # Do not remove message task_manager will purge database removing
            # messages in spool distribute that have no links with
            # bulkspool_stable
            # $spool->remove_message(
            #     {'messagekey' => $message_in_spool->{'messagekey'}});

            # move message to bad.
            unless ($spool->move_to_bad($message_in_spool->{'messagekey'})) {
                Sympa::Log::Syslog::do_log('err',
                    'Unable to move message %s to bad. Stopping here.',
                    $message);
                exit 1;
            }
            Sympa::Log::Syslog::do_log(
                'notice',
                'Message %s for %s function %s was moved to bad spool',
                $message,
                ($list || $robot),
                ($message->{'listtype'} || '(post)')
            );
        }
    }    ## END of infinite loop

    # Purge grouped notifications
    Sympa::Site->send_notify_to_listmaster(undef, undef, undef, 1);

    ## Disconnect from Database
    Sympa::DatabaseManager::db_disconnect;

}    #end of block while ($signal ne 'term'){

Sympa::Log::Syslog::do_log('notice', 'Sympa exited normally due to signal');
Sympa::Tools::Daemon::remove_pid(
    name   => 'sympa',
    pid    => $PID,
    piddir => Sympa::Constants::PIDDIR,
    tmpdir => Sympa::Site->tmpdir(),
);

exit(0);

############################################################
# sigterm
############################################################
#  When we catch SIGTERM, just changes the value of the $signal
#  loop variable.
#
# IN : -
#
# OUT : -
#
############################################################
sub sigterm {
    Sympa::Log::Syslog::do_log('notice',
        'signal TERM received, still processing current task');
    $signal = 'term';
}

############################################################
# sighup
############################################################
#  When we catch SIGHUP, changes the value of the $signal
#  loop variable and puts the "-mail" logging option
#
# IN : -
#
# OUT : -
#
###########################################################
sub sighup {
    if ($options{'mail'}) {
        Sympa::Log::Syslog::do_log('notice',
            'signal HUP received, switch of the "-mail" logging option and continue current task'
        );
        undef $options{'mail'};
    } else {
        Sympa::Log::Syslog::do_log('notice',
            'signal HUP received, switch on the "-mail" logging option and continue current task'
        );
        $options{'mail'} = 1;
    }
    $signal = 'hup';
}

############################################################
#  process_message
############################################################
#  Handles a file received and files in the queue directory.
#  This will read the file, separate the header and the body
#  of the message and call the adequate function wether we
#  have received a command or a message to be redistributed
#  to a list.
#
# IN : -$file (+): the file to handle
#
# OUT : $status
#     | undef
#
##############################################################
sub process_message {
    Sympa::Log::Syslog::do_log('debug2', '(%s)', @_);
    my $message = shift;

    ## get listname & robot
    my $listname = $message->{'listname'};
    my $robot_id = $message->{'robot_id'} || Sympa::Site->domain;
    my $list     = $message->get_list();
    my $robot    = $message->get_robot();
    my $sender   = $message->get_sender_email;
    my $type     = $message->{'listtype'};
    my $status;

    my $msg    = $message->get_mime_message;
    my $hdr    = $msg->head;
    my $msg_id = $message->get_msg_id;

    ## Ignoring messages with no sender
    unless ($sender) {
        Sympa::Log::Syslog::do_log('err',
            'No sender found in message, skipping.');
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot_id,
                'list'         => $listname,
                'action'       => 'process_message',
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'no_sender',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    Sympa::Log::Syslog::do_log('notice',
        'Processing: sender: %s ; message: %s',
        $sender, $message);

    ## Unknown robot
    unless ($robot) {
        Sympa::Log::Syslog::do_log('err', 'robot %s does not exist',
            $robot_id);
        Sympa::Site->send_dsn($message,
            {'recipient' => sprintf('%s@%s', $listname, $robot_id)}, '5.1.2');
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot_id,
                'list'         => $listname,
                'action'       => 'process_message',
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'unknown_robot',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    # setting log_level using conf unless it is set by calling option
    unless ($options{'log_level'}) {
        Sympa::Log::Syslog::set_log_level($robot->log_level);
        Sympa::Log::Syslog::do_log(
            'debug',
            'Setting log level with robot %s configuration (or sympa.conf) : %d',
            $robot->log_level
        );
    }

    ## Initialize command report
    Sympa::Report::init_report_cmd();

    ## Maybe daemon is handling an automatic list
    my $dyn_list_family = $message->get_family;
    my $dyn_just_created;

    my $list_address;

    if ($type and ($type eq 'sympa' or $type eq 'listmaster')) {
        $list_address = $robot->get_address($type);
    } else {
        unless (defined $list) {
            unless (defined $dyn_list_family) {
                Sympa::Log::Syslog::do_log('err', 'list %s@%s does not exist',
                    $listname, $robot_id);
                $robot->send_dsn($message, {'listname' => $listname},
                    '5.1.1');
                Sympa::Log::Database::db_log(
                    {   'robot'        => $robot_id,
                        'list'         => $listname,
                        'action'       => 'process_message',
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'unknown_list',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }

            ## Automatic creation of a mailing list, based on a family
            my $dyn_family;
            unless ($dyn_family = Sympa::Family->new($dyn_list_family, $robot)) {
                Sympa::Log::Syslog::do_log(
                    'err',
                    "Failed to process message: family %s does not exist, impossible to create the dynamic list.",
                    $dyn_list_family
                );
                $robot->send_notify_to_listmaster(
                    'automatic_list_creation_failed',
                    {   'family' => $dyn_list_family,
                        'robot'  => $robot_id,
                        'msg_id' => $msg_id,
                    }
                );
                $robot->send_dsn($message, {'listname' => $listname},
                    '5.3.5');
                return undef;
            }

            my $auth_level = 'smtp';
            $auth_level = 'dkim'  if $message->{'dkim_pass'};
            $auth_level = 'md5'   if $message->authenticated;
            $auth_level = 'smime' if $message->{'smime_signed'};
            if ($list = $dyn_family->create_automatic_list(
                    (   'listname'   => $listname,
                        'auth_level' => $auth_level,
                        'sender'     => $sender,
                        'message'    => $message
                    )
                )
                ) {
                $dyn_just_created = 1;
            } else {
                Sympa::Log::Syslog::do_log('err',
                    'Unable to create list %s@%s. Message %s ignored.',
                    $listname, $robot_id, $message);
                $robot->send_notify_to_listmaster(
                    'automatic_list_creation_failed',
                    {   'listname' => $listname,
                        'family'   => $dyn_list_family,
                        'robot'    => $robot_id,
                        'msg_id'   => $msg_id
                    }
                );
                $robot->send_dsn($message, {'listname' => $listname},
                    '5.3.5');
                Sympa::Log::Database::db_log(
                    {   'robot'        => $robot_id,
                        'list'         => $listname,
                        'action'       => 'process_message',
                        'parameters'   => $msg_id,             # FIXME
                        'target_email' => '',
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'internal',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                return undef;
            }
        }
        $list_address = $list->get_address();
    }
    ## Loop prevention
    if ($list and $list->reject_mail_from_automates_feature eq 'on') {
        my $conf_loop_prevention_regex;
        $conf_loop_prevention_regex = $list->loop_prevention_regex
            || $robot->loop_prevention_regex;
        if ($sender =~ /^($conf_loop_prevention_regex)(\@|$)/mio) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Ignoring message %s from %s which would cause a loop; "%s" matches loop_prevention_regex',
                $message,
                $sender,
                $1
            );
            return undef;
        }

        ## Ignore messages that would cause a loop
        ## Content-Identifier: Auto-replied is generated by some non standard
        ## X400 mailer
        if (    $hdr->get('Content-Identifier')
            and $hdr->get('Content-Identifier') =~ /Auto-replied/i
            or $hdr->get('X400-Content-Identifier')
            and $hdr->get('X400-Content-Identifier') =~ /Auto Reply to/i
            or $hdr->get('Auto-Submitted')
            and $hdr->get('Auto-Submitted') !~ /^no$/i) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Ignoring message %s which would cause a loop; message appears to be an auto-reply',
                $message
            );
            return undef;
        }
    }

    ## Q- and B-decode subject
    my $subject_field = $message->{'decoded_subject'};

    ## Loop prevention
    my $loop;
    foreach $loop ($message->get_header('X-Loop')) {
        Sympa::Log::Syslog::do_log('debug3', 'X-Loop: %s', $loop);
        if ($loop eq lc($list_address)) {
            Sympa::Log::Syslog::do_log('err',
                'Ignoring message %s which would cause a loop; X-Loop: %s',
                $message, $loop);
            return undef;
        }
    }

    ## S/MIME or DKIM signed messages
    if ($message->{'smime_signed'}) {

        # subject semantic is related to X509 (subject is the private key
        # owner, not the message Subject header !)
        $is_signed = {
            'subject' => $message->{'smime_subject'},
            'body'    => 'smime'
        };
    } else {
        undef $is_signed;
    }

    # anti-virus
    my $rc = Sympa::Tools::Message::virus_infected($message->as_entity());
    if ($rc) {
        if ($robot->antivirus_notify eq 'sender') {
            unless (
                $robot->send_file(
                    'your_infected_msg',
                    $sender,
                    {   'virus_name'     => $rc,
                        'recipient'      => $list_address,
                        'lang'           => ($robot->lang || 'en'),
                        'auto_submitted' => 'auto-replied'
                    }
                )
                ) {
                Sympa::Log::Syslog::do_log('notice',
                    'Unable to send template "your infected_msg" to %s',
                    $sender);
            }
        }
        Sympa::Log::Syslog::do_log(
            'notice',
            'Ignoring message %s for %s function %s from %s; virus "%s" found',
            $message,
            ($list || $robot),
            ($type || '(post)'),
            $sender,
            $rc
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot_id,
                'list'         => $listname,
                'action'       => 'process_message',
                'target_email' => "",
                'msg_id'       => $msg_id,
                'status'       => 'error',
                'error_type'   => 'virus',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;

    } elsif (!defined($rc)) {
        $robot->send_notify_to_listmaster('antivirus_failed',
            'Could not scan message; The message has been saved as "bad".');
        return undef;
    }

    if (Sympa::Site->automatic_list_feature eq 'on') {
        if (defined $dyn_list_family and $dyn_just_created) {
            unless (defined $list->sync_include()) {
                Sympa::Log::Syslog::do_log(
                    'err',
                    'Failed to synchronize list members of dynamic list %s from family %s',
                    $list,
                    $list->family
                );
                $robot->send_dsn($message, {'listname' => $listname},
                    '4.2.1');

                #FIXME: Notify listmaster?
                Sympa::Log::Database::db_log(
                    {   'robot'        => $robot_id,
                        'list'         => $listname,
                        'action'       => 'process_message',
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'dyn_cant_sync',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );

                # purge the unwanted empty automatic list
                if (Sympa::Site->automatic_list_removal =~ /if_empty/i) {
                    $list->close_list();
                    $list->purge();

                    # verifier pour tt ce bloc si supprime bien tout
                }
                return undef;
            }
            unless ($list->total > 0) {
                Sympa::Log::Syslog::do_log('err',
                    'Dynamic list %s from family %s has ZERO subscribers',
                    $list, $dyn_list_family);
                $list->send_dsn($message, {}, '4.2.4');
                Sympa::Log::Database::db_log(
                    {   'robot'        => $robot_id,
                        'list'         => $listname,
                        'action'       => 'process_message',
                        'target_email' => "",
                        'msg_id'       => $msg_id,
                        'status'       => 'error',
                        'error_type'   => 'list_unknown',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );

                # purge the unwanted empty automatic list
                if (Sympa::Site->automatic_list_removal =~ /if_empty/i) {
                    $list->close_list();
                    $list->purge();

                    # verifier pour tt ce bloc si supprime bien tout
                }
                return undef;
            }
            Sympa::Log::Syslog::do_log('info',
                'Successfully create list %s with %s subscribers',
                $list, $list->total);
        }
    }

    if ($type and $type eq 'listmaster') {
        $status = DoForward($message, 'listmaster');
    } elsif ($type and $type eq 'sympa') {
        ## Mail addressed to the robot is commands.
        $status = DoCommand($message);
    } elsif (
        $type and grep {
            $_ eq $type
        } qw(subscribe unsubscribe)
        ) {
        ## Mail addressed to <list>-subscribe or <list>-unsubscribe is
        ## commands.
        $status = DoCommand($message, $type);
    } elsif (
        $type and grep {
            $_ eq $type
        } qw(return_path owner editor)
        ) {
        ## forward mails to <list>-request <list>-owner etc.
        ## Simulate Smartlist behaviour with command in subject
        my $name = $list->name;
        if (    $type eq 'owner'
            and $subject_field =~
            /^\s*(subscribe|unsubscribe)(\s+$name)?\s*$/i) {
            my $command = lc $1;
            $status = DoCommand($message, $command);
        } else {
            $status = DoForward($message, $type);
        }
    } else {
        $status = DoMessage($message);
    }

    ## Mail back the result.
    if (Sympa::Report::is_there_any_report_cmd()) {

        ## Loop prevention

        ## Count reports sent to $sender
        $loop_info{$sender}{'count'}++;

        ## Sampling delay
        if (time - ($loop_info{$sender}{'date_init'} || 0) <
            Sympa::Site->loop_command_sampling_delay) {

            ## Notify listmaster of first rejection
            if ($loop_info{$sender}{'count'} == Sympa::Site->loop_command_max) {
                ## Notify listmaster
                $robot->send_notify_to_listmaster('loop_command',
                    {'msg' => $message});
            }

            ## Too many reports sent => message skipped !!
            if ($loop_info{$sender}{'count'} >= Sympa::Site->loop_command_max) {
                Sympa::Log::Syslog::do_log(
                    'err',
                    'Ignoring message %s which would cause a loop; %d messages sent to %s; loop_command_max exceeded',
                    $message,
                    $loop_info{$sender}{'count'},
                    $sender
                );

                return undef;
            }
        } else {
            ## Sampling delay is over, reinit
            $loop_info{$sender}{'date_init'} = time;

            ## We apply Decrease factor if a loop occurred
            $loop_info{$sender}{'count'} *=
                Sympa::Site->loop_command_decrease_factor;
        }

        ## Send the reply message
        Sympa::Report::send_report_cmd($sender, $robot_id);
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot_id,
                'list'         => $listname,
                'action'       => 'process_message',
                'parameters'   => '',
                'target_email' => '',
                'msg_id'       => $msg_id,
                'status'       => 'success',
                'error_type'   => '',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );

    }

    return $status;
}

############################################################
#  DoForward
############################################################
#  Handles a message sent to [list]-editor : the list editor,
#  [list]-request : the list owner or the listmaster.
#  Message is forwarded according to $function
#
# IN : -$message (+): ref(message object).
#      -$function (+): 'listmaster'|'owner'|'editor'
#
# OUT : 1
#     | undef
#
############################################################
sub DoForward {
    Sympa::Log::Syslog::do_log('debug2', '(%s, %s)', @_);
    my ($message, $function) = @_;

    my $robot = $message->get_robot();
    my $list  = $message->get_list();
    unless ($list or $robot) {
        croak 'bug in logic.  Ask developer';
    }

    my $msg        = $message->as_entity();
    my $hdr        = $msg->head;
    my $messageid  = $message->get_msg_id;
    my $msg_string = $message->as_string();        # raw message
    my $sender     = $message->get_sender_email;

    if ($message->{'spam_status'} and $message->{'spam_status'} eq 'spam') {
        Sympa::Log::Syslog::do_log('notice',
            "Message %s for %s function %s ignored, because tagged as spam",
            $message, ($list || $robot), $function,);
        return undef;
    }

    Sympa::Log::Syslog::do_log(
        'info', 'Processing message %s for %s function %s with priority %s',
        $message, ($list || $robot),
        $function, $message->{'priority'}
    );

    # Prevent loop.
    $hdr->add('X-Loop', ($list || $robot)->get_address($function));

    my @rcpt;
    if ($function eq 'listmaster') {
        @rcpt = @{$robot->listmasters || Sympa::Site->listmasters || []};
        Sympa::Log::Syslog::do_log(
            'notice',
            'Warning : no listmaster defined in robot.conf for robot %s nor sympa.conf',
            $robot
        ) unless @rcpt;
    } elsif ($function eq 'owner') {    # -request
        @rcpt = $list->get_owners_email();
        Sympa::Log::Syslog::do_log(
            'notice',
            'Warning : no owner defined or all of them use nomail option in list %s',
            $list
        ) unless @rcpt;
    } elsif ($function eq 'editor') {
        @rcpt = $list->get_editors_email();

        Sympa::Log::Syslog::do_log(
            'notice',
            'Warning : no owner and editor defined or all of them use nomail option in list %s',
            $list
        ) unless @rcpt;
    } else {
        Sympa::Log::Syslog::do_log('err', 'Unknown function "%s"', $function);
        return undef;
    }

    ## Did we find a recipient?
    unless (@rcpt) {
        if ($function ne 'listmaster') {
            Sympa::Log::Syslog::do_log(
                'err',
                'No recipient available in message %s for %s function %s. Trying to proceed ignoring nomail option',
                $message,
                ($list || $robot),
                $function
            );

            if ($function eq 'owner') {    # -request
                @rcpt = $list->get_owners_email({'ignore_nomail', 1});
                Sympa::Log::Syslog::do_log('notice',
                    'Warning : no owner defined at all in list %s', $list)
                    unless @rcpt;
            } elsif ($function eq 'editor') {
                @rcpt = $list->get_editors_email({'ignore_nomail', 1});
                Sympa::Log::Syslog::do_log(
                    'notice',
                    'Warning : no owner and editor defined at all in list %s',
                    $list
                ) unless @rcpt;
            }
        }
        ## Could we find a recipient by ignoring the "nomail" option?
        if (@rcpt) {
            Sympa::Log::Syslog::do_log(
                'notice',
                'All the intended recipients of message %s in list %s have set the "nomail" option. Ignoring it and sending it to all of them.',
                $message,
                $list
            );
        } else {
            Sympa::Log::Syslog::do_log(
                'err',
                'Impossible to forward a message %s to %s function %s: Undefined function',
                $message,
                $list,
                $function
            );
            my $string =
                sprintf
                'Impossible to forward a message %s to %s function %s: undefined function',
                $message->get_id, $list->get_id, $function;
            Sympa::Report::reject_report_msg(
                'intern', $string, $sender,
                {   'msg_id'   => $messageid,
                    'entry'    => 'forward',
                    'function' => $function,
                    'message'  => $msg
                },
                $robot,
                $msg_string,
                $list
            );
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoForward',
                    'parameters'   => $function,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
    }

    my $listname = '';
    $listname = $list->name if $list;

    # my $msg_copy = $msg->dup;
    $message->{'msg'} = $msg;
    unless (
        $mailer->forward_message(
            message => $message,
            from    => $robot->get_address('owner'), #FIXME: 'return_path'
            rcpt    => \@rcpt,
            robot   => $robot
        )
        ) {
        Sympa::Log::Syslog::do_log('err',
            'Impossible to forward message %s for %s function %s',
            $message, $list, $function);
        my $string = sprintf
            'Impossible to forward message %s for %s function %s',
            $message->get_id, $list->get_id, $function;
        Sympa::Report::reject_report_msg(
            'intern', $string, $sender,
            {   'msg_id'   => $messageid,
                'entry'    => 'forward',
                'function' => $function,
                'message'  => $msg
            },
            $robot,
            $msg_string,
            $list
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $listname,
                'action'       => 'DoForward',
                'parameters'   => $function,      #FIXME
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }
    Sympa::Log::Database::db_log(
        {   'robot'        => $robot->name,
            'list'         => $listname,
            'action'       => 'DoForward',
            'parameters'   => $function,
            'target_email' => '',
            'msg_id'       => $messageid,
            'status'       => 'success',
            'error_type'   => '',
            'user_email'   => $sender,
            'client'       => $ip,
            'daemon'       => $daemon_name
        }
    );

    return 1;
}

####################################################
#  DoMessage
####################################################
#  Handles a message sent to a list. (Those that can
#  make loop and those containing a command are
#  rejected)
#
# IN : -$message (+): ref(Message)
#
# OUT : 1 if ok (in order to remove the file from the queue)
#     | undef
#
####################################################
sub DoMessage {
    my $message = shift;
    Sympa::Log::Syslog::do_log(
        'debug2',
        '(%s, list=%s, sender=%s, size=%s, smime_crypted=%s)',
        $message,
        $message->get_list(),
        $message->{'sender'},
        $message->{'size'},
        $message->{'smime_crypted'}
    );

    my $list  = $message->get_list();
    my $robot = $message->get_robot();

    my $hdr = $message->as_entity()->head;

    my $messageid  = $message->get_msg_id;
    my $msg        = $message->as_entity();
    my $msg_string = $message->as_string();    # raw message

    my $sender = $message->get_sender_email;

    my ($listname, $host) = ($list->name, $list->host);
    my $start_time = time;
    Sympa::Language::SetLang($list->lang);

    ## Now check if the sender is an authorized address.

    Sympa::Log::Syslog::do_log('info',
        'Processing message %s for %s from %s with priority %s',
        $message, $list, $sender, $message->{'priority'});

    if ($msgid_table{$list->get_id}{$messageid}) {
        Sympa::Log::Syslog::do_log('err',
            'Found known Message-ID, ignoring message which would cause a loop'
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'known_message',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    # Reject messages with commands
    if (Sympa::Site->misaddressed_commands =~ /reject/i) {
        ## Check the message for commands and catch them.
        if (Sympa::Tools::checkcommand($message->as_entity(), $sender, $robot)) {
            Sympa::Log::Syslog::do_log('err',
                'Found command in message, ignoring message');
            Sympa::Report::reject_report_msg('user', 'routing_error', $sender,
                {'message' => $message},
                $robot, $msg_string, $list);
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoMessage',
                    'parameters'   => $messageid,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'routing_error',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
    }

    ## Check if the message is too large
    my $max_size = $list->get_max_size();

    if ($max_size and $message->{'size'} > $max_size) {
        Sympa::Log::Syslog::do_log('info',
            'Rejecting message %s for list %s from %s; too large (%d > %d)',
            $message, $listname, $sender, $message->{'size'}, $max_size);
        $list->send_dsn(
            $message,
            {   'msg_size' => int($message->{'size'} / 1024),
                'max_size' => int($max_size / 1024)
            },
            '5.2.3'
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'message_too_large',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    my $rc;

    my $context = {
        'sender'  => $sender,
        'message' => $message
    };

    ## list msg topic
    if ($list->is_there_msg_topic()) {

        my $info_msg_topic = $list->load_msg_topic($messageid);

        # is msg already tagged ?
        if (ref($info_msg_topic) eq "HASH") {
            if ($info_msg_topic->{'method'} eq "sender") {
                $context->{'topic_sender'} = $info_msg_topic->{'topic'};

            } elsif ($info_msg_topic->{'method'} eq "editor") {
                $context->{'topic_editor'} = $info_msg_topic->{'topic'};

            } elsif ($info_msg_topic->{'method'} eq "auto") {
                $context->{'topic_auto'} = $info_msg_topic->{'topic'};
            }
        } else {

            # not already tagged
            $context->{'topic_auto'} = $list->automatic_tag($message);
        }

        $context->{'topic'} =
               $context->{'topic_auto'}
            || $context->{'topic_sender'}
            || $context->{'topic_editor'};
        $context->{'topic_needed'} =
            (!$context->{'topic'} && $list->is_msg_topic_tagging_required());
    }

    ## Call scenarios: auth_method MD5 do not have any sense in send
    ## scenarios because auth is perfom by distribute or reject command.

    my $action;
    my $result;

    # the order of the following 3 lines is important ! S/MIME > DKIM > SMTP
    my $auth_method = 'smtp';
    $auth_method = 'dkim'  if ($message->{'dkim_pass'});
    $auth_method = 'md5'   if $message->authenticated;
    $auth_method = 'smime' if ($is_signed->{'body'});

    $result = Sympa::Scenario::request_action($list, 'send', $auth_method, $context);
    $action = $result->{'action'} if ref $result eq 'HASH';

    unless (defined $action) {
        Sympa::Log::Syslog::do_log(
            'err',
            'Message %s ignored because unable to evaluate scenario "send" for list %s',
            $message,
            $list
        );
        Sympa::Report::reject_report_msg(
            'intern',
            'Message ignored because scenario "send" cannot be evaluated',
            $sender,
            {'msg_id' => $messageid, 'message' => $message},
            $robot,
            $msg_string,
            $list
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    ## message topic context
    if (($action =~ /^do_it/) && ($context->{'topic_needed'})) {
        $action = 'editorkey'
            if $list->msg_topic_tagging eq 'required_moderator';
        $action = 'request_auth'
            if $list->msg_topic_tagging eq 'required_sender';
    }

    if ($action =~ /^do_it/) {
        my $apply_dkim_signature = 'off';
        $apply_dkim_signature = 'on'
            if Sympa::Tools::Data::is_in_array($list->dkim_signature_apply_on, 'any');
        $apply_dkim_signature = 'on'
            if Sympa::Tools::Data::is_in_array($list->dkim_signature_apply_on,
            'smime_authenticated_messages')
            and $is_signed->{'body'};
        $apply_dkim_signature = 'on'
            if Sympa::Tools::Data::is_in_array($list->dkim_signature_apply_on,
            'dkim_authenticated_messages');

        ## Check TT2 syntax for merge_feature.
        unless ($message->test_personalize($list)) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Failed to personalize. Message %s for list %s was rejected',
                $message,
                $list
            );
            $list->send_dsn($message, {}, '5.6.5');
            return undef;
        }

        my $numsmtp;
        eval {
            $numsmtp = $list->distribute_msg(
                'message'              => $message,
                'apply_dkim_signature' => $apply_dkim_signature
            );
        };
        if ($EVAL_ERROR) {
            Sympa::Log::Syslog::do_log('err',
                'FATAL: Failed to distribute message: %s', $EVAL_ERROR);
        }
        ## Keep track of known message IDs...if any
        $msgid_table{$list->get_id}{$messageid} = time if $messageid;

        unless (defined($numsmtp)) {
            Sympa::Log::Syslog::do_log('err',
                'Unable to send message to list %s', $list);
            Sympa::Report::reject_report_msg('intern', '', $sender,
                {'msg_id' => $messageid, 'message' => $message},
                $robot, $msg_string, $list);
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoMessage',
                    'parameters'   => $messageid,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
        Sympa::Log::Syslog::do_log(
            'info',
            'Message %s for %s from %s accepted; %d seconds, %d sessions, %d subscribers, size=%d',
            $message,
            $list,
            $sender,
            time - $start_time,
            $numsmtp,
            $list->total,
            $message->{'size'}
        );

        return 1;

    } elsif ($action =~ /^request_auth/) {
        ## Check syntax for merge_feature.
        unless ($message->test_personalize($list)) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Failed to personalize. Message %s for list %s was rejected',
                $message,
                $list
            );
            $list->send_dsn($message, {}, '5.6.5');
            return undef;
        }

        my $key = $list->send_auth($message);

        unless (defined $key) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Calling to send_auth function failed for user %s in list %s',
                $sender,
                $list
            );
            Sympa::Report::reject_report_msg(
                'intern', 'The request authentication sending failed',
                $sender, {'msg_id' => $messageid, 'message' => $message},
                $robot, $msg_string,
                $list
            );
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoMessage',
                    'parameters'   => $messageid,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }
        Sympa::Log::Syslog::do_log('notice',
            'Message %s for %s from %s kept for authentication with key %s',
            $message, $list, $sender, $key);
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'success',
                'error_type'   => 'kept_for_auth',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return 1;
    } elsif ($action =~ /^editorkey((?:\s*,\s*quiet)?)/) {
        ## Check syntax for merge_feature.
        unless ($message->test_personalize($list)) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Failed to personalize. Message %s for list %s was rejected',
                $message,
                $list
            );
            $list->send_dsn($message, {}, '5.6.5');
            return undef;
        }

        my $is_quiet = $1 || undef;
        my $key = $list->send_to_editor('md5', $message);

        unless (defined $key) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Calling to send_to_editor() function failed for user %s in list %s',
                $sender,
                $list
            );
            Sympa::Report::reject_report_msg(
                'intern',
                'The request moderation sending to moderator failed.',
                $sender,
                {'msg_id' => $messageid, 'message' => $message},
                $robot,
                $msg_string,
                $list
            );
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoMessage',
                    'parameters'   => $messageid,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        Sympa::Log::Syslog::do_log('info',
            'Key %s for list %s from %s sent to editors; %s',
            $key, $list, $sender, $message->{'filename'});

        # do not report to the sender if the message was tagged as a spam
        unless (
            $is_quiet
            or (    $message->{'spam_status'}
                and $message->{'spam_status'} eq 'spam')
            ) {
            unless (
                Sympa::Report::notice_report_msg(
                    'moderating_message', $sender,
                    {'message' => $message}, $robot,
                    $list
                )
                ) {
                Sympa::Log::Syslog::do_log(
                    'notice',
                    'Unable to send template "message_report", entry "moderating_message" to %s',
                    $sender
                );
            }
        }
        return 1;
    } elsif ($action =~ /^editor((?:\s*,\s*quiet)?)/) {
        ## Check syntax for merge_feature.
        unless ($message->test_personalize($list)) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Failed to personalize. Message %s for list %s was rejected',
                $message,
                $list
            );
            $list->send_dsn($message, {}, '5.6.5');
            return undef;
        }

        my $is_quiet = $1 || undef;
        my $key = $list->send_to_editor('smtp', $message);

        unless (defined $key) {
            Sympa::Log::Syslog::do_log(
                'err',
                'Calling to send_to_editor() function failed for user %s in list %s',
                $sender,
                $list
            );
            Sympa::Report::reject_report_msg(
                'intern',
                'The request moderation sending to moderator failed.',
                $sender,
                {'msg_id' => $messageid, 'message' => $message},
                $robot,
                $msg_string,
                $list
            );
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => $list->name,
                    'action'       => 'DoMessage',
                    'parameters'   => $messageid,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'internal',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        Sympa::Log::Syslog::do_log('info',
            'Message %s for %s from %s sent to editors',
            $message, $list, $sender);

        # do not report to the sender if the message was tagged as a spam
        unless (
            $is_quiet
            or (    $message->{'spam_status'}
                and $message->{'spam_status'} eq 'spam')
            ) {
            unless (
                Sympa::Report::notice_report_msg(
                    'moderating_message', $sender,
                    {'message' => $message}, $robot,
                    $list
                )
                ) {
                Sympa::Log::Syslog::do_log(
                    'notice',
                    'Unable to send template "message_report", type "success", entry "moderating_message" to %s',
                    $sender
                );
            }
        }
        return 1;
    } elsif ($action =~ /^reject((?:\s*,\s*quiet)?)/) {
        my $is_quiet = $1 || undef;
        Sympa::Log::Syslog::do_log('notice',
            'Message %s for %s from %s rejected; (%s) sender not allowed',
            $message, $list, $sender, $result->{'tt2'});

        # do not report to the sender if the message was tagued as a spam
        unless (
            $is_quiet
            or (    $message->{'spam_status'}
                and $message->{'spam_status'} eq 'spam')
            ) {
            if (defined $result->{'tt2'}) {
                unless (
                    $list->send_file(
                        $result->{'tt2'}, $sender,
                        {'auto_submitted' => 'auto-replied'}
                    )
                    ) {
                    Sympa::Log::Syslog::do_log('notice',
                        'Unable to send template "%s" to %s',
                        $result->{'tt2'}, $sender);
                }
            } else {
                unless (
                    Sympa::Report::reject_report_msg(
                        'auth', $result->{'reason'},
                        $sender, {'message' => $message},
                        $robot, $msg_string,
                        $list
                    )
                    ) {
                    Sympa::Log::Syslog::do_log(
                        'notice',
                        'Unable to send template "message_report", type "auth" to %s',
                        $sender
                    );
                }
            }
        }
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'rejected_authorization',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    } else {
        Sympa::Log::Syslog::do_log('err',
            'Unknown action "%s" returned by the scenario "send"', $action);
        Sympa::Report::reject_report_msg(
            'intern', 'Unknown action returned by the scenario "send"',
            $sender, {'msg_id' => $messageid, 'message' => $message},
            $robot, $msg_string,
            $list
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoMessage',
                'parameters'   => $messageid,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'internal',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }
}

############################################################
#  DoCommand
############################################################
#  Handles a command sent to the list manager.
#
# IN : -$message (+) : ref(message object)
#      -$command     : command or ""
#
# OUT : $success
#     | undef
#
##############################################################
sub DoCommand {
    Sympa::Log::Syslog::do_log('debug2', '(%s, %s)', @_);
    my ($message, $command) = @_;

    my $list  = $message->get_list();
    my $robot = $message->get_robot();

    my $msg = $message->as_entity();

    ## boolean
    my $cmd_found = 0;

    ## Now check if the sender is an authorized address.
    my $hdr = $msg->head;

    my $messageid = $message->get_msg_id;
    my ($success, $status);

    my $sender = $message->get_sender_email;

    if ($message->{'spam_status'} and $message->{'spam_status'} eq 'spam') {
        Sympa::Log::Syslog::do_log('notice',
            'Message %s for %s function %s ignored, because tagged as spam',
            $message, ($list || $robot), $command);
        return undef;
    }

    ## Detect loops
    if ($msgid_table{'sympa@' . $robot->name}{$messageid}) {    #FIXME
        Sympa::Log::Syslog::do_log('err',
            'Found known Message-ID, ignoring command which would cause a loop'
        );
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoCommand',
                'parameters'   => $command,                     #FIXME
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'known_message',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }    ## Clean old files from spool

    ## Keep track of known message IDs...if any
    $msgid_table{'sympa@' . $robot->name}{$messageid} = time
        if $messageid;

    ## If recipient is <listname>-<subscribe|unsubscribe> parse as a unique
    ## command
    if ($command) {
        Sympa::Log::Syslog::do_log('info',
            'Processing message %s for %s function %s with priority %s',
            $message, $list, $command, $message->{'priority'});
        my $auth_level;
        $auth_level = 'dkim'
            if $message->{'dkim_pass'};

        # at this point $message->{'dkim_pass'} does not verify that
        # Subject: is part of the signature. It SHOULD !
        Sympa::Commands::parse($sender, $robot,
            sprintf('%s %s', $command, $list->name),
            $auth_level, $message);
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => $list->name,
                'action'       => 'DoCommand',
                'parameters'   => $command,       # FIXME
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'success',
                'error_type'   => '',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return 1;
    }

    Sympa::Log::Syslog::do_log('info',
        'Processing message %s for %s function sympa with priority %s',
        $message, $robot, $message->{'priority'});

    ## Process the Subject of the message
    ## Search and process a command in the Subject field
    my $subject_field = $message->{'decoded_subject'};
    my $re_regexp     = Sympa::Tools::get_regexp('re');
    $subject_field =~ s/^\s*(?:$re_regexp)?\s*(.*)\s*$/$1/i
        if $subject_field;

    my $auth_level = 'dkim' if ($message->{'dkim_pass'});
    $auth_level = $is_signed->{'subject'} if $is_signed->{'subject'};

    if (defined $subject_field and $subject_field =~ /\S/) {
        $success ||=
            Sympa::Commands::parse($sender, $robot, $subject_field, $auth_level,
            $message);
        unless ($success eq 'unknown_cmd') {
            $cmd_found = 1;
        }
    }

    ## Make multipart singlepart
    if ($msg->is_multipart()) {
        my $status = Sympa::Tools::Message::as_singlepart($msg, 'text/plain');

        unless (defined $status) {
            Sympa::Log::Syslog::do_log('err',
                'Could not change multipart to singlepart');
            Sympa::Report::global_report_cmd('user', 'error_content_type', {});
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => '',
                    'action'       => 'DoCommand',
                    'parameters'   => $command,               #FIXME
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'error_content_type',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return undef;
        }

        if ($status) {
            Sympa::Log::Syslog::do_log('debug3',
                'Multipart message changed to singlepart');
        }
    }

    my $i;
    my $size;

    ## Process the body of the message
    ## unless subject contained commands or message has no body
    if (!$cmd_found and defined $msg->bodyhandle) {

        ## check Content-type
        my $mime         = $hdr->get('Mime-Version');
        my $content_type = $msg->effective_type;
        ## Get charset
        my $cset =
            MIME::Charset->new($hdr->mime_attr('Content-Type.Charset'));
        unless ($cset->decoder) {

            # Charset is unknown.  Detect 7-bit charset.
            my ($dummy, $charset) =
                MIME::Charset::body_encode($msg->bodyhandle->as_string(),
                '', Detect7Bit => 'YES');
            $cset = MIME::Charset->new($charset);
        }
        if ($cset->decoder) {
            $cset->encoder('UTF-8');
        } else {
            $cset = MIME::Charset->new('US-ASCII');
        }

        unless (($content_type =~ /^text/i and !$mime)
            or !$content_type
            or $content_type =~ /text\/plain/i) {
            Sympa::Log::Syslog::do_log('err',
                'Ignoring message body not in text/plain, Content-type: %s',
                $content_type);
            Sympa::Report::global_report_cmd('user', 'error_content_type', {});
            Sympa::Log::Database::db_log(
                {   'robot'        => $robot->name,
                    'list'         => '',
                    'action'       => 'DoCommand',
                    'parameters'   => $command,
                    'target_email' => '',
                    'msg_id'       => $messageid,
                    'status'       => 'error',
                    'error_type'   => 'error_content_type',
                    'user_email'   => $sender,
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            return $success;
        }

        my @body = $msg->bodyhandle->as_lines();
        foreach $i (@body) {
            $i = $cset->encode($i);

            last if ($i =~ /^-- $/);    ## ignore signature
            $i =~ s/^\s*>?\s*(.*)\s*$/$1/g;
            next if $i =~ /^$/;         ## skip empty lines
            next if $i =~ /^\s*\#/;

            Sympa::Log::Syslog::do_log('debug3', 'is_signed->body %s',
                $is_signed->{'body'});

            $auth_level = 'dkim' if $message->{'dkim_pass'};
            $auth_level = $is_signed->{'body'} if $is_signed->{'body'};
            $status =
                Sympa::Commands::parse($sender, $robot, $i, $auth_level, $message);

            $cmd_found = 1;    # if problem no_cmd_understood is sent here
            if ($status eq 'unknown_cmd') {
                Sympa::Log::Syslog::do_log('notice',
                    "Unknown command found :%s", $i);
                Sympa::Report::reject_report_cmd('user', 'not_understood', {}, $i);
                Sympa::Log::Database::db_log(
                    {   'robot'        => $robot->name,
                        'list'         => '',
                        'action'       => 'DoCommand',
                        'parameters'   => $i,                 #FIXME
                        'target_email' => '',
                        'msg_id'       => $messageid,
                        'status'       => 'error',
                        'error_type'   => 'not_understood',
                        'user_email'   => $sender,
                        'client'       => $ip,
                        'daemon'       => $daemon_name
                    }
                );
                last;
            }
            if ($i =~ /^(quit|end|stop|-)\s*$/io) {
                last;
            }

            $success ||= $status;
        }
    }

    ## No command found
    unless ($cmd_found) {
        Sympa::Log::Syslog::do_log('info', 'No command found in message %s',
            $message);
        Sympa::Report::global_report_cmd('user', 'no_cmd_found', {});
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot->name,
                'list'         => '',
                'action'       => 'DoCommand',
                'parameters'   => $command,
                'target_email' => '',
                'msg_id'       => $messageid,
                'status'       => 'error',
                'error_type'   => 'no_cmd_found',
                'user_email'   => $sender,
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        );
        return undef;
    }

    return $success;
}

############################################################
#  SendDigest
############################################################
#  Read the queuedigest and send old digests to the subscribers
#  with the digest option.
#
# IN : -
#
# OUT : -
#     | undef
#
##############################################################
sub SendDigest {
    Sympa::Log::Syslog::do_log('debug2', '()');

    my $digestspool = Sympa::Spool::File->new('digest');

    foreach my $digest (
        $digestspool->get_content(
            {'selection' => 'messagekey,list,robot,date'}
        )
        ) {
        my $list = Sympa::List->new($digest->{'list'}, $digest->{'robot'});
        unless ($list) {
            Sympa::Log::Syslog::do_log(
                'info',
                'Unknown list %s, (robot %s), deleting digest (messagekey %s)',
                $digest->{'list'},
                $digest->{'messagekey'}
            );
            Sympa::Log::Database::db_log(
                {   'robot'        => $digest->{'robot'},
                    'list'         => $digest->{'list'},
                    'action'       => 'SendDigest',
                    'parameters'   => "$digest->{'messagekey'}",
                    'target_email' => '',
                    'msg_id'       => '',
                    'status'       => 'error',
                    'error_type'   => 'unknown_list',
                    'user_email'   => '',
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            $digestspool->remove_message(
                {'messagekey' => $digest->{'messagekey'}});
            next;
        }

        Sympa::Language::SetLang($list->lang);

        if ($list->get_nextdigest($digest->{'date'})) {
            ## Blindly send the message to all users.
            Sympa::Log::Syslog::do_log('info', 'Sending digest to list %s',
                $list);
            my $start_time = time;
            $list->send_msg_digest($digest->{'messagekey'});

            Sympa::Log::Syslog::do_log('info',
                'Digest of the list %s sent (%d seconds)',
                $list, time - $start_time);
            Sympa::Log::Database::db_log(
                {   'robot'        => $list->{'robot'},
                    'list'         => $list->name,
                    'action'       => 'SendDigest',
                    'parameters'   => "",
                    'target_email' => '',
                    'msg_id'       => '',
                    'status'       => 'success',
                    'error_type'   => '',
                    'user_email'   => '',
                    'client'       => $ip,
                    'daemon'       => $daemon_name
                }
            );
            $digestspool->remove_message(
                {'messagekey' => $digest->{'messagekey'}});
        }
    }
}

## Cleanup the msgid_table every 'msgid_table_cleanup_frequency' sec
## Removes all entries older than 'msgid_table_cleanup_ttl' sec
sub clean_msgid_table {

    foreach my $rcpt (keys %msgid_table) {
        foreach my $msgid (keys %{$msgid_table{$rcpt}}) {
            if (time >
                $msgid_table{$rcpt}{$msgid} + Sympa::Site->msgid_table_cleanup_ttl) {
                delete $msgid_table{$rcpt}{$msgid};
            }
        }
    }

    return 1;
}

## END of sympa.pl
