#! --PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997-1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997-2011 Comite Reseau des Universites
# Copyright (c) 2011-2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=encoding utf-8

=head1 NAME

task_manager, task_manager.pl - Daemon executing background tasks

=head1 SYNOPSIS

B<task_manager.pl>
    S<[ B<-d, --debug> ]>
    S<[ B<-F, --foreground> ]>
    S<[ B<--log-level>=I<level> ]>

B<task_manager.pl> B<-h, --help>

=head1 DESCRIPTION

B<task_manager.pl> is a daemon scanning the B<task> spool content, and
executing tasks.

=head1 OPTIONS

=over 4

=item B<-d>, B<--debug>

Run in debug mode.

=item B<-F>, B<--foreground>

Do not detach from TTY.

=item B<-h>, B<--help>

Prints this help message.

=item B<--log_level=>I<level>

Set log level.

=back

=head1 FILES

F<--spooldir--/task/> directory for task spool.

F<--piddir--/task_manager.pid> this file contains the process ID
of F<task_manager.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<wwsympa(8)>

=cut

use strict;
use warnings;
use lib '--modulesdir--';

use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;

use Sympa::Conf;
use Sympa::Constants;
use Sympa::List;
use Sympa::Log::Syslog;
use Sympa::Mailer;
use Sympa::Site;
use Sympa::Spool::File::Task;
use Sympa::Task;
use Sympa::Tools::Daemon;
use Sympa::Tools::Time;

my $daemon_name = 'task_manager';

my %options;
unless (
    GetOptions(
        \%options,
        'debug|d',
        'foreground|F',
        'help|h',
        'log_level=s',
    )) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($options{'help'}) {
    pod2usage(0);
}

if ($options{'debug'}) {
    $options{'log_level'} = 2 unless ($options{'log_level'});
    $options{'foreground'} = 1;
}

$options{'log_to_stderr'} = 1 if $options{'foreground'};

# Load sympa.conf
unless (Sympa::Robot::get_robots()) {
    printf STDERR
        "Unable to load Sympa configuration, file %s or any of the virtual host robot.conf files contain errors. Exiting.\n",
        Sympa::Conf::get_sympa_conf();
    exit 1;
}

Sympa::Log::Syslog::do_openlog(Sympa::Site->log_facility, $daemon_name);

# setting log_level using conf unless it is set by calling option
if ($options{'log_level'}) {
    Sympa::Log::Syslog::set_log_level($options{'log_level'});
    Sympa::Log::Syslog::do_log(
        Sympa::Log::Syslog::INFO,
        'Configuration file read, log level set using options : %s',
        $options{'log_level'}
    );
} else {
    Sympa::Log::Syslog::set_log_level(Sympa::Site->log_level);
    Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::INFO,
        'Configuration file read, default log level %s',
        Sympa::Site->log_level);
}

# put ourselves in background if not in debug mode.
Sympa::Tools::Daemon::daemonize(name => $daemon_name)
    unless $options{'foreground'};

# check presence of a PID file from a previous execution
Sympa::Tools::Daemon::check_old_pid_file(
    name   => $daemon_name,
    piddir => Sympa::Constants::PIDDIR,
    tmpdir => Sympa::Site->tmpdir(),
);

# Create the PID file
Sympa::Tools::Daemon::write_pid(
    name   => $daemon_name,
    pid    => $PID,
    piddir => Sympa::Constants::PIDDIR,
    user   => Sympa::Constants::USER,
    group  => Sympa::Constants::GROUP,
);

# Redirect STDERR to a file, unless the process is running in foreground
unless ($options{'foreground'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(
        pid    => $PID,
        tmpdir => Sympa::Site->tmpdir(),
        user   => Sympa::Constants::USER,
        group  => Sympa::Constants::GROUP,
    );
}

eval {
    Sympa::Tools::Daemon::drop_privileges(
        user  => Sympa::Constants::USER,
        group => Sympa::Constants::GROUP
    );
};
Sympa::Log::Syslog::fatal_err($EVAL_ERROR) if $EVAL_ERROR;

## Sets the UMASK
umask(oct(Sympa::Site->umask));

## Change to list root
unless (chdir(Sympa::Site->home)) {
    Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::ERR,
        'error : unable to change to directory %s', Sympa::Site->home);
    exit(-1);
}

my $spool = Sympa::Spool::File::Task->new();

## Catch SIGTERM, in order to exit cleanly, whenever possible.
my $end = 0;
$SIG{'TERM'} = sub { $end = 1 };

# Catch fatal errors, to generate traceback.
$SIG{'__DIE__'} = sub {
    return if $^S;    # invoked from inside eval.

    my $msg = $_[0];
    chomp $msg;
    Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::ERR, 'DIED: %s', $msg);
    eval { Sympa::Site->send_notify_to_listmaster(undef, undef, undef, 1); };
    eval { Sympa::DatabaseManager::db_disconnect(); };    # unlock database
    Sympa::Log::Syslog::closelog();           # flush log

    ## gather traceback information
    my @calls;
    my @f;
    $_[0] =~ /.+ at (.+? line \d+\.)\n$/s;
    @calls = ($1) if $1;
    for (my $i = 1; @f = caller($i); $i++) {
        $calls[0] = "In $f[3] at $calls[0]" if @calls;
        unshift @calls, "$f[1] line $f[2].";
    }
    $calls[0] = "In (top-level) at $calls[0]";

    print STDERR join "\n", "DIED: $msg", @calls;
    print STDERR "\n";
    exit 255;
};

###### VARIABLES DECLARATION ######
our $mailer = Sympa::Mailer->new(
    db_type         => Sympa::Site->db_type(),
    nrcpt_by_domain => Sympa::Site->nrcpt_by_domain(),
);

###### INFINITE LOOP SCANING THE SPOOL (unless a sig TERM is received) ######
while (!$end) {
    my $current_date = time;                           # current epoch date
    my $rep          = Sympa::Tools::Time::adate($current_date);

    ## Empty cache of the List.pm module
    Sympa::List::init_list_cache();

    # Process grouped notifications
    Sympa::Site->send_notify_to_listmaster(undef, undef, 1, undef);

    $spool->create_required_tasks($current_date);

    ## Execute existing tasks
    ## processing of tasks anterior to the current date
    Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::DEBUG2,
        'Processing tasks anterior to the current date');
    foreach my $task ($spool->get_content) {
        last if $end;
        next unless $task->{'date'} <= $current_date;

        # Check that a task is still legitimate before executing it, as tasks
        # for list whose parameters have been changed may not be valid anymore,
        # such as synchronisation without datasources
        my $validity = $task->check_validity();

        if ($validity) {
            Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::DEBUG2, 'Processing task %s', $task);

            eval {
                $task->execute();
            };
            if ($EVAL_ERROR) {
                my $data = {
                    'task'       => $task,
                    'human_date' => Sympa::Tools::Time::adate($task->{'date'}),
                };
                if ($task->isa('Sympa::Task::List')) {
                    $data->{'list'} = $task->{'list'};
                }
                Sympa::Log::Syslog::do_log(
                    Sympa::Log::Syslog::ERR,
                    'Execution of task %s failed, sending detailed report to listmaster',
                    $task->get_description()
                );
                Sympa::Site->send_notify_to_listmaster('task_error', $data);
            } else {
                Sympa::Log::Syslog::do_log(
                    Sympa::Log::Syslog::NOTICE,
                    'Execution of task %s suceeded',
                    $task->get_description,
                );
            }
        }

        my $result = $spool->remove_message($task->{'messagekey'});
        unless ($result) {
            Sympa::Log::Syslog::do_log(
                Sympa::Log::Syslog::ERR,
                'Unable to remove task (messagekey = %s)',
                $task->{'messagekey'}
            );
        }
    }
    sleep 30;
    ## Free zombie sendmail processes
    $mailer->reaper();
}

# Purge grouped notifications
Sympa::Site->send_notify_to_listmaster(undef, undef, undef, 1);

Sympa::Log::Syslog::do_log(Sympa::Log::Syslog::NOTICE,
    'task_manager exited normally due to signal');

Sympa::Tools::Daemon::remove_pid(
    name   => $daemon_name,
    pid    => $PID,
    piddir => Sympa::Constants::PIDDIR,
    tmpdir => Sympa::Site->tmpdir(),
);

exit(0);
