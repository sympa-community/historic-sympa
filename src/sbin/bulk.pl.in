#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;
use POSIX qw();

use Sympa::Alarm;
use Sympa::Bulk;
use Conf;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Sympa::List;
use Log;
use Sympa::Mail;
use Sympa::Message;
use Sympa::Robot;
use SDM;
use tools;
use Sympa::Tools::Daemon;
use Sympa::Tools::Data;
use Sympa::Tools::DKIM;
use Sympa::Tracking;

my $daemon_name           = Log::set_daemon($0);
my $date_of_last_activity = time();
local $main::daemon_usage =
    'DAEMON_MASTER';    ## Default is to launch bulk as master daemon.

## Check options
##  --debug : sets the debug mode
##  --foreground : prevents the script from beeing daemonized
##  --mail : logs every sendmail calls
my %options;
unless (
    GetOptions(
        \%main::options, 'config|f=s',  'debug|d', 'foreground|F',
        'help|h',        'log_level=s', 'mail|m',  'version|v',
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1
    if ($main::options{'debug'} || $main::options{'foreground'});

# Load sympa.conf
unless (Conf::load()) {
    printf STDERR
        "Unable to load Sympa configuration, file %s or one of the virtual host robot.conf files contain errors. Exiting.\n",
        Conf::get_sympa_conf();
    exit 1;
}

Log::do_openlog($Conf::Conf{'syslog'}, $Conf::Conf{'log_socket_type'},
    'bulk');

# Enable SMTP logging if required
my $default_log_smtp = $main::options{'mail'}
    || Sympa::Tools::Data::smart_eq($Conf::Conf{'log_smtp'}, 'on');
$Sympa::Mail::log_smtp = $default_log_smtp;

# setting log_level using conf unless it is set by calling option
my $default_log_level;
if ($main::options{'log_level'}) {
    $default_log_level = $main::options{'log_level'};
    Log::set_log_level($default_log_level);
    Log::do_log(
        'info',
        'Configuration file read, log level set using options: %s',
        $main::options{'log_level'}
    );
} else {
    $default_log_level = $Conf::Conf{'log_level'};
    Log::set_log_level($default_log_level);
    Log::do_log(
        'info',
        'Configuration file read, default log level %s',
        $Conf::Conf{'log_level'}
    );
}

## Set the process as main bulk daemon by default.
my $is_main_bulk = 0;

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        close(TTY);
    }
    setpgrp(0, 0);
    if ((my $child_pid = fork) != 0) {
        Log::do_log('info', 'Starting bulk master daemon, PID %s',
            $child_pid);
        exit(0);
    }
}
Log::do_openlog($Conf::Conf{'syslog'}, $Conf::Conf{'log_socket_type'},
    'bulk');
## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
$options->{'multiple_process'} = 0;

# Save the PID number
Sympa::Tools::Daemon::write_pid('bulk', $PID, $options);
unless ($options->{'stderr_to_tty'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(('pid' => $PID));
}
## Set the User ID & Group ID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    Log::fatal_err(
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo."
    );
}

## Sets the UMASK
umask(oct($Conf::Conf{'umask'}));

## Change to list root
unless (chdir($Conf::Conf{'home'})) {
    die sprintf 'Can\'t chdir to %s: %s', $Conf::Conf{'home'}, $!;
}

Log::do_log('notice', 'Bulk %s Started', Sympa::Constants::VERSION);

## Catch signals, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'INT'}  = \&sigterm;
my $end = 0;

my $opensmtp = 0;
my $fh       = 'fh0000000000';    ## File handle for the stream.

my $message;
my $messagekey;    # the key of the current message in the message_table

my $timeout         = $Conf::Conf{'bulk_wait_to_fork'};
my $last_check_date = 0;
my %created_children;

$options->{'multiple_process'} = 1;
#FIXME: Overwriting configuration on memory.
$Conf::Conf{'maxsmtp'} =
    int($Conf::Conf{'maxsmtp'} / $Conf::Conf{'bulk_max_count'});

while (!$end) {
    # Enable SMTP logging if required.
    $Sympa::Mail::log_smtp = $default_log_smtp;
    # setting log_level using conf unless it is set by calling option
    Log::set_log_level($default_log_level);

    Sympa::List::init_list_cache();
    # Process grouped notifications
    Sympa::Alarm::flush();

    my $bulk;

    unless ($main::options{'foreground'}) {
        ##
        ## Create child bulks if too much packets are waiting to be sent in
        ## the bulk_mailer table.
        ## Only the main bulk process (DAEMON_MASTER) can create child
        ## processes
        ## Check if we need to run new child processes every
        ## 'bulk_wait_to_fork' (sympa.conf parameter) seconds
        if (   ($main::daemon_usage eq 'DAEMON_MASTER')
            && (time() - $last_check_date > $timeout)) {
            ## Clean up PID file (in case some child bulks would have died)
            my @actual_children =
                Sympa::Tools::Daemon::get_children_processes_list();
            my @remaining_children;
            my %dead_children = %created_children;
            foreach my $apid (@actual_children) {
                if (defined $dead_children{$apid}) {
                    push @remaining_children, $apid;
                    delete $dead_children{$apid};
                }
            }
            my @pids_leftover = keys %dead_children;
            if ($#pids_leftover > -1) {
                my @dc;
                Log::do_log('debug2',
                    'Some childs of current process disappeared. Checking whether they shut down cleanly or not.'
                );
                my $pids_in_pfile =
                    Sympa::Tools::Daemon::get_pids_in_pid_file('bulk');
                foreach my $fpid (@{$pids_in_pfile}) {
                    if (defined $dead_children{$fpid}) {
                        Log::do_log(
                            'err',
                            'The %s child exists in the PID file but is no longer running. Removing it and notyfying listmaster',
                            $fpid
                        );
                        my $pname = $0;
                        $pname =~ s/.*\/(\w+)/$1/;
                        Sympa::Tools::Daemon::send_crash_report(
                            ('pid' => $fpid, 'pname' => $pname));
                        Sympa::Tools::Daemon::remove_pid('bulk', $fpid,
                            $options);
                        delete $dead_children{$fpid};
                        push @dc, $fpid;
                    }
                }
            }
            my $pids_in_pfile =
                Sympa::Tools::Daemon::get_pids_in_pid_file('bulk');
            unless (defined($pids_in_pfile)) {
                Sympa::Tools::Daemon::write_pid('bulk', $PID, $options);
                close STDERR;
                Sympa::Tools::Daemon::direct_stderr_to_file(('pid' => $PID));
                $pids_in_pfile = [$PID];
            }
            ## Start new processes if there remain at least
            ## 'bulk_fork_threshold' packets to send in the bulkmailer_table
            ## table
            if (my $r_packets =
                Sympa::Bulk::there_is_too_much_remaining_packets()
                and $#remaining_children + 1 < $Conf::Conf{'bulk_max_count'})
            {

                ## disconnect from database before fork
                ## to prevent DB handlers to be shared by different processes
                # when loading conf in database disconnect because of sharing
                # database handler may crash bulk.pl
                SDM::db_disconnect();

                if ($Conf::Conf{'bulk_max_count'} > 1) {
                    Log::do_log(
                        'info',
                        'Important workload: %s packets to process. Creating %s child bulks to increase sending rate',
                        $r_packets,
                        $Conf::Conf{'bulk_max_count'} -
                            ($#remaining_children + 1)
                    );
                    for my $process_count (
                        1 .. $Conf::Conf{'bulk_max_count'} -
                        ($#remaining_children + 1)) {
                        Log::do_log('info', "Will fork: %s", $process_count);
                        if ((my $child_pid = fork) != 0) {
                            Log::do_log('info',
                                'Starting bulk child daemon, PID %s',
                                $child_pid);
                            # Saves the pid number
                            Sympa::Tools::Daemon::write_pid('bulk',
                                $child_pid, $options);
                            $created_children{$child_pid} = 1;
                            sleep 1;
                        } else {
                            ## We're in a child bulk process
                            close STDERR;
                            Sympa::Tools::Daemon::direct_stderr_to_file(
                                ('pid' => $PID));
                            $date_of_last_activity = time();
                            $main::daemon_usage =
                                'DAEMON_SLAVE';    # automatic lists creation
                            Log::do_openlog($Conf::Conf{'syslog'},
                                $Conf::Conf{'log_socket_type'}, 'bulk');
                            Log::do_log('info',
                                'Bulk slave daemon started with PID %s',
                                $PID);
                            last;
                        }
                    }
                }
            }
            $last_check_date = time();
        }
    }
    ## If a child bulk process is running for long enough, stop it (if the
    ## number of remaining packets to send is reasonnable).
    if (    $main::daemon_usage eq 'DAEMON_SLAVE'
        and time() - $date_of_last_activity > $Conf::Conf{'bulk_lazytime'}
        and
        !(my $r_packets = Sympa::Bulk::there_is_too_much_remaining_packets()))
    {
        Log::do_log('info',
            'Process %s didn\'t send any message since %s seconds, exiting',
            $PID, $Conf::Conf{'bulk_lazytime'});
        last;
    }

    ## Go through the bulk_mailer table and process messages
    if ($bulk = Sympa::Bulk::next()) {
        # Get list/robot context.
        # NOTE: The robot that injected packet can no longer be available.
        # In such case fallback to site-wide robot.
        my $listname = $bulk->{'listname'};
        my $robot    = $bulk->{'robot'};
        my $list;
        $robot = $Conf::Conf{'domain'}
            unless $robot
                and $robot ne '*'
                and Conf::valid_robot($robot);
        $list = Sympa::List->new($listname, $robot, {'just_try' => 1})
            if defined $listname and length $listname;

        if (!defined $messagekey or $bulk->{'messagekey'} ne $messagekey) {
            # current packet is not related to the same message as the
            # previous packet
            # so it is needed to fetch the new message from message_table

            $messagekey = $bulk->{'messagekey'};
            my $msg_string =
                Sympa::Bulk::fetch_content($bulk->{'messagekey'});
            $message = Sympa::Message->new(
                $msg_string,
                context => ($list || $robot || '*'),
                %$bulk
            );
            unless ($message) {
                Log::do_log(
                    'err',
                    'Current packet (messagekey=%s) contains broken message',
                    $messagekey
                );
                Sympa::Bulk::remove($messagekey, $bulk->{'packetid'})
                    or Log::do_log(
                    'err',
                    'Failed to remove processed packet "%s", messagekey "%s"',
                    $messagekey,
                    $bulk->{'packetid'}
                    );
            }

            Log::do_log(
                'notice',
                'Start sending message %s to %s (priority %s) (starting %s seconds after scheduled expedition date)',
                $message,
                $message->{context},
                $message->{'priority'},
                time() - $message->{'date'}
            );
            # trace_smime($message, 'init');
            $messagekey = $bulk->{'messagekey'};
        }

        # Enable SMTP logging if required.
        $Sympa::Mail::log_smtp = $main::options{'mail'}
            || Sympa::Tools::Data::smart_eq(
            Conf::get_robot_conf($robot, 'log_smtp'), 'on');
        # setting log_level using conf unless it is set by calling option
        Log::set_log_level(
            (defined $main::options{'log_level'})
            ? $main::options{'log_level'}
            : Conf::get_robot_conf($robot, 'log_level')
        );

        #HASH which will contain the attributes of the subscriber
        my $data;
        # Initialization of the HASH $data. It will be used by parse_tt2 to
        # personalized messages.
        # Note that message ID which can be anonymized should be taken from
        # message header instead of {message_id} attribute.
        my $msg_id = tools::clean_msg_id($message->get_header('Message-ID'));
        $data = {
            'messageid' => $msg_id,
            'listname'  => $listname,
            'robot'     => $robot,
            #XXX'to'        => $bulk->{'recipients'}, #XXX Insecure
            'wwsympa_url' => Conf::get_robot_conf($robot, 'wwsympa_url'),
        };

        # It is the email of a subscriber, use it in the foreach
        my $rcpt;
        # Contain all the subscribers
        my @rcpts = split /,/, $bulk->{'recipients'};
        ## Use an intermediate handler to encode to filesystem_encoding
        my $user;

        # message transformation must be done in the folowing order
        #  -1 headers modifications (done in sympa.pl)
        #  -2 personalize (a.k.a. "merge")
        #  -3 smime sign
        #  -4 smime encrypt
        #  -5 remove existing signature if altered
        #  -6 dkim sign

        my $dkim;
        if ($message->{shelved}{dkim_sign}) {
            $dkim =
                Sympa::Tools::DKIM::get_dkim_parameters($message->{context});
        }

        if (   $message->{shelved}{merge}
            or $message->{shelved}{smime_encrypt}
            or $message->{shelved}{tracking}) {
            # message needs personalization
            my $key;

            foreach $rcpt (@rcpts) {
                my $new_message = $message->dup;

                my $notification_id;
                my $return_path;

                if (Sympa::Tools::Data::smart_eq(
                        $new_message->{shelved}{tracking}, qr/dsn|mdn/
                    )
                    ) {
                    # tracking by MDN required tracking by DSN to
                    my $msgid = $new_message->{'message_id'};
                    $notification_id =
                        Sympa::Tracking::find_notification_id_by_message(
                        $rcpt, $msgid, $listname, $robot);
                    $return_path =
                        $list->get_bounce_address($rcpt, $notification_id);
                    $new_message->replace_header(
                        'Disposition-Notification-To', $return_path)
                        if $new_message->{shelved}{tracking} =~ /mdn/;
                    # trace_smime($new_message, 'tracking');
                } elsif (
                    Sympa::Tools::Data::smart_eq(
                        $new_message->{shelved}{tracking}, 'w'
                    )
                    ) {
                    $return_path = $list->get_bounce_address($rcpt, 'w');
                } elsif (
                    Sympa::Tools::Data::smart_eq(
                        $new_message->{shelved}{tracking}, 'r'
                    )
                    ) {
                    $return_path = $list->get_bounce_address($rcpt, 'r');
                } elsif ($new_message->{shelved}{tracking}) {    # simple VERP
                    $return_path = $list->get_bounce_address($rcpt);
                } elsif ($new_message->{envelope_sender}) {
                    $return_path = $new_message->{envelope_sender};
                } elsif ($list) {
                    $return_path = $list->get_list_address('return_path');
                } else {
                    $return_path = Conf::get_robot_conf($robot, 'request');
                }

                if ($new_message->{shelved}{merge}) {
                    unless ($new_message->personalize($list, $rcpt)) {
                        #FIXME: Mark packet as "bad".
                        Log::do_log('err', 'Erreur d appel personalize()');
                        tools::send_notify_to_listmaster($list, 'bulk_failed',
                            {'message_id' => $message->get_id});

                        last;    # foreach $rcpt
                    }
                    delete $new_message->{shelved}{merge};
                }

                if ($new_message->{shelved}{smime_sign}) {
                    $new_message->smime_sign;
                    delete $new_message->{shelved}{smime_sign};
                }

                if ($new_message->{shelved}{smime_encrypt}) {
                    unless ($new_message->smime_encrypt($rcpt)) {
                        #FIXME: Mark packet as "bad".
                        Log::do_log(
                            'err',
                            'Unable to encrypt message %s from %s for recipient %s',
                            $new_message,
                            $list,
                            $rcpt
                        );

                        last;    # foreach $rcpt
                    }
                    delete $new_message->{shelved}{smime_encrypt};
                }

                if (Conf::get_robot_conf($robot, 'dkim_feature') eq 'on') {
                    $new_message->remove_invalid_dkim_signature;
                }
                if ($new_message->{shelved}{dkim_sign} and $dkim) {
                    # apply dkim signature AFTER any other message
                    # transformation.
                    $new_message->dkim_sign(
                        'dkim_d'          => $dkim->{'d'},
                        'dkim_i'          => $dkim->{'i'},
                        'dkim_selector'   => $dkim->{'selector'},
                        'dkim_privatekey' => $dkim->{'private_key'},
                    );
                    delete $new_message->{shelved}{dkim_sign};
                }

                # trace_smime($new_message, 'dkim');

                *SMTP = Sympa::Mail::smtpto($return_path, \$rcpt, $robot,
                    $notification_id);
                # Message with customized data, stripped Return-Path:.
                my $msg_string = $new_message->as_string;
                $msg_string =~ s/\AReturn-Path: (.*?)\n(?![ \t])//s;
                print SMTP $msg_string;
                close SMTP;
            }
        } else {
            # message doesn't need personalization, so can be sent by packet.
            my $new_message = $message->dup;

            my $return_path;

            if ($new_message->{envelope_sender}) {
                $return_path = $new_message->{envelope_sender};
            } elsif ($list) {
                $return_path = $list->get_list_address('return_path');
            } else {
                $return_path = Conf::get_robot_conf($robot, 'request');
            }

            if ($new_message->{shelved}{smime_sign}) {
                $new_message->smime_sign;
                delete $new_message->{shelved}{smime_sign};
            }

            if (Conf::get_robot_conf($robot, 'dkim_feature') eq 'on') {
                $new_message->remove_invalid_dkim_signature;
            }
            # Initial message
            if ($new_message->{shelved}{dkim_sign} and $dkim) {
                $new_message->dkim_sign(
                    'dkim_d'          => $dkim->{'d'},
                    'dkim_i'          => $dkim->{'i'},
                    'dkim_selector'   => $dkim->{'selector'},
                    'dkim_privatekey' => $dkim->{'private_key'},
                );
                delete $new_message->{shelved}{dkim_sign};
            }

            # trace_smime($new_message,'dkim 2');

            *SMTP = Sympa::Mail::smtpto($return_path, \@rcpts, $robot);
            # Stripping Return-Path: pseudo-header field.
            my $msg_string = $new_message->as_string;
            $msg_string =~ s/\AReturn-Path: (.*?)\n(?![ \t])//s;
            print SMTP $msg_string;
            close SMTP;
        }

        ## Remove packet once it has been processed
        unless (
            Sympa::Bulk::remove($bulk->{'messagekey'}, $bulk->{'packetid'})) {
            Log::do_log('err',
                'Failed to remove processed packet "%s", messagekey "%s"',
                $bulk->{'messagekey'}, $bulk->{'packetid'});
        }

        if ($bulk->{'priority_packet'} ==
            Conf::get_robot_conf($robot, 'sympa_packet_priority') + 5) {
            Log::do_log(
                'notice',
                'Done sending message %s to %s (priority %s) in %s seconds since scheduled expedition date',
                $message,
                ($list || $robot),
                $message->{'priority'},
                time() - $message->{'date'}
            );
        }
        $date_of_last_activity = time();
    } else {
        ## Sleep for a while if bulk_mailer DB table is empty
        sleep $Conf::Conf{'bulk_sleep'};
    }
    Sympa::Mail::reaper();
}

# Purge grouped notifications
Sympa::Alarm::flush('purge');

Log::do_log('notice', 'Bulk.pl exited normally due to signal');
Sympa::Tools::Daemon::remove_pid('bulk', $PID, $options);

exit(0);

## When we catch signal, just change the value of the loop
## variable.
sub sigterm {
    my ($sig) = @_;
    Log::do_log('notice', 'Signal %s received, still processing current task',
        $sig);
    $end = 1;
}

sub trace_smime {
    my $message = shift;
    my $where   = shift;

    my $result = $message->check_smime_signature;
    return if defined $result and $result == 0;

    unless ($result) {
        Log::do_log('debug', 'Signature S/MIME NOT OK (%s)', $where);
    } else {
        Log::do_log('debug', 'Signature S/MIME OK (%s)', $where);
    }
}

__END__

=encoding utf-8

=head1 NAME 

bulk, bulk.pl - Daemon for Submitting Bulk Content to SMTP Engine

=head1 SYNOPSIS

S<B<bulk.pl> [ B<--foreground> ] [ B<--debug> ]>

=head1 DESCRIPTION 

This daemon must be run along with Sympa.  It regularly checks the
C<bulkpacket_table> content and submit the messages it finds in it to the
sendmail engine.  Several daemon should be used on deferent server for huge
traffic.

=head1 OPTIONS

=over 4

=item B<-d>, B<--debug>

Sets the debug mode

=item B<-F>, B<--foreground>

Prevents the script from being daemonized

=item B<-h>, B<--help>

Prints this help message.

=item B<--log_level=>I<level>

Set log level.

=item B<-m>, B<--mail>

Logs every sendmail calls.

=back

=head1 FILES

F<--piddir--/bulk.pid> this file contains the process IDs
of F<bulk.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<sendmail(8)>

=cut
