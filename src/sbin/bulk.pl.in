#!--PERL--
# -*- indent-tabs-mode: t; -*-
# vim:ft=perl:et:sw=4:textwidth=78
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=encoding utf-8

=head1 NAME

bulk.pl - Daemon for Submitting Bulk Content to SMTP Engine

=head1 SYNOPSIS

S<B<bulk.pl> [ B<--foreground> ] [ B<--mail> ] [ B<--debug> ]>

=head1 DESCRIPTION

This daemon regulary submit messages found in the database to an SMTP server.
Multiple instances can be run simultaneously to distribute traffic.

=head1 OPTIONS

=over

=item B<-d>, B<--debug>

Set debug mode (implies -F)

=item B<-F>, B<--foreground>

Do not detach TTY

=item B<-m>, B<--mail>

Log every sendmail command invocation.

=item B<-h>, B<--help>

Print this help and exit.

=back

=head1 FILES

F<--piddir--/bulk.pid> this file contains the process IDs of F<bulk.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be found in L<http://www.sympa.org/manual/>.
	
The mailing lists (with web archives) can be accessed at L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<sendmail(8)>

=cut

use strict;
use lib '--modulesdir--';
use warnings;

use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;

use Sympa::Bulk;
use Sympa::Configuration;
use Sympa::Constants;
use Sympa::Database;
use Sympa::List;
use Sympa::Log::Syslog;
use Sympa::Mail;
use Sympa::Message;
use Sympa::Spool::SQL;
use Sympa::Tools;
use Sympa::Tools::Daemon;
use Sympa::Tracking;

my $daemon_name = Sympa::Tools::Daemon::get_daemon_name();
my $date_of_last_activity = time();
local $main::daemon_usage = 'DAEMON_MASTER'; ## Default is to launch bulk as master daemon.

my %options;
GetOptions(
	\%options,
	'debug|d',
	'foreground|F',
	'mail|m',
	'help|h',
) or pod2usage(-verbose => 0);

pod2usage(-verbose => 0, -exitstatus => 0) if $options{help};

if ($options{'debug'}) {
	$options{'log_level'} = 2 unless ($options{'log_level'});
}

$options{'foreground'} = 1 if ($options{'debug'});
$options{'log_to_stderr'} = 1 if ($options{'debug'} || $options{'foreground'});

if ($main::options{'help'}) {
    pod2usage(0);
}

# Load sympa.conf
unless (Robot::get_robots()) {
	Sympa::Log::Syslog::fatal_err("Unable to load sympa configuration, file %s or one of the vhost robot.conf files contain errors. Exiting.", Conf::get_sympa_conf());
}

# connect to database
my $db_conf = Sympa::Configuration::get_parameters_group(
	'*','Database related'
);

my $base = Sympa::Database->create(%$db_conf);
unless ($base) {
	Sympa::Log::Syslog::fatal_err(
		'Unable to create database defined in configuration. Exiting.'
	);
}

my $result = $base->connect();
unless ($result) {
	Sympa::Log::Syslog::fatal_err(
		'Unable to connect to database defined in configuration. Exiting.'
	);
}

# Check that the data structure is uptodate
unless (Sympa::Configuration::check_data_structure(Sympa::Constants::VERSION)) {
	Sympa::Log::Syslog::fatal_err("error : data structure was not updated ; you should run sympa.pl to run the upgrade process.");
}

# Check for several files.
unless (Sympa::Configuration::checkfiles()) {
	Sympa::Log::Syslog::fatal_err("Missing files. Aborting.");
}

Sympa::Log::Syslog::do_openlog(Sympa::Site->syslog, Sympa::Site->log_socket_type, 'bulk');

# setting log_level using conf unless it is set by calling option
if ($options{'log_level'}) {
	Sympa::Log::Syslog::set_log_level($options{'log_level'});
	Sympa::Log::Syslog::do_log('info', "Configuration file read, log level set using options : $options{'log_level'}");
} else {
	Sympa::Log::Syslog::set_log_level(Sympa::Site->log_level);
	Sympa::Log::Syslog::do_log('info', "Configuration file read, default log level Sympa::Site->log_level");
}

## Set the process as main bulk daemon by default.
my $is_main_bulk = 0;

## Put ourselves in background if not in debug mode.
unless ($options{'debug'} || $options{'foreground'}) {
	open(STDERR, ">> /dev/null");
	open(STDOUT, ">> /dev/null");
	if (open(TTY, "/dev/tty")) {
		close(TTY);
	}
	setpgrp(0, 0);
	if ((my $child_pid = fork) != 0) {
		Sympa::Log::Syslog::do_log('info',"Starting bulk master daemon, pid %s",$child_pid);
		exit(0);
	}
}
Sympa::Log::Syslog::do_openlog(Sympa::Site->syslog, Sympa::Site->log_socket_type, 'bulk');

# Saves the pid number
my $result = Sympa::Tools::Daemon::write_pid(
	directory => Sympa::Constants::PIDDIR,
	pid       => $PID,
	method    => Sympa::Site->lock_method,
	user      => Sympa::Constants::USER,
	group     => Sympa::Constants::GROUP,
);
unless ($result) {
	Sympa::Log::Syslog::fatal_err('Error while writing pid file, exiting');
}
# If process is running in foreground, don't write STDERR to a dedicated file
unless ($options{foreground}) {
	Sympa::Tools::Daemon::direct_stderr_to_file(
		directory => Sympa::Constants::PIDDIR,
		pid       => $PID,
		user      => Sympa::Constants::USER,
		group     => Sympa::Constants::GROUP,
	);
}
## Set the UserID & GroupID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2]) && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
	Sympa::Log::Syslog::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct(Sympa::Site->umask));

## Change to list root
unless (chdir(Sympa::Site->home)) {
	Sympa::Log::Syslog::do_log('err','unable to change directory');
	exit (-1);
}

my $pinfo = Sympa::List::_apply_defaults();

Sympa::Log::Syslog::do_log('notice', "bulk.pl %s Started", Sympa::Constants::VERSION);


## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $opensmtp = 0;
my $fh = 'fh0000000000';	## File handle for the stream.

my $messagekey;       # the key of the current message in the message_table
my $messageasstring_init;  # the current message as a string
my $messageasstring;  # the transformed message.

my $timeout = Sympa::Site->bulk_wait_to_fork;
my $last_check_date = 0;
my %created_children;

Sympa::Site->maxsmtp = int(Sympa::Site->maxsmtp/Sympa::Site->bulk_max_count);


my $spool = Sympa::Spool::SQL->new(
	name => 'bulk',
	base => $base
);

my $bulk = Sympa::Bulk->new(
	base => $base
);

while (!$end) {
	Sympa::List::init_list_cache();
	Sympa::List::send_notify_to_listmaster(undef, undef, undef, 1); # Process grouped notifications

	my $message_from_spool;

	unless ($options{'foreground'}) {
		# Create child bulks if too much packets are waiting to be
		# sent in the bulk_mailer table.
		# Only the main bulk process (DAEMON_MASTER) can create child
		# processes
		# Check if we need to run new child processes every
		# 'bulk_wait_to_fork' (sympa.conf parameter) seconds
		if (($main::daemon_usage eq 'DAEMON_MASTER') && (time() - $last_check_date > $timeout)){
			## Clean up pid file (in case some child bulks would have died)
			my @actual_children = Sympa::Tools::Daemon::get_children_processes_list();
			my @remaining_children;
			my %dead_children = %created_children;
			foreach my $apid (@actual_children) {
				if (defined $dead_children{$apid}) {
					push @remaining_children, $apid;
					delete $dead_children{$apid};
				}
			}
			my @pids_leftover = keys %dead_children;
			if ($#pids_leftover > -1) {
				my @dc;
				Sympa::Log::Syslog::do_log('debug2','Some childs of current process disappeared. Checking whether they shut down cleanly or not.');
				my $pids_in_pfile = Sympa::Tools::Daemon::read_pids(
					directory => Sympa::Constants::PIDDIR,
					daemon    => $daemon_name
				);
				foreach my $fpid (@{$pids_in_pfile}) {
					if (defined $dead_children{$fpid}) {
						Sympa::Log::Syslog::do_log('err','The %s child exists in the pid file but is no longer running. Removing it and notyfying listmaster.',$fpid);
						Sympa::Tools::Daemon::send_crash_report(
							directory => Sympa::Constants::PIDDIR,
							daemon    => $daemon_name,
							pid       => $fpid,
							domain    => Sympa::Site->domain
						);
						Sympa::Tools::Daemon::remove_pid(
							directory        => Sympa::Constants::PIDDIR,
							daemon           => $daemon_name,
							pid              => $fpid,
							multiple_process => 1
						);
						delete $dead_children{$fpid};
						push @dc, $fpid;
					}
				}
			}
			my $pids_in_pfile = Sympa::Tools::Daemon::read_pids(
				directory => Sympa::Constants::PIDDIR,
				daemon    => $daemon_name
			);
			unless (defined($pids_in_pfile)){
				my $result = Sympa::Tools::Daemon::write_pid(
					directory        => Sympa::Constants::PIDDIR,
					daemon           => $daemon_name,
					pid              => $PID,
					multiple_process => 1,
					method           => Sympa::Site->lock_method,
					user             => Sympa::Constants::USER,
					group            => Sympa::Constants::GROUP,
				);
				unless ($result) {
					Sympa::Log::Syslog::fatal_err('Error while writing pid file, exiting');
				}
				close STDERR;
				Sympa::Tools::Daemon::direct_stderr_to_file(
					directory => Sympa::Constants::PIDDIR,
					pid       => $PID,
					user      => Sympa::Constants::USER,
					group     => Sympa::Constants::GROUP,
				);
				$pids_in_pfile = [$PID];
			}

			## Start new processes if there remain at least 'bulk_fork_threshold' packets to send in the bulkmailer_table table
			if(
				(my $r_packets = $bulk->there_is_too_much_remaining_packets(Sympa::Site->bulk_fork_threshold)) &&
				($#remaining_children+1 < Sympa::Site->bulk_max_count) ){

				## disconnect from database before fork
				## to prevent DB handlers to be shared by different processes
				# when loading conf in database disconnect
				# because of sharing dbh may crash bulk.pl
				$base->disconnect();

				if(Sympa::Site->bulk_max_count > 1) {
					Sympa::Log::Syslog::do_log('info','Important workload: %s packets to process. Creating %s child bulks to increase sending rate.', $r_packets, Sympa::Site->bulk_max_count-($#remaining_children+1));
					for my $process_count(1..Sympa::Site->bulk_max_count-($#remaining_children+1)){
						Sympa::Log::Syslog::do_log('info', "Will fork: %s", $process_count);
						if ((my $child_pid = fork) != 0) {
							Sympa::Log::Syslog::do_log('info', "Starting bulk child daemon, pid %s", $child_pid);
							# Saves the pid number
							my $result = Sympa::Tools::Daemon::write_pid(
								directory        => Sympa::Constants::PIDDIR,
								daemon           => $daemon_name,
								pid              => $child_pid,
								multiple_process => 1,
								method           => Sympa::Site->lock_method,
								user             => Sympa::Constants::USER,
								group            => Sympa::Constants::GROUP,
							);
							unless ($result) {
								Sympa::Log::Syslog::fatal_err('Error while writing pid file, exiting');
							}
							$created_children{$child_pid} = 1;
							sleep 1;
						} else {
							## We're in a child bulk process
							close STDERR;
							Sympa::Tools::Daemon::direct_stderr_to_file(
								directory => Sympa::Constants::PIDDIR,
								pid       => $PID,
								user      => Sympa::Constants::USER,
								group     => Sympa::Constants::GROUP,
							);
							$date_of_last_activity = time();
							$main::daemon_usage = 'DAEMON_SLAVE'; # automatic lists creation
							Sympa::Log::Syslog::do_openlog(Sympa::Site->syslog, Sympa::Site->log_socket_type, 'bulk');
							Sympa::Log::Syslog::do_log('info', "Bulk slave daemon started with pid %s", $PID);
							last;
						}
					}
				}
			}
			$last_check_date = time();
		}
	}
	## If a child bulk process is running for long enough, stop it (if the number of remaining packets to send is reasonnable).
	if (
		($main::daemon_usage eq 'DAEMON_SLAVE') &&
		(time() - $date_of_last_activity > Sympa::Site->bulk_lazytime) &&
		!(my $r_packets = $bulk->there_is_too_much_remaining_packets(Sympa::Site->bulk_fork_threshold))
	){
		Sympa::Log::Syslog::do_log('info', "Process %s didn't send any message since %s seconds, exiting.", $PID, Sympa::Site->bulk_lazytime);
		last;
	}

	## Go through the bulk_mailer table and process messages

	if (my $next = $bulk->next()) {
		if ($next->{'messagekey'} ne $messagekey) {
			# current packet is not related to the same message as
			# the previous packet
			# so it is needed to fetch the new message from message_table
			$messagekey = $next->{'messagekey'};
			$message_from_spool =
				$spool->get_message({'messagekey' => $next->{'messagekey'}});
			Sympa::Log::Syslog::do_log('notice','Start sending message "%s" (key "%s") to list "%s@%s" (priority %s) (starting %s seconds after scheduled expedition date)',
				$next->{'messageid'},
				$next->{'messagekey'},
				$next->{'listname'},
				$next->{'robot'},
				$next->{'priority_message'},
				time() - $next->{'delivery_date'}
			);

			my $message;
			$message = Message->new($message_from_spool)
				if $message_from_spool;
			
			unless ($message) {
				Sympa::Log::Syslog::do_log('err',
					'Internal error: current packet (messagekey=%s) refers to a null message',
					$messagekey
				);
				unless (Bulk::remove($messagekey, $bulk->{'packetid'})) {
					Sympa::Log::Syslog::do_log('err',
						'Failed to remove processed packet "%s", messagekey "%s"',
						$messagekey, $bulk->{'packetid'}
					);
				}
				next; # while (!$end)
			}

			# Get message as string without meta information.
			$messageasstring_init = $message->as_string();

			unless ( $messageasstring_init ) {
				Sympa::Log::Syslog::do_log('err',"internal error : current packet (messagekey= %s) contains a ref to a null message",$next->{'messagekey'});
				unless
				($bulk->remove($next->{'messagekey'},$next->{'packetid'})) {
					Sympa::Log::Syslog::do_log('err',"failed to remove processed packet '%s', messagekey '%s'", $next->{'messagekey'},$next->{'packetid'});
				}
			}
			$messagekey = $next->{'messagekey'};
		}
		my $data; #HASH which will contain the attributes of the subscriber

		# Initialization of the HASH : $data.
		# It will be used by parse_tt2 to personalized messages.
		$data->{'listname'} = $next->{'listname'};
		$data->{'robot'} = $next->{'robot'};
		$data->{'to'} = $next->{'receipients'};
		$data->{'wwsympa_url'} = Sympa::Configuration::get_robot_conf($next->{'robot'},'wwsympa_url');

		my $rcpt; # It is the email of a subscriber, use it in the foreach
		my @rcpts = split /,/,$next->{'receipients'}; # / Contain all the subscribers
		## Use an intermediate handler to encode to filesystem_encoding
		my $user;

		# message transformation must be done in the folowing order
		#  -1 headers modifications (done in sympa.pl)
		#  -2 merge
		#  -3 smime sign
		#  -4 smime encrypt
		#  -5 remove existing signature if altered
		#  -6 dkim sign


		#my $list = Sympa::List->new($next->{'listname'}, $next->{'robot'});
		my $listname= $next->{'listname'};
		my $robot_id =  $next->{'robot'};
		my $list = $bulk->{'list_object'};
		my $robot = $bulk->{'robot_object'};

		if (
			$next->{'verp'}  ||
			$next->{'merge'} ||
			$next->{'tracking'} eq 'dsn' ||
			$next->{'tracking'}eq 'mdn'
		){
			# message needs personalization
			my $key;

			foreach $rcpt (@rcpts) {
				my $message = Sympa::Message->new(
					messageasstring => $messageasstring_init,
					noxsympato      => 'noxsympato'
					'list_object'   => $list,
				);
				my $entity = $message->as_entity();
				my $notification_id;
				my $return_path;
				my $escaped_rcpt = $rcpt;
				$escaped_rcpt  =~ s/\@/\=\=a\=\=/;

				if (
					$next->{'tracking'} eq 'dsn' ||
					$next->{'tracking'} eq 'mdn'
				) {
					# tracking by MDN required tracking by DSN to
					my $msgid = $message->get_msg_id;
					$notification_id = Sympa::Tracking::find_notification_id_by_message($rcpt, $msgid, $listname,$robot_id);
					$return_path = $list->get_bounce_address($rcpt, $notification_id);
					$entity->head->replace('Disposition-Notification-To',$return_path) if ($next->{'tracking'} eq 'mdn');
					if (($message->{'protected'})||($message->{'smime_crypted'})){
					my $msg_body = Sympa::Message::get_body_from_msg_as_string($messageasstring_init);
					$messageasstring_init = $entity->head->as_string(). "\n" . $msg_body; # concat headers from entity with original body
					} else {
					$messageasstring_init = $entity->as_string();
					}
				} else {  # VERP
					$return_path = $list->get_bounce_address($rcpt);
				}

				if (($next->{'merge'}) && !($message->{'protected'})) {
					if ($message->personalize($list, $rcpt)) {
						$messageasstring = $message->as_string();
					} else {
						Sympa::Log::Syslog::do_log('err', 'Erreur d appel personalize()');
						$list->robot->send_notify_to_listmaster(
							'bulk_failed',
							{
								'msg' => $messageasstring_init,
								'list' => $list,
							}
						);
						last;
					}
				} else {
					$messageasstring = $messageasstring_init;
				}

				if ($robot->dkim_feature eq 'on'){
					# assume Sympa::Tools::DKIM can be loaded if the setting is
					# still on
					require Sympa::Tools::DKIM;
					$messageasstring = Sympa::Tools::DKIM::remove_invalid_dkim_signature($messageasstring, Sympa::Site->tmpdir);
				}

				if ($message_from_spool->{'dkim_d'}){
					# apply dkim signature AFTER any other message transformation.
					$messageasstring = dkim_sign(
						$messageasstring,
						{
							'dkim_d'=> $message_from_spool->{'dkim_d'},
																	'dkim_i'=> $message_from_spool->{'dkim_i'},
																	'dkim_selector'=> $message_from_spool->{'dkim_selector'},
																	'dkim_privatekey' => $message_from_spool->{'dkim_privatekey'}
																},
						Sympa::Site->tmpdir
					);
				}

				*SMTP = Sympa::Mail::smtpto($return_path, \$rcpt, $next->{'robot'},$notification_id);
				# Message with customized data
				print SMTP $messageasstring;
				close SMTP;
			}
		} else {
			# message dont needs personalization, they can be sent by packet
			if ($robot->dkim_feature eq 'on'){
				$messageasstring_init = remove_invalid_dkim_signature($messageasstring_init, Sympa::Site->tmpdir);
			}
			# Initial message
			if ($message_from_spool->{'dkim_d'}){
				# assume Sympa::Tools::DKIM can be loaded if
				# there is a message in this spool
				require Sympa::Tools::DKIM;
				$messageasstring_init = Sympa::Tools::DKIM::dkim_sign(
					$messageasstring_init,
					{
						'dkim_d'=> $message_from_spool->{'dkim_d'},
						'dkim_i'=> $message_from_spool->{'dkim_i'},
						'dkim_selector'=> $message_from_spool->{'dkim_selector'},
						'dkim_privatekey' => $message_from_spool->{'dkim_privatekey'}
					},
					Sympa::Site->tmpdir
				);
			}

			*SMTP = Sympa::Mail::smtpto($next->{'returnpath'}, \@rcpts, $next->{'robot'});
			print SMTP $messageasstring_init;
			close SMTP;
		}

		## Remove packet once it has been processed
		unless ($bulk->remove($next->{'messagekey'},$next->{'packetid'})) {
			Sympa::Log::Syslog::do_log('err',"failed to remove processed packet '%s', messagekey '%s'", $next->{'messagekey'},$next->{'packetid'});
		}

		if($next->{'priority_packet'} == Sympa::Site->sympa_packet_priority + 5){
			Sympa::Log::Syslog::do_log('notice','Done sending message "%s" (key "%s") to list "%s@%s" (priority %s) in %s seconds since scheduled expedition date.',
				$next->{'messageid'},
				$next->{'messagekey'},
				$next->{'listname'},
				$next->{'robot'},
				$next->{'priority_message'},
				time() - $next->{'delivery_date'}
			);
		}
		$date_of_last_activity = time();
	} else {
		## Sleep for a while if bulk_mailer DB table is empty
		sleep Sympa::Site->bulk_sleep;
	}
	Sympa::Mail::reaper;
}

Sympa::List::send_notify_to_listmaster(undef, undef, undef, undef, 1); # Purge grouped notifications

Sympa::Log::Syslog::do_log('notice', 'bulk.pl exited normally due to signal');
Sympa::Tools::Daemon::remove_pid(
	directory        => Sympa::Constants::PIDDIR,
	daemon           => $daemon_name,
	pid              => $PID,
	multiple_process => 1
);

exit(0);


# When we catch SIGTERM, just change the value of the loop variable.
sub sigterm {
	Sympa::Log::Syslog::do_log('notice', 'signal TERM received, still processing current task');
	$end = 1;
}
