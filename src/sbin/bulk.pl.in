#!--PERL--
# -*- indent-tabs-mode: t; -*-
# vim:ft=perl:noet:sw=8:wrap:textwidth=78
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

=head1 NAME

bulk.pl - Sympa bulk mail manager

=head1 DESCRIPTION

This script runs as a daemon and regulary submit messages found in the database
to an SMTP server. Multiple instances can be run simultaneously to distribute
traffic.

=head1 SYNOPSIS

bulk.pl [options]

Available options:
  -F do not detach TTY
  -d debug

=cut

use strict;
use lib '--modulesdir--';

use Getopt::Long;

use Sympa::Bulk;
use Sympa::Configuration;
use Sympa::Constants;
use Sympa::List;
use Sympa::Log;
use Sympa::Mail;
use Sympa::Message;
use Sympa::Spool;
use Sympa::SDM;
use Sympa::Tools;
use Sympa::Tools::Daemon;
use Sympa::Tracking;

my $daemon_name = &Sympa::Log::set_daemon($0);
my $date_of_last_activity = time();
local $main::daemon_usage = 'DAEMON_MASTER'; ## Default is to launch bulk as master daemon.

## Check options
##  --debug : sets the debug mode
##  --foreground : prevents the script from beeing daemonized
##  --mail : logs every sendmail calls
my %options;
unless (&GetOptions(\%main::options, 'debug|d', 'foreground|F','mail|m')) {
    &Sympa::Log::fatal_err("Unknown options.");
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'debug'} || $main::options{'foreground'});

my $sympa_conf_file = Sympa::Constants::CONFIG;

# Load sympa.conf
unless (Sympa::Configuration::load($sympa_conf_file)) {
    &Sympa::Log::fatal_err("Unable to load sympa configuration, file $sympa_conf_file or one of the vhost robot.conf files contain errors. Exiting.");
}

## Check database connectivity
unless (&Sympa::SDM::check_db_connect()) {
    &Sympa::Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', $Sympa::Configuration::Conf{'db_name'});
}

&Sympa::Log::do_openlog($Sympa::Configuration::Conf{'syslog'}, $Sympa::Configuration::Conf{'log_socket_type'}, 'bulk');

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    &Sympa::Log::set_log_level($main::options{'log_level'});
    &Sympa::Log::do_log('info', "Configuration file read, log level set using options : $main::options{'log_level'}");
}else{
    &Sympa::Log::set_log_level($Sympa::Configuration::Conf{'log_level'});
    &Sympa::Log::do_log('info', "Configuration file read, default log level $Sympa::Configuration::Conf{'log_level'}");
}

## Set the process as main bulk daemon by default.
my $is_main_bulk = 0;

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
   open(STDERR, ">> /dev/null");
   open(STDOUT, ">> /dev/null");
   if (open(TTY, "/dev/tty")) {
#      ioctl(TTY, &TIOCNOTTY, 0);
      close(TTY);
   }
   setpgrp(0, 0);
   if ((my $child_pid = fork) != 0) {
       &Sympa::Log::do_log('info',"Starting bulk master daemon, pid %s",$child_pid);
       exit(0);
   }
}
&Sympa::Log::do_openlog($Sympa::Configuration::Conf{'syslog'}, $Sympa::Configuration::Conf{'log_socket_type'}, 'bulk');
## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});
$options->{'multiple_process'} = 0;

# Saves the pid number
&Sympa::Tools::Daemon::write_pid($Sympa::Configuration::Conf{'pidfile_bulk'}, $$, $options, $Sympa::Configuration::Conf{'lock_method'});
unless ($options->{'stderr_to_tty'}) {
    &Sympa::Tools::Daemon::direct_stderr_to_file(('tmpdir' => $Sympa::Configuration::Conf{'tmpdir'}, 'pid' => $$));
}
## Set the UserID & GroupID for the process
$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
$< = $> = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
    &Sympa::Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct($Sympa::Configuration::Conf{'umask'}));

## Change to list root
unless (chdir($Sympa::Configuration::Conf{'home'})) {
    &Sympa::Log::do_log('err','unable to change directory');
    exit (-1);
}

my $pinfo = &Sympa::List::_apply_defaults();

&Sympa::Log::do_log('notice', "bulk.pl %s Started", Sympa::Constants::VERSION);


## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $opensmtp = 0 ;
my $fh = 'fh0000000000';	## File handle for the stream.

my $messagekey;       # the key of the current message in the message_table
my $messageasstring_init;  # the current message as a string
my $messageasstring;  # the transformed message.

my $timeout = $Sympa::Configuration::Conf{'bulk_wait_to_fork'};
my $last_check_date = 0;
my %created_children;

$options->{'multiple_process'} = 1;
$Sympa::Configuration::Conf{'maxsmtp'} = int($Sympa::Configuration::Conf{'maxsmtp'}/$Sympa::Configuration::Conf{'bulk_max_count'});


my $spool = new Sympa::Spool('bulk');

while (!$end) {
    &Sympa::List::init_list_cache();
	&Sympa::List::send_notify_to_listmaster(undef, undef, undef, 1); # Process grouped notifications

    my $bulk;
    my $message_from_spool ;

    unless ($main::options{'foreground'}) {
        ##
	## Create child bulks if too much packets are waiting to be sent in the bulk_mailer table.
	## Only the main bulk process (DAEMON_MASTER) can create child processes
 	## Check if we need to run new child processes every 'bulk_wait_to_fork' (sympa.conf parameter) seconds
	if (($main::daemon_usage eq 'DAEMON_MASTER') && (time() - $last_check_date > $timeout)){
	    ## Clean up pid file (in case some child bulks would have died)
	    my @actual_children = &Sympa::Tools::Daemon::get_children_processes_list();
	    my @remaining_children;
	    my %dead_children = %created_children;
	    foreach my $apid (@actual_children) {
		if (defined $dead_children{$apid}) {
		    push @remaining_children, $apid;
		    delete $dead_children{$apid};
		}
	    }
	    my @pids_leftover = keys %dead_children;
	    if ($#pids_leftover > -1) {
		my @dc;
		&Sympa::Log::do_log('debug2','Some childs of current process disappeared. Checking whether they shut down cleanly or not.');
		my $pids_in_pfile = &Sympa::Tools::Daemon::get_pids_in_pid_file($Sympa::Configuration::Conf{'pidfile_bulk'});
		foreach my $fpid (@{$pids_in_pfile}) {
		    if (defined $dead_children{$fpid}) {
			&Sympa::Log::do_log('err','The %s child exists in the pid file but is no longer running. Removing it and notyfying listmaster.',$fpid);
			my $pname = $0;
			$pname =~ s/.*\/(\w+)/$1/;
			&Sympa::Tools::Daemon::send_crash_report(('tmpdir' => $Sympa::Configuration::Conf{'tmpdir'}, 'pid'=>$fpid,'pname'=>$pname, domain => $Sympa::Configuration::Conf{'domain'}));
			&Sympa::Tools::Daemon::remove_pid($Sympa::Configuration::Conf{'pidfile_bulk'}, $fpid, $options, $Sympa::Configuration::Conf{'tmpdir'});
			delete $dead_children{$fpid};
			push @dc, $fpid;
		    }
		}
	    }
	    my $pids_in_pfile = &Sympa::Tools::Daemon::get_pids_in_pid_file($Sympa::Configuration::Conf{'pidfile_bulk'});
	    unless (defined($pids_in_pfile)){
		&Sympa::Tools::Daemon::write_pid($Sympa::Configuration::Conf{'pidfile_bulk'}, $$, $options, $Sympa::Configuration::Conf{'lock_method'});
		close STDERR;
		&Sympa::Tools::Daemon::direct_stderr_to_file(('tmpdir' => $Sympa::Configuration::Conf{'tmpdir'}, 'pid' => $$));
		$pids_in_pfile = [$$];
	    }
	    ## Start new processes if there remain at least 'bulk_fork_threshold' packets to send in the bulkmailer_table table
	    if((my $r_packets = &Sympa::Bulk::there_is_too_much_remaining_packets()) && ($#remaining_children+1 < $Sympa::Configuration::Conf{'bulk_max_count'}) ){

		## disconnect from database before fork
		## to prevent DB handlers to be shared by different processes
		my $dbh = &Sympa::SDM::db_get_handler();
		$dbh->disconnect; # when loading conf in database disconnect because of sharing dbh may crash bulk.pl

		if($Sympa::Configuration::Conf{'bulk_max_count'} > 1) {
		    &Sympa::Log::do_log('info','Important workload: %s packets to process. Creating %s child bulks to increase sending rate.', $r_packets, $Sympa::Configuration::Conf{'bulk_max_count'}-($#remaining_children+1));
		    for my $process_count(1..$Sympa::Configuration::Conf{'bulk_max_count'}-($#remaining_children+1)){
			&Sympa::Log::do_log('info', "Will fork: %s", $process_count);
			if ((my $child_pid = fork) != 0) {
			    &Sympa::Log::do_log('info', "Starting bulk child daemon, pid %s", $child_pid);
			    # Saves the pid number
			    &Sympa::Tools::Daemon::write_pid($Sympa::Configuration::Conf{'pidfile_bulk'}, $child_pid, $options, $Sympa::Configuration::Conf{'lock_method'});
			    $created_children{$child_pid} = 1;
			    sleep 1;
			}else{
			    ## We're in a child bulk process
			    close STDERR;
			    &Sympa::Tools::Daemon::direct_stderr_to_file(('tmpdir' => $Sympa::Configuration::Conf{'tmpdir'}, 'pid' => $$));
			    $date_of_last_activity = time();
			    $main::daemon_usage = 'DAEMON_SLAVE'; # automatic lists creation
			    &Sympa::Log::do_openlog($Sympa::Configuration::Conf{'syslog'}, $Sympa::Configuration::Conf{'log_socket_type'}, 'bulk');
			    &Sympa::Log::do_log('info', "Bulk slave daemon started with pid %s", $$);
			    last;
			}
		    }
		}
	    }
	    $last_check_date = time();
	}
    }
    ## If a child bulk process is running for long enough, stop it (if the number of remaining packets to send is reasonnable).
    if (($main::daemon_usage eq 'DAEMON_SLAVE') &&
		(time() - $date_of_last_activity > $Sympa::Configuration::Conf{'bulk_lazytime'}) &&
		!(my $r_packets = &Sympa::Bulk::there_is_too_much_remaining_packets())){
		&Sympa::Log::do_log('info', "Process %s didn't send any message since %s seconds, exiting.", $$, $Sympa::Configuration::Conf{'bulk_lazytime'});
		last;
    }

	## Go through the bulk_mailer table and process messages

    if ($bulk = Sympa::Bulk::next()) {
	if ($bulk->{'messagekey'} ne $messagekey) {
	    # current packet is not related to the same message as the previous packet
            # so it is needed to fetch the new message from message_table

	    $messagekey = $bulk->{'messagekey'};
	    $message_from_spool = $spool->get_message({'messagekey' => $bulk->{'messagekey'}});
	    &Sympa::Log::do_log('notice','Start sending message "%s" (key "%s") to list "%s@%s" (priority %s) (starting %s seconds after scheduled expedition date)',
			$bulk->{'messageid'},
			$bulk->{'messagekey'},
			$bulk->{'listname'},
			$bulk->{'robot'},
			$bulk->{'priority_message'},
			time() - $bulk->{'delivery_date'});

	    $messageasstring_init = $message_from_spool->{'messageasstring'};

            #use Data::Dumper;
	    #my $dump = &Dumper($messageasstring_init); open (DUMP,">>/tmp/dumper"); printf DUMP 'messageasstring recup par bulk \n%s',$dump ; close DUMP;
	    # &trace_smime($messageasstring_init,'initial');

	    unless ( $messageasstring_init ) {
		&Sympa::Log::do_log('err',"internal error : current packet (messagekey= %s) contains a ref to a null message",$bulk->{'messagekey'});
		unless (&Sympa::Bulk::remove($bulk->{'messagekey'},$bulk->{'packetid'})) {
		    &Sympa::Log::do_log('err',"failed to remove processed packet '%s', messagekey '%s'", $bulk->{'messagekey'},$bulk->{'packetid'});
		}
	    }
	    $messagekey = $bulk->{'messagekey'};
	}
	my $data; #HASH which will contain the attributes of the subscriber

	# Initialization of the HASH : $data. It will be used by parse_tt2 to personalized messages.
	$data->{'listname'} = $bulk->{'listname'};
	$data->{'robot'} = $bulk->{'robot'};
	$data->{'to'} = $bulk->{'receipients'};
	$data->{'wwsympa_url'} = &Sympa::Configuration::get_robot_conf($bulk->{'robot'},'wwsympa_url');

	my $rcpt; # It is the email of a subscriber, use it in the foreach
	my @rcpts = split /,/,$bulk->{'receipients'}; # / Contain all the subscribers
	## Use an intermediate handler to encode to filesystem_encoding
	my $user;

	# message transformation must be done in the folowing order
        #  -1 headers modifications (done in sympa.pl)
        #  -2 merge
        #  -3 smime sign
        #  -4 smime encrypt
	#  -5 remove existing signature if altered
        #  -6 dkim sign
        #


	#my $list = new Sympa::List($bulk->{'listname'}, $bulk->{'robot'});
	my $listname= $bulk->{'listname'}; my $robot =  $bulk->{'robot'};

	if (($bulk->{'verp'})||($bulk->{'merge'})||($bulk->{'tracking'}eq 'dsn')||($bulk->{'tracking'}eq 'mdn')){ # message needs personalization
	    my $key ;

	    foreach $rcpt (@rcpts) {
		my $message = new Sympa::Message ({'messageasstring'=>$messageasstring_init,'noxsympato'=>'noxsympato'});
		my $entity = $message->{'msg'};
		my $notification_id;
		my $return_path;
		my $escaped_rcpt = $rcpt;
		$escaped_rcpt  =~ s/\@/\=\=a\=\=/;

		if(($bulk->{'tracking'} eq 'dsn')||($bulk->{'tracking'} eq 'mdn')){ # tracking by MDN required tracking by DSN to
		    my $msgid = $entity->head->get('Message-Id'); chomp $msgid;
		    $notification_id = &Sympa::Tracking::find_notification_id_by_message($rcpt, $msgid, $listname,$robot);
		    $return_path = $Sympa::Configuration::Conf{'bounce_email_prefix'}.'+'.$escaped_rcpt.'=='.$listname.'=='.$notification_id.'@'.$robot;
		    $entity->head->replace('Disposition-Notification-To',$return_path) if ($bulk->{'tracking'} eq 'mdn') ;
		    if (($message->{'protected'})||($message->{'smime_crypted'})){
			my $msg_body = &Sympa::Message::get_body_from_msg_as_string($messageasstring_init);
			$messageasstring_init = $entity->head->as_string. "\n" . $msg_body; # concat headers from entity with original body
		    }else{
			$messageasstring_init = $entity->as_string;
		    }
		    # &trace_smime($messageasstring,'tracking');
		}else{  # VERP
		    $return_path = $Sympa::Configuration::Conf{'bounce_email_prefix'}.'+'.$escaped_rcpt.'=='.$listname.'@'.$robot;
		}
		if (($bulk->{'merge'}) && !($message->{'protected'})) {
		    unless(&Sympa::Bulk::merge_msg ($entity, $rcpt, $bulk, $data)){
			&Sympa::Log::do_log('err', 'Erreur d appel &Sympa::Bulk::merge_msg');
		    }
		    $messageasstring = $entity->as_string;
		}else{
		    $messageasstring = $messageasstring_init;
		}

		if (&Sympa::Configuration::get_robot_conf($bulk->{'robot'}, 'dkim_feature') eq 'on'){
		    # assume Sympa::Tools::DKIM can be loaded if the setting is
		    # still on
		    require Sympa::Tools::DKIM;
		    $messageasstring = Sympa::Tools::DKIM::remove_invalid_dkim_signature($messageasstring, $Sympa::Configuration::Conf{'tmpdir'});
		}
		if ($message_from_spool->{'dkim_d'}){ # apply dkim signature AFTER any other message transformation.
		    $messageasstring = dkim_sign($messageasstring,{'dkim_d'=>           $message_from_spool->{'dkim_d'},
									   'dkim_i'=>           $message_from_spool->{'dkim_i'},
									   'dkim_selector'=>    $message_from_spool->{'dkim_selector'},
									   'dkim_privatekey' => $message_from_spool->{'dkim_privatekey'}, }, $Sympa::Configuration::Conf{'tmpdir'});
		}

		# &trace_smime($messageasstring,'dkim');

		*SMTP = &Sympa::Mail::smtpto($return_path, \$rcpt, $bulk->{'robot'},$notification_id);
		# Message with customized data
		print SMTP $messageasstring;
		close SMTP;
	    }
	}else{ # message dont needs personalization, they can be sent by packet
            if (&Sympa::Configuration::get_robot_conf($bulk->{'robot'}, 'dkim_feature') eq 'on'){
		$messageasstring_init = remove_invalid_dkim_signature($messageasstring_init, $Sympa::Configuration::Conf{'tmpdir'});
	    }
	    # Initial message
	    if ($message_from_spool->{'dkim_d'}){
		# assume Sympa::Tools::DKIM can be loaded if there is a message
		# in this spool
		require Sympa::Tools::DKIM;
		$messageasstring_init = Sympa::Tools::DKIM::dkim_sign($messageasstring_init,{'dkim_d'=>           $message_from_spool->{'dkim_d'},
										 'dkim_i'=>           $message_from_spool->{'dkim_i'},
										 'dkim_selector'=>    $message_from_spool->{'dkim_selector'},
										 'dkim_privatekey' => $message_from_spool->{'dkim_privatekey'}, }, $Sympa::Configuration::Conf{'tmpdir'} );
	    }

	    # &trace_smime($messageasstring_init,'dkim 2');

	    *SMTP = &Sympa::Mail::smtpto($bulk->{'returnpath'}, \@rcpts, $bulk->{'robot'});
	    print SMTP $messageasstring_init;
	    close SMTP;
	}

	## Remove packet once it has been processed
	unless (&Sympa::Bulk::remove($bulk->{'messagekey'},$bulk->{'packetid'})) {
	    &Sympa::Log::do_log('err',"failed to remove processed packet '%s', messagekey '%s'", $bulk->{'messagekey'},$bulk->{'packetid'});
	}


	if($bulk->{'priority_packet'} == $Sympa::Configuration::Conf{'sympa_packet_priority'} + 5){
	    &Sympa::Log::do_log('notice','Done sending message "%s" (key "%s") to list "%s@%s" (priority %s) in %s seconds since scheduled expedition date.',
		    $bulk->{'messageid'},
		    $bulk->{'messagekey'},
		    $bulk->{'listname'},
		    $bulk->{'robot'},
		    $bulk->{'priority_message'},
		    time() - $bulk->{'delivery_date'});
	}
	$date_of_last_activity = time();
    }else{
	## Sleep for a while if bulk_mailer DB table is empty
	sleep $Sympa::Configuration::Conf{'bulk_sleep'};
    }
    &Sympa::Mail::reaper;


}

&Sympa::List::send_notify_to_listmaster(undef, undef, undef, undef, 1); # Purge grouped notifications

&Sympa::Log::do_log('notice', 'bulk.pl exited normally due to signal');
&Sympa::Tools::Daemon::remove_pid($Sympa::Configuration::Conf{'pidfile_bulk'}, $$, $options, $Sympa::Configuration::Conf{'tmpdir'});

exit(0);


## When we catch SIGTERM, just change the value of the loop
## variable.
sub sigterm {
    &Sympa::Log::do_log('notice', 'signal TERM received, still processing current task');
    $end = 1;
}


sub trace_smime {

    my $messageasstring_init = shift;
    my $where = shift;

    my $trusted_ca_options = '';
    $trusted_ca_options = "-CAfile $Sympa::Configuration::Conf{'cafile'} " if ($Sympa::Configuration::Conf{'cafile'});
    $trusted_ca_options .= "-CApath $Sympa::Configuration::Conf{'capath'} " if ($Sympa::Configuration::Conf{'capath'});

    unless (open (MSGDUMP, "| $Sympa::Configuration::Conf{'openssl'} smime -verify  $trusted_ca_options > /dev/null")) {
	&Sympa::Log::do_log('err', "unable to verify smime signature");
	return undef ;
    }

    print MSGDUMP $messageasstring_init;

    close MSGDUMP;

    my $status = $?/256 ;
    unless ($status == 0) {
	&Sympa::Log::do_log('debug', "signature SMIME NOT OK   (%s)",$where);
    }else{
	&Sympa::Log::do_log('debug', "signature SMIME OK    (%s)",$where);
    }
}
