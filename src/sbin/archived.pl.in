#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014, 2015 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use Digest::MD5 qw();
use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;
use POSIX qw();

use Sympa;
use Sympa::Alarm;
use Sympa::Archive;
use Conf;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Sympa::DatabaseManager;
use Sympa::Language;
use Sympa::List;
use Sympa::Log;
use Sympa::Mailer;
use Sympa::Message;
use Sympa::Robot;
use Sympa::Spool::Archive;
use Sympa::Tools::Daemon;
use Sympa::Tools::File;

# Check options
my %options;
unless (
    GetOptions(
        \%main::options, 'config|f=s',  'debug|d', 'help|h',
        'foreground|F',  'log_level=s', 'version|v'
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}
if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless $main::options{'log_level'};
    $main::options{'foreground'} = 1;
}

my $log = Sympa::Log->instance;
$log->{'log_to_stderr'} = 'all' if $main::options{'foreground'};

# Load sympa.conf
unless (Conf::load()) {
    die sprintf
        "Unable to load sympa configuration, file %s has errors.\n",
        Conf::get_sympa_conf();
}

# Check databse connectivity
unless (Sympa::DatabaseManager->instance) {
    die sprintf
        "Database %s defined in sympa.conf has not the right structure or is unreachable.\n",
        $Conf::Conf{'db_name'};
}

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        # ioctl(TTY, TIOCNOTTY(), 0);
        ioctl(TTY, 0x20007471, 0);    # XXX s/b TIOCNOTTY
        close(TTY);
    }
    setpgrp 0, 0;
    my $child_pid = fork;
    if ($child_pid) {
        $log->syslog('info', 'Starting archived daemon, PID %s', $child_pid);
        exit 0;
    } elsif (not defined $child_pid) {
        die sprintf 'Cannot fork: %s', $ERRNO;
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the PID file
Sympa::Tools::Daemon::write_pid('archived', $PID, $options);
unless ($options->{'stderr_to_tty'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(('pid' => $PID));
}

# setting log_level using conf unless it is set by calling option
if ($main::options{'log_level'}) {
    $log->{level} = $main::options{'log_level'};
    $log->syslog('info',
        "Configuration file read, log level set using options : $main::options{'log_level'}"
    );
} else {
    $log->{level} = $Conf::Conf{'log_level'};
    $log->syslog('info',
        "Configuration file read, default log level $Conf::Conf{'log_level'}"
    );
}

my $log_facility = $Conf::Conf{'log_facility'} || $Conf::Conf{'syslog'};
$log->openlog($log_facility, $Conf::Conf{'log_socket_type'});

## Set the User ID & Group ID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    die
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo.\n";
}

## Sets the UMASK
umask(oct($Conf::Conf{'umask'}));

foreach my $robot (@{Conf::get_robots_list()}) {
    my $arc_dir = Conf::get_robot_conf($robot, 'arc_path');
    ## Create arc_path if required
    if ($arc_dir) {
        unless (directory_check($arc_dir)) {
            $log->syslog('err',
                'No vailable directory to store archives. Exiting');
            exit -1;
        }
    } else {
        $log->syslog('err',
            'Robot %s has no archives directory. Check arc_path parameter in this robot.conf and in sympa.conf.'
        );
        exit -1;
    }
}

## Change to list root
unless (chdir($Conf::Conf{'home'})) {
    die sprintf 'Unable to change directory to %s: %s', $Conf::Conf{'home'},
        $!;
}

Sympa::Language->instance->set_lang($Conf::Conf{'lang'}, 'en');

$log->syslog('notice', 'Archived %s Started', Sympa::Constants::VERSION);

# Catch signals, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'INT'}  = 'sigterm';
my $end = 0;

my $spool = Sympa::Spool::Archive->new;

# Infinite loop scanning the queue (unless a SIGTERM is received)
while (!$end) {
    Sympa::List::init_list_cache();
    # Process grouped notifications
    Sympa::Alarm->instance->flush;

    my ($message, $handle) = $spool->next;

    if ($message and $handle) {
        my $status = process_message($message, $handle);
        unless (defined $status) {
            $spool->quarantine($handle);
        } elsif ($status) {
            $spool->remove($handle);
        } else {
            # Processing aborted.  Redo later.
        }
    } elsif ($handle) {
        $log->syslog('err', 'Cannot parse message <%s>', $handle->basename);
        $spool->quarantine($handle);
        next;
    } else {
        # Sleep for a while if archive spool is empty.
        sleep $Conf::Conf{'sleep'};
    }

    # Free zombie sendmail process.
    Sympa::Mailer->instance->reaper;
}

# Purge grouped notifications.
Sympa::Alarm->instance->flush(purge => 1);

# Free zombie sendmail processes.
Sympa::Mailer->instance->reaper;

$log->syslog('notice', 'Archived exited normally due to signal');
Sympa::Tools::Daemon::remove_pid('archived', $PID);

exit 0;

# When we catch signal, just change the value of the loop variable.
sub sigterm {
    my ($sig) = @_;
    $log->syslog('notice',
        'Signal %s received, still processing current task', $sig);
    $end = 1;
}

sub process_message {
    my $message = shift;
    my $handle  = shift;

    unless (defined $message) {
        $log->syslog('err', 'Unable to create Sympa::Message object');
        return undef;
    }

    $log->syslog('notice', 'Processing %s; sender: %s; message ID: %s',
        $message, $message->{'sender'}, $message->{'message_id'});

    my ($robot_id, $list, $type);
    if (ref $message->{context} eq 'Sympa::List') {
        $robot_id = $message->{context}->{'domain'};
        $list     = $message->{context};
    } else {
        $robot_id = $message->{context};
    }
    $type = $message->{'listtype'} || '';

    # Unknown robot
    unless ($robot_id and $robot_id ne '*') {
        $log->syslog('err', 'Robot %s does not exist', $robot_id);
        return undef;
    }

    if ($type eq 'sympa') {
        return do_command($robot_id, $message);
    } elsif (not $type and $list) {
        $log->do_log('notice', 'Archiving %s for list %s', $message, $list);
        if ($Conf::Conf{'custom_archiver'}) {
            my $status = system($Conf::Conf{'custom_archiver'},
                '--list=' . $list->get_list_id,
                '--file=' . $spool->{directory} . '/' . $handle->basename,
            ) >> 8;
            if ($status) {
                $log->syslog('err', 'Custom archiver exits with code %d',
                    $status);
                return undef;
            }
        } else {
            unless (mail2arc($message)) {
                Sympa::send_notify_to_listmaster(
                    $robot_id,
                    'archiving_failed',
                    {   'file' => $handle->basename,
                        'bad'  => $spool->{bad_directory}
                    }
                );
                return undef;
            }
        }
    } else {
        $log->syslog('err', 'Illegal format: %s', $message);
        return undef;
    }

    return 1;
}

sub do_command {
    my $robot_id = shift;
    my $message  = shift;

    my ($bodyh, $io);
    unless ($bodyh = $message->as_entity->bodyhandle
        and $io = $bodyh->open('r')) {
        $log->syslog('err', 'Format error: %s', $message);
        return undef;
    }

    while (my $line = $io->getline) {
        chomp $line;
        next unless $line =~ /\S/;
        next if $line =~ /\A\s*#/;

        my ($order, $listname, $args) = split /\s+/, $line, 3;

        my $context;
        if ($listname and $listname eq '*') {
            $context = $robot_id;
        } else {
            $context = Sympa::List->new($listname, $robot_id);
            unless ($context) {
                $log->syslog('err', 'Unknown list %s', $listname);
                next;
            }
        }

        if ($order eq 'remove_arc') {
            my ($yyyymm, $msgid) = split /\s+/, $args, 2;
            unless (ref $context eq 'Sympa::List') {
                $log->syslog('err', 'Unknown list %s', $listname);
                next;
            }
            unless ($yyyymm =~ /\A\d{4}-\d{2}\z/) {
                $log->syslog('err', 'Illegal archive path "%s"', $yyyymm);
                next;
            }
            my $list = $context;

            my $arcpath = sprintf '%s/%s/%s',
                Conf::get_robot_conf($list->{'domain'}, 'arc_path'),
                $list->get_list_id, $yyyymm;

            $log->syslog('debug', 'Start remove process: list=%s; yyyymm=%s',
                $list, $yyyymm);

            my $sender = $message->{sender};

            chomp $msgid;
            if ($msgid =~ /NO-ID-FOUND\.mhonarc\.org/) {
                $log->syslog('err', 'No message id found');
                next;
            }

            my $arc_file;
            unless ($arc_file =
                Sympa::Archive::search_msgid("$arcpath/arctxt", $msgid)) {
                $log->syslog('err',
                    'No message with message ID %s found in %s/arctxt',
                    $msgid, $arcpath);
                next;
            }

            # if not list owner, list editor nor listmaster, check if
            # sender of remove order is sender of the message to be
            # removed.
            unless ($list->am_i('privileged_owner', $sender)
                or $list->am_i('owner',  $sender)
                or $list->am_i('editor', $sender)
                or Sympa::Robot::is_listmaster($sender, $list->{'domain'})) {
                # Analyze message to get sender from envelope sender and
                # sender_headers.
                my $arc_message =
                    Sympa::Message->new_from_file("$arcpath/arctxt/$arc_file",
                    context => $list);
                unless ($arc_message) {
                    $log->syslog('err',
                        'Unable to load new message %s/arctxt/%s',
                        $arcpath, $arc_file);
                    next;
                }
                my $messagesender = lc($arc_message->{'sender'});

                unless ($sender eq $messagesender) {
                    $log->syslog(
                        'err',
                        'Remove command for %s/arctxt/%s by unauthorized sender: %s',
                        $arcpath,
                        $arc_file,
                        $sender
                    );
                    next;
                }
            }
            # this point : requested command is from a authorized personn
            # (message sender or list admin or listmaster

            do_remove($list, $yyyymm, $msgid);

            my $url_dir = $list->{'dir'} . '/urlized/' . $msgid;
            Sympa::Tools::File::remove_dir($url_dir);

            unless (-d "$arcpath/deleted") {
                unless (mkdir("$arcpath/deleted", 0777)) {
                    $log->syslog('info', 'Unable to create %s/deleted : %m',
                        $arcpath);
                    last;
                }
            }

            unless (
                rename(
                    "$arcpath/arctxt/$arc_file",
                    "$arcpath/deleted/$arc_file"
                )
                ) {
                $log->syslog('info', 'Unable to rename message %s/arctxt/%s',
                    $arcpath, $arc_file);
                next;
            }

            # remove directory if empty arctxt
            unless (opendir(DIR, "$arcpath/arctxt")) {
                $log->syslog('info', 'Unable to open dir %s/arctxt',
                    $arcpath);
                next;
            }
            my @files = grep(/^\d+$/, readdir(DIR));
            closedir(DIR);
            unless (@files) {
                Sympa::Tools::File::remove_dir($arcpath);
            }
        } elsif ($order eq 'rebuildarc') {
            my $arc = (defined $args and length $args) ? $args : '*';
            unless ($arc =~ /\A\d{4}-\d{2}\z/ or $arc eq '*') {
                $log->syslog('err', 'Illegal archive path "%s"', $arc);

                next;
            }

            if (ref $context eq 'Sympa::List') {
                do_rebuild($context, $arc);
            } else {
                my $all_lists = Sympa::List::get_lists($context);
                foreach my $list (@{$all_lists || []}) {
                    do_rebuild($list, $arc);
                }
            }
        } else {
            $log->syslog('err', 'Format error: Unknown command "%s"', $order);
            return undef;
        }
    }

    return 1;
}

sub do_remove {
    $log->syslog('debug2', '(%s, %s, %s)', @_);
    my $list  = shift;
    my $arc   = shift;
    my $msgid = shift;

    $log->syslog('notice', 'Removing %s in list %s section %s',
        $msgid, $list, $arc);
    $log->db_log(
        'robot'        => $list->{'domain'},
        'list'         => $list->{'name'},
        'action'       => 'remove',
        'parameters'   => $msgid,
        'target_email' => '',
        'msg_id'       => $msgid,
        'status'       => 'success',
        'error_type'   => '',
        'user_email'   => ''
    );
    #FIXME: Assign right email.
    #$log->add_stat(
    #    'robot'     => $list->{'domain'},
    #    'list'      => $list->{'name'},
    #    'operation' => 'remove archive',
    #    'parameter' => '',
    #    'mail'      => 'test@cru.fr'
    #);

    system(
        Conf::get_robot_conf($list->{'domain'}, 'mhonarc'),
        '-outdir' => sprintf('%s/%s/%s',
            Conf::get_robot_conf($list->{'domain'}, 'arc_path'),
            $list->get_id, $arc),
        '-rmm' => $msgid
    );
}

# =head2 sub rebuild(STRING $adrlist)
#
# Rebuilds archives for the list the name of which is given in the argument $adrlist.
#
# =head3 Arguments
#
# =over
#
# =item * I<$adrlist>, a character string containing the name of the list the archives of which we want to rebuild.
#
# =back
#
# =head3 Return
#
# =over
#
# =item * I<undef> if something goes wrong.
#
# =back
#
# =cut

sub do_rebuild {
    $log->syslog('debug2', '(%s, %s)', @_);
    my $list = shift;
    my $arc  = shift;

    my $listname = $list->{'name'};
    my $robot_id = $list->{'domain'};

    my $arcpath = Conf::get_robot_conf($robot_id, 'arc_path');
    my $tag = Sympa::Archive::get_tag($list);
    my $mhonarc_ressources =
        Sympa::search_fullpath($list, 'mhonarc-ressources.tt2');

    if (   ($list->{'admin'}{'web_archive_spam_protection'} ne 'none')
        && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    $log->syslog('notice', 'Rebuilding %s with M2H_ADDRESSMODIFYCODE: %s',
        $arc, $ENV{'M2H_ADDRESSMODIFYCODE'});

    if ($arc and $arc ne '*') {
        $log->syslog('notice', "Rebuilding %s of %s archive", $arc, $list);
        $arc =~ /^(\d{4})-(\d{2})$/;
        my $yyyy = $1;
        my $mm   = $2;

        # remove empty directory
        my $arcdir = $arcpath . '/' . $list->get_id . '/' . $yyyy . '-' . $mm;
        my $arctxt = $arcdir . '/arctxt';
        if (opendir(DIR, $arctxt)) {
            my @files = (grep(/^\d+$/, (readdir DIR)));
            close(DIR);
            if ($#files == -1) {
                $log->syslog('notice', "Removing empty directory %s",
                    $arcdir);
                Sympa::Tools::File::remove_dir($arcdir);
                next;
            }

            ## index file was removed ; recreate it
            my $index = $files[$#files];
            save_idx($arcdir . '/index', $index + 1);
        }

        # recreate index file if needed
        unless (-f $arcdir . '/index') {
            create_idx($arcdir);
        }

        # Remove .mhonarc.db
        unlink $arcdir . '/.mhonarc.db';

        # Remove existing HTML files
        opendir HTML, $arcdir;

        # Skip arctxt/ . and ..
        foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
            unlink $arcdir . '/' . $html_file;
        }
        closedir HTML;

        my $arcs_dir =
            Sympa::Archive::clean_archive_directory($robot_id,
            sprintf('%s/%s/arctxt', $list->get_id, $arc));
        my $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'} if $arcs_dir;

        my @cmd = (
            Conf::get_robot_conf($robot_id, 'mhonarc'),
            '-modifybodyaddresses',
            '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
            '-rcfile'            => $mhonarc_ressources,
            '-outdir'            => $arcdir,
            '-definevars'        => sprintf(
                "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
                $listname, $robot_id, $yyyy, $mm, $yyyy, $mm, $arcpath,
                Conf::get_robot_conf($robot_id, 'wwsympa_url'), $tag
            ),
            '-umask' => $Conf::Conf{'umask'},
            $dir_to_rebuild
        );

        $log->syslog('debug', 'System call: %s', join(' ', @cmd));
        my $exitcode = system(@cmd) >> 8;

        # Delete temporary directory containing files with escaped HTML.
        if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
            Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
        }

        ## Remove lock if required
        if ($exitcode == 75) {
            $log->syslog(
                'notice',
                'Removing lock directory %s',
                $arcdir . '/.mhonarc.lck'
            );
            rmdir $arcdir . '/.mhonarc.lck';

            $exitcode = system(@cmd) >> 8;
        }

        if ($exitcode) {
            $log->syslog(
                'err',
                'Command %s failed with exit code %s',
                join(' ', @cmd), $exitcode
            );
        } else {
            $log->syslog('notice', "Rebuild %s of %s archive complete",
                $arc, $list);
        }
    } else {
        $log->syslog('notice', 'Rebuilding archive of %s completely', $list);
        my $dh;
        unless (opendir $dh, sprintf('%s/%s', $arcpath, $list->get_id)) {
            $log->syslog('err', 'Unable to open %s/%s to rebuild archive',
                $arcpath, $list->get_id);
            return;
        }
        my @archives = grep(/^\d{4}-\d{2}/, readdir $dh);
        closedir $dh;

        foreach my $arc (@archives) {
            $arc =~ /^(\d{4})-(\d{2})$/;
            my $yyyy = $1;
            my $mm   = $2;

            my $arcdir =
                $arcpath . '/' . $list->get_id . '/' . $yyyy . '-' . $mm;

            # Remove .mhonarc.db
            unlink $arcdir . '/.mhonarc.db';

            ## Remove existing HTML files
            opendir HTML, $arcdir;
            ## Skip arctxt/ . and ..
            foreach
                my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
                unlink $arcdir . '/' . $html_file;
            }
            closedir HTML;
            my $dir_to_rebuild = "$arcdir/arctxt";
            my $arcs_dir =
                Sympa::Archive::clean_archive_directory($robot_id,
                sprintf('/%s/%s/arctxt', $list->get_id, $arc));
            if ($arcs_dir) {
                $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'};
            }
            ## recreate index file if needed
            unless (-f $arcdir . '/index') {
                create_idx($arcdir);
            }

            my @cmd = (
                Conf::get_robot_conf($robot_id, 'mhonarc'),
                '-modifybodyaddresses',
                '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
                '-rcfile'            => $mhonarc_ressources,
                '-outdir'            => $arcdir,
                '-definevars'        => sprintf(
                    "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
                    $listname, $robot_id, $yyyy, $mm, $yyyy, $mm, $arcpath,
                    Conf::get_robot_conf($robot_id, 'wwsympa_url'), $tag
                ),
                '-umask' => $Conf::Conf{'umask'},
                $dir_to_rebuild
            );
            my $exitcode = system(@cmd) >> 8;

            # Delete temporary directory containing files with escaped HTML.
            if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
                Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
            }

            ## Remove lock if required
            if ($exitcode == 75) {
                $log->syslog(
                    'notice',
                    'Removing lock directory %s',
                    $arcdir . '/.mhonarc.lck'
                );
                rmdir $arcdir . '/.mhonarc.lck';

                $exitcode = system(@cmd) >> 8;
            }
            if ($exitcode) {
                $log->syslog(
                    'err',
                    'Command %s failed with exit code %s',
                    join(' ', @cmd), $exitcode
                );
            }

        }
        $log->syslog('notice', "Rebuild of %s archives completed", $list);
    }
}

# =head2 sub mail2arc(STRING $file,STRING $listname,STRING $robot_id,STRING $yyyy,STRING $mm,STRING $dd,STRING $hh,STRING $min,STRING $ss)
#
# Archives one message into one list archives directory.
#
# =head3 Arguments
#
# =over
#
# =item * I<$file>: a character string containing the message filename.
#
# =item * I<$listname>: a character string containing the name of the list in which to archive the message
#
# =item * $robot: a character string containing the name of the virtual robot hosting the list.
#
# =item * I<$yyyy>: a character string containing the year of the date when the message is archived (i.e. now)
#
# =item * I<$mm>: a character string containing the month of the date when the message is archived (i.e. now)
#
# =item * I<$dd>: a character string containing the day of the date when the message is archived (i.e. now)
#
# =item * I<$hh>: a character string containing the hour of the date when the message is archived (i.e. now)
#
# =item * I<$min>: a character string containing the minute of the date when the message is archived (i.e. now)
#
# =item * I<$ss>: a character string containing the second of the date when the message is archived (i.e. now)
#
# =back
#
# =head3 Return
#
# =over
#
# =item * I<undef> if something goes wrong.
#
# =back
#
# =cut

sub mail2arc {
    $log->syslog('debug2', '(%s)', @_);
    my $message = shift;

    my $newfile;

    my $list = $message->{context};
    my $arcpath = Conf::get_robot_conf($list->{'domain'}, 'arc_path');

    my $tag = Sympa::Archive::get_tag($list);

    if (    $list->{'admin'}{'web_archive_spam_protection'} ne 'none'
        and $list->{'admin'}{'web_archive_spam_protection'} ne 'cookie') {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    # chdir($arcpath);

    my @now  = localtime $message->{date};
    my $yyyy = sprintf '%04d', 1900 + $now[5];
    my $mm   = sprintf '%02d', $now[4] + 1;
    my $dd   = sprintf '%02d', $now[3];
    my $hh   = sprintf '%02d', $now[2];
    my $min  = sprintf '%02d', $now[1];
    my $ss   = sprintf '%02d', $now[0];

    my $basedir = $arcpath . '/' . $list->get_list_id();

    if (!-d $basedir) {
        unless (mkdir $basedir, 0775) {
            $log->syslog('err', 'Cannot create directory %s', $basedir);
            Sympa::send_notify_to_listmaster($list->{'domain'},
                'unable_to_create_dir', {'dir' => "$basedir"});
        }
        $log->syslog('debug', 'mkdir %s', $basedir);
    }

    ## Check quota
    if ($list->{'admin'}{'archive'}{'quota'}) {
        my $used = $list->get_arc_size("$arcpath");

        if ($used >= $list->{'admin'}{'archive'}{'quota'} * 1024) {
            $log->syslog('err', 'Web archive quota exceeded for list %s',
                $list);
            $list->send_notify_to_owner('arc_quota_exceeded',
                {'size' => $used});
            return undef;
        }
        if ($used >= ($list->{'admin'}{'archive'}{'quota'} * 1024 * 0.95)) {
            $log->syslog('err', 'Web archive quota exceeded for list %s',
                $list);
            $list->send_notify_to_owner(
                'arc_quota_95',
                {   'size' => $used,
                    'rate' => int(
                        $used * 100 /
                            ($list->{'admin'}{'archive'}{'quota'} * 1024)
                    )
                }
            );
        }
    }

    my $monthdir = $basedir . "/$yyyy-$mm";

    if (!-d $monthdir) {
        unless (mkdir($monthdir, 0775)) {
            $log->syslog('err', 'Cannot create directory %s', $monthdir);
            return undef;
        }

        $log->syslog('debug', 'mkdir %s/%s/%s-%s',
            $arcpath, $list->get_list_id(), $yyyy, $mm);

        if ($list->{'admin'}{'archive'}{'max_month'}) {
            # maybe need to remove some old archive
            if (opendir DIR, $arcpath . '/' . $list->get_list_id()) {
                my @archives = (
                    sort { $a cmp $b }
                    grep (/^\d{4}-\d{2}/, readdir(DIR))
                );
                closedir DIR;
                my $nb_month = $#archives + 1;
                my $i        = 0;
                while ($nb_month > $list->{'admin'}{'archive'}{'max_month'}) {
                    $log->syslog('info', 'Removing %s/%s/%s',
                        $arcpath, $list->get_list_id(), $archives[$i]);
                    Sympa::Tools::File::remove_dir($arcpath . '/'
                            . $list->get_list_id() . '/'
                            . $archives[$i]);
                    $i++;
                    $nb_month--;
                }
            }
        }
    }

    my $arctxtdir = $monthdir . "/arctxt";

    if (!-d $arctxtdir) {
        unless (mkdir($arctxtdir, 0775)) {
            $log->syslog('err', 'Cannot create directory %s', $arctxtdir);
            return undef;
        }
        $log->syslog('debug', 'mkdir %s', $arctxtdir);
    }

    ## copy the file in the arctxt and in "mhonarc -add"
    if (-f $monthdir . "/index") {
        open IDX, '<', "$monthdir/index"
            or die sprintf "Couldn't read index for %s: %s/n", $list->get_id,
            $ERRNO;
        $newfile = <IDX>;
        chomp($newfile);
        $newfile++;
        close IDX;
    } else {
        ## recreate index file if needed and update it
        $newfile = create_idx($monthdir) + 1;
    }

    # Save arctxt dump of original message.
    open my $fh, '>', "$arctxtdir/$newfile"
        or die sprintf 'Couldn\'t open file %s/%s: %s', $arctxtdir,
        $newfile, $!;
    print $fh $message->as_string;
    close $fh;

    # Prepare clean message content (HTML parts are cleaned)
    unless ($message->clean_html) {
        $log->syslog('err', "Could not clean message, ignoring message");
        next;
    }

    my $mhonarc_ressources =
        Sympa::search_fullpath($list, 'mhonarc-ressources.tt2');

    $log->syslog(
        'debug',
        'Calling %s for list %s',
        Conf::get_robot_conf($list->{'domain'}, 'mhonarc'), $list
    );

    # call mhonarc on cleaned message source to make clean htlm view of
    # message
    my @cmd = (
        Conf::get_robot_conf($list->{'domain'}, 'mhonarc'),
        '-add',
        '-modifybodyaddresses',
        '-addressmodifycode' => $ENV{'M2H_ADDRESSMODIFYCODE'},
        '-rcfile'            => $mhonarc_ressources,
        '-outdir'            => $monthdir,
        '-definevars'        => sprintf(
            "listname='%s' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s",
            $list->{'name'}, $list->{'domain'}, $yyyy, $mm, $yyyy, $mm,
            $arcpath, Conf::get_robot_conf($list->{'domain'}, 'wwsympa_url'),
            $tag
        ),
        '-umask' => $Conf::Conf{'umask'}
    );

    $log->syslog('debug', 'System call: %s', join(' ', @cmd));

    my $pipeout;
    unless (open $pipeout, '|-', @cmd) {
        $log->syslog('err', 'Could not open pipe: %m');
        return undef;
    }
    print $pipeout $message->as_string;
    close $pipeout;
    my $status = $? >> 8;

    ## Remove lock if required
    if ($status == 75) {
        $log->syslog(
            'notice',
            'Removing lock directory %s',
            $monthdir . '/.mhonarc.lck'
        );
        rmdir $monthdir . '/.mhonarc.lck';

        my $pipeout;
        unless (open $pipeout, '|-', @cmd) {
            $log->syslog('err', 'Could not open pipe: %m');
            return undef;
        }
        print $pipeout $message->as_string;
        close $pipeout;
        $status = $? >> 8;
    }
    if ($status) {
        $log->syslog(
            'err',
            'Command %s failed with exit code %s',
            join(' ', @cmd), $status
        );
    }

    save_idx("$monthdir/index", $newfile);

    return 1;
}

# Sets the value of $ENV{'M2H_ADDRESSMODIFYCODE'} and $ENV{'M2H_MODIFYBODYADDRESSES'}
#* $tag a character string (containing the result of get_tag($list))
sub set_hidden_mode {
    ## tag is used as variable elements in tags to prevent message contents to
    ## be parsed
    my $tag = shift;

    ## $ENV{'M2H_MODIFYBODYADDRESSES'} à positionner si le corps du message est parse
    $ENV{'M2H_ADDRESSMODIFYCODE'} =
        "s|^([^\@]+)\@([^\@]+)\$|\($tag\%hidden_head\%$tag\)\$1\($tag\%hidden_at\%$tag\)\$2\($tag\%hidden_end\%$tag\)|g";
    $ENV{'M2H_MODIFYBODYADDRESSES'} = 1;
}

# Empties $ENV{'M2H_ADDRESSMODIFYCODE'}.
sub unset_hidden_mode {

    ## Be careful, the .mhonarc.db file keeps track of previous
    ## M2H_ADDRESSMODIFYCODE setup
    $ENV{'M2H_ADDRESSMODIFYCODE'} = '';
}

# Saves the archives index file
#* $index, a string corresponding to the file name to which save an index.
#* $lst, a character string
sub save_idx {
    my ($index, $lst) = @_;

    return unless $lst;

    open INDEXF, '>', $index
        or die sprintf 'Couldn\'t overwrite index %s: %s', $index, $!;
    print INDEXF "$lst\n";
    close INDEXF;
}

## Create the 'index' file for one archive subdir
sub create_idx {
    my $arc_dir = shift;    ## corresponds to the yyyy-mm directory

    my $arc_txt_dir = $arc_dir . '/arctxt';

    unless (opendir(DIR, $arc_txt_dir)) {
        $log->syslog('err', 'Failed to open directory "%s"', $arc_txt_dir);
        return undef;
    }

    my @files = (sort { $a <=> $b; } grep(/^\d+$/, (readdir DIR)));
    my $index = $files[$#files] || 0;
    save_idx($arc_dir . '/index', $index);

    closedir DIR;

    return $index;
}

# OBSOLETED.
# Use Sympa::Archive::get_tag().
sub get_tag {
    my $listname = shift;

    return (
        substr(
            Digest::MD5::md5_hex(join('/', $Conf::Conf{'cookie'}, $listname)),
            -10
        )
    );
}

# Checks if directory exists and we have write and read accec to it.
sub directory_check {
    my $dir = shift;
    unless (-d $dir) {
        printf STDERR "Creating missing %s directory\n", $dir;
        unless (mkdir $dir, 0775) {
            $log->syslog('err', 'Unable to create directory %s', $dir);
            return undef;
        }
        unless (
            Sympa::Tools::File::set_file_rights(
                file  => $dir,
                user  => Sympa::Constants::USER,
                group => Sympa::Constants::GROUP,
                mode  => 0775,
            )
            ) {
            $log->syslog('err', 'Unable to set rights on %s', $dir);
            return undef;
        }
    }
    unless ((-r $dir) && (-w $dir)) {
        $log->syslog('err', 'Unsufficient access to %s directory', $dir);
        return undef;
    }
    return 1;
}

__END__

=encoding utf-8

=head1 NAME

archived, archived.pl - Mailing List Archiving Daemon for Sympa

=head1 SYNOPSIS

S<B<archived.pl> [ B<--foreground> ] [ B<--debug> ]>

=head1 DESCRIPTION

B<Archived> is a program which scan permanently the archive spool
and feeds the web archives, converting messages to the HTML format and
linking them. Original mails are also kept (in I<arctxt/> directory> for
later rebuilding of archives.

The HTML conversion is achieved by the means of the B<MHonArc> program.

Archives are accessed via B<wwsympa.fcgi> and B<sympa.pl>,
which proposes access control;
therefore archives should not be located in a public web directory.

=head1 OPTIONS

These programs follow the usual GNU command line syntax,
with long options starting with two dashes (C<-->).  A summary of
options is included below.

=over 5

=item B<-F>, B<--foreground>

Do not detach TTY.

=item B<-f>, B<--config=>I<file>

Force archived to use an alternative configuration file instead
of F<--CONFIG-->.

=item B<-d>, B<--debug>

Run the program in a debug mode.

=item B<-h>, B<--help>

Print this help message.

=back

=head1 FILES

F<--spooldir--/outgoing/> outgoing Sympa directory.

F<--defaultdir--/mhonarc-ressources.tt2> template of MHonArc resource file.

F<--CONFIG--> Sympa configuration file.

F<--piddir--/archived.pid> this file contains the process ID
of F<archived.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be found in
L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 HISTORY

This program was originally written by:

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

This manual page was initially written by
JE<233>rE<244>me Marant <jerome.marant@IDEALX.org>
for the Debian GNU/Linux system.

=head1 LICENSE

You may distribute this software under the terms of the GNU General
Public License Version 2.  For more details see F<README> file.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license can be found under
L<http://www.gnu.org/licenses/fdl.html>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa_msg(8)>, L<bounced(8)>, L<mhonarc(1)>, L<sympa.conf(5)>.

=cut
