#!--PERL--
# -*- indent-tabs-mode: t; -*-
# vim:ft=perl:noet:sw=8:textwidth=78
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

=head1 NAME

archived.pl - Web archive manager

=head1 SYNOPSIS

  archived.pl [-d|--debug] [-F|--foreground]

=head1 DESCRIPTION

This daemon regularly checks the 'outgoing' spool and picks the messages it
finds in it. It then calls MHonArc to build the HTML version of archives and
add an SMTP text version (i.e. an ASCII file including headers and body) to
the appropriate directory.

=head1 OPTIONS

=over

=item B<-d>, B<--debug>

Set debug mode (implies -F)

=item B<-F>, B<--foreground>

Do not detach from TTY.

=item B<-h>, B<--help>

Print this help and exit.

=back

=head1 AUTHORS

=over

=item * Serge Aumont <sa AT cru.fr>

=item * Olivier Salaun <os AT cru.fr>

=back

=cut

use strict;
use lib '--modulesdir--';

use Digest::MD5;
use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;

use Sympa::Archive;
use Sympa::Configuration;
use Sympa::Constants;
use Sympa::Language;
use Sympa::List;
use Sympa::Log::Database;
use Sympa::Log::Syslog;
use Sympa::Message;
use Sympa::SDM;
use Sympa::Spool;
use Sympa::Tools;
use Sympa::Tools::Time;
use Sympa::Tools::File;
use Sympa::Tools::Daemon;
use Sympa::WWSympa;

my $daemon_name = Sympa::Log::Syslog::set_daemon($0);
my $ip = $ENV{'REMOTE_HOST'};

#getopts('dF');

## Check options
my %options;
GetOptions(
	\%options,
	'debug|d',
	'foreground|F',
	'help|h'
) or pod2usage(-verbose => 0);

pod2usage(-verbose => 0, -exitstatus => 0) if $options{help};

if ($options{'debug'}) {
	$options{'log_level'} = 2 unless ($options{'log_level'});
}

$options{'foreground'} = 1 if ($options{'debug'});
$options{'log_to_stderr'} = 1 if ($options{'debug'} || $options{'foreground'});

my $wwsympa_conf    = Sympa::Constants::WWSCONFIG;
my $sympa_conf_file = Sympa::Constants::CONFIG;

my $wwsconf = {};

# Load WWSympa configuration
unless ($wwsconf = Sympa::WWSympa::load_config($wwsympa_conf)) {
	print STDERR 'unable to load config file';
	exit -1;
}

# Load sympa.conf
unless (Sympa::Configuration::load($sympa_conf_file)) {
	Sympa::Log::Syslog::fatal_err("Unable to load sympa configuration, file $sympa_conf_file has errors.");
}

## Check databse connectivity
unless (Sympa::SDM::check_db_connect()) {
	Sympa::Log::Syslog::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', $Sympa::Configuration::Conf{'db_name'});
}

## Put ourselves in background if not in debug mode.
unless ($options{'debug'} || $options{'foreground'}) {
	open(STDERR, ">> /dev/null");
	open(STDOUT, ">> /dev/null");
	if (open(TTY, "/dev/tty")) {
		ioctl(TTY, 0x20007471, 0);
		close(TTY);
	}
	setpgrp(0, 0);
	if ((my $child_pid = fork) != 0) {
		print STDOUT "Starting archive daemon, pid $_\n";

		exit(0);
	}
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($options{'foreground'});

## Create and write the pidfile
my $result = Sympa::Tools::Daemon::write_pid(
	file    => $wwsconf->{'archived_pidfile'},
	pid     => $PID,
	options => $options,
	method  => $Sympa::Configuration::Conf{'lock_method'},
	user    => Sympa::Constants::USER,
	group   => Sympa::Constants::GROUP,
);
unless ($result) {
	Sympa::Log::Syslog::fatal_err('Error while writing pid file, exiting');
}
unless ($options->{'stderr_to_tty'}) {
	Sympa::Tools::Daemon::direct_stderr_to_file(
		tmpdir => $Sympa::Configuration::Conf{'tmpdir'},
		pid    => $PID,
		user   => Sympa::Constants::USER,
		group  => Sympa::Constants::GROUP,
	);
}

# setting log_level using conf unless it is set by calling option
if ($options{'log_level'}) {
	Sympa::Log::Syslog::set_log_level($options{'log_level'});
	Sympa::Log::Syslog::do_log('info', "Configuration file read, log level set using options : $options{'log_level'}");
} else {
	Sympa::Log::Syslog::set_log_level($Sympa::Configuration::Conf{'log_level'});
	Sympa::Log::Syslog::do_log('info', "Configuration file read, default log level $Sympa::Configuration::Conf{'log_level'}");
}

$wwsconf->{'log_facility'}||= $Sympa::Configuration::Conf{'syslog'};
Sympa::Log::Syslog::do_openlog($wwsconf->{'log_facility'}, $Sympa::Configuration::Conf{'log_socket_type'}, 'archived');

## Set the UserID & GroupID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];


## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2]) && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
	Sympa::Log::Syslog::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct($Sympa::Configuration::Conf{'umask'}));

foreach my $robot (@{Sympa::Configuration::get_robots_list()}) {
	my $arc_dir = Sympa::Configuration::get_robot_conf($robot,'arc_path');
	## Create arc_path if required
	if ($arc_dir) {
		unless (directory_check($arc_dir)) {
			Sympa::Log::Syslog::do_log('err','No vailable directory to store archives. Exiting.');
			exit -1;
		}
	} else {
		Sympa::Log::Syslog::do_log('err','Robot %s has no archives directory. Check arc_path parameter in this robot.conf and in wwsympa.conf.');
		exit -1;
	}
}

## Change to list root
unless (chdir($Sympa::Configuration::Conf{'home'})) {
	Sympa::Log::Syslog::do_log('err','unable to change directory');
	exit (-1);
}

my $pinfo = Sympa::List::_apply_defaults();

$Sympa::Language::default_lang = $Sympa::Configuration::Conf{'lang'};

Sympa::Log::Syslog::do_log('notice', "archived %s Started", Sympa::Constants::VERSION);


## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $spoolarchive = Sympa::Spool->new(name => 'archive');

## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {

	Sympa::List::init_list_cache();
	sleep 1;
	my $item = $spoolarchive->next;

	next unless $item;

	my @orders = split(/\n/,$item->{'messageasstring'} );

	Sympa::Log::Syslog::do_log('debug',"orders[0] %s ",$orders[0] );

	if ($orders[0] =~ /^rebuild\s*$/ ) {
		Sympa::Log::Syslog::do_log('debug',"rebuild found ");
		if ($item->{'list'} && $item->{'robot'}) {
			rebuild($item->{'list'}.'@'.$item->{'robot'});
			$spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}});
		} else {
			Sympa::Log::Syslog::do_log('err',"unable to rebuild archive for unkown list/robot.Move to bad");
			$spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to rebuild archive for unkown list','lock'=>'NULL'});
			next;
		}
	}elsif($orders[0]  =~ /^remove\.(\d\d\d\d\-\d\d)\.\d+$/ ) {
		my $yyyymm = $1;
		shift @orders;
		Sympa::Log::Syslog::do_log('debug',"removed found ");
		unless($item->{'list'} && $item->{'robot'}){
			Sympa::Log::Syslog::do_log('err',"unable to remove messages from archive for unkown list/robot.Move to bad");
			$spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to remove messages from archive, list name missing','lock'=>'NULL'});
			next;
		}
		my $listadress = $item->{'list'}.'@'.$item->{'robot'}	;

		my $arclistdir = $listadress.'.'.$yyyymm;
		my $arcpath = "$wwsconf->{'arc_path'}/$listadress/$yyyymm";

		Sympa::Log::Syslog::do_log('debug',"start remove process :listadress :'$listadress' arclistdir '$arclistdir' arcpath '$arcpath'  yyyymm '$yyyymm'");

		my $list = Sympa::List->new(name => $listadress);
		unless ($list) {
			Sympa::Log::Syslog::do_log('err',"remove : unknown list $listadress");
			$spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to remove messages from archive for unkown list','lock'=>'NULL'});
			next;
		}
		Sympa::Log::Syslog::do_log('debug',"remove found : for $arclistdir");

		my $email_regexp = Sympa::Tools::get_regexp('email');

		foreach my $order (@orders) {
			unless($order =~ /(.*)\|\|($email_regexp)/){
				Sympa::Log::Syslog::do_log ('err',"Ignoring remove_order $order not recognized format");
				next;
			}
			my $msgid = $1;
			my $sender = $2;

			chomp 	$msgid ;
			if ($msgid =~ /NO-ID-FOUND\.mhonarc\.org/) {
				Sympa::Log::Syslog::do_log('err','remove_arc: no message id found');
				next;
			}

			my $message ;
			unless ($message = Sympa::Archive::search_msgid("$arcpath/arctxt",$msgid)){
				Sympa::Log::Syslog::do_log('err','No message with message-id %s found in %s/arctxt',$msgid,$arcpath);
				next;
			}

			unless ($list->am_i('privileged_owner',$sender)|| $list->am_i('owner',$sender)||$list->am_i('editor', $sender)||Sympa::List::is_listmaster($sender,$list->{'domain'} )){
				# if not list owner or list editor or listmaster,n check if sender of remove order is sender of the message to remove

				my $new_message = Sympa::Message->new(
					file       => "$arcpath/arctxt/$message",
					noxsympato => 'noxsympato'
				);
				unless ($new_message) {
					Sympa::Log::Syslog::do_log('err',"unable to load new message $arcpath/arctxt/$message");
					next;
				}
				my $messagesender = lc($new_message->{'sender'});

				unless ($sender == $messagesender) {
					Sympa::Log::Syslog::do_log('err', 'remove command by unauthorized sender');
					next;
				}
			}
			# this point : requested command is from a authorized personn (message sender or list admin or listmaster
			remove($arclistdir,$msgid);

			my $url_dir = $list->{'dir'}.'/urlized/'.$msgid;
			Sympa::Tools::File::remove_dir ($url_dir);

			unless (-d "$arcpath/deleted"){
				unless (mkdir ("$arcpath/deleted",0777)) {
					Sympa::Log::Syslog::do_log('info',"remove_arc: unable to create $arcpath/deleted : $ERRNO");
					last;
				}
			}

			unless (rename ("$arcpath/arctxt/$message","$arcpath/deleted/$message")) {
				Sympa::Log::Syslog::do_log('info',"remove_arc: unable to rename message $arcpath/arctxt/$message");
				next;
			}

			# remove directory if empty arctxt
			unless (opendir (DIR,"$arcpath/arctxt")) {
				Sympa::Log::Syslog::do_log('info',"remove_arc: unable to open dir $arcpath/arctxt");
				next;
			}
			my @files = grep(/^\d+$/, readdir( DIR ));
			closedir (DIR);
			if ($#files == -1) {
				Sympa::Tools::File::remove_dir ($arcpath);
			}
		}
		$spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}});
	} else {
		Sympa::Log::Syslog::do_log('notice',"Archiving message %s for list %s@%s",$item->{'messagekey'},$item->{'list'},$item->{'robot'});
		unless (mail2arc ($item)) {
			$spoolarchive->update({'messagekey'=>$item->{'messagekey'}},{'message_status'=>'bad','message_diag'=>'unable to rebuild archive for unkown list','lockdate'=>'NULL'});
			Sympa::Log::Syslog::do_log('err',"archiving_failed for message %s",$item->{'messagekey'});
			unless (Sympa::List::send_notify_to_listmaster('archiving_failed',$item->{'robot'})) {
				Sympa::Log::Syslog::do_log('notice',"Unable to send notify 'archiving_failed' to listmaster");
			}
		}
		unless ($spoolarchive->remove_message({'messagekey'=>$item->{'messagekey'}})){
			Sympa::Log::Syslog::do_log ('err',"Couldn't remove message in archive spool %s . exiting to prevent infinite loop",$item->{'messagekey'});
			last;
		}
	}
}

Sympa::List::send_notify_to_listmaster(undef, undef, undef, undef, 1); # Purge grouped notifications

Sympa::Log::Syslog::do_log('notice', 'archived exited normally due to signal');
Sympa::Tools::Daemon::remove_pid(
	file    => $wwsconf->{'archived_pidfile'},
	file    => $PID,
	options => undef,
	tmpdir  => $Sympa::Configuration::Conf{'tmpdir'}
);

exit(0);

# When we catch SIGTERM, just change the value of the loop # variable
sub sigterm {
	$end = 1;
}

# Removes a message from a list.
#
# Parameters:
# * $adrlist: the list name
# * $msgid: the message identifier
sub remove {
	my $adrlist = shift;
	my $msgid = shift;
	my $robot = shift;

	Sympa::Log::Syslog::do_log ('debug',"remove ($adrlist, $msgid)");
	my $arc ;

	if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
		$adrlist = $1;
		$arc = $2;
	}

	Sympa::Log::Syslog::do_log('notice',"Removing $msgid in list $adrlist section $2");

	Sympa::Log::Database::do_stat_log({'robot' => $robot, 'list' => $adrlist, 'operation' => 'remove archive', 'parameter' => '', 'mail' => 'test@cru.fr','client' => $ip, 'daemon' => $daemon_name});

	my $result = Sympa::Log::Database::do_log(
		robot        => $robot,
		list         => $adrlist,
		action       => 'remove',
		parameters   => $msgid.','.$adrlist,
		target_email => '',
		msg_id       => $msgid,
		status       => 'succes',
		error_type   => '',
		user_email   => '',
		client       => $ip,
		daemon       => $daemon_name
	);
	unless ($result) {
		Sympa::Log::Syslog::do_log('error','archived::remove: unable to log event');
	}
	my $arcpath = Sympa::Configuration::get_robot_conf($robot,'arc_path');
	$arc =~ /^(\d{4})-(\d{2})$/ ;
	my $yyyy = $1 ;
	my $mm = $2 ;

	$msgid =~ s/\$/\\\$/g;
	system "$wwsconf->{'mhonarc'}  -outdir $arcpath/$adrlist/$yyyy-$mm -rmm $msgid";
}

# Rebuilds archives for a list
#
# Parameters:
# * $adrlist: a string containing the name of the list the archives of which we want to rebuild.

# Return value:
# undef if something goes wrong.
sub rebuild {

	my $adrlist = shift;
	my $arc ;

	Sympa::Log::Syslog::do_log ('debug2',"rebuild ($adrlist)");

	if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
		$adrlist = $1;
		$arc = $2;
	}

	my ($listname, $hostname);
	if ($adrlist =~ /^(.*)\@(.*)$/) {
		$listname = $1;
		$hostname = $2;
	} else {
		Sympa::Log::Syslog::do_log('err',"Match of list address '$adrlist' failed");
		return undef;
	}

	my $tag = get_tag($listname);

	my $list = Sympa::List->new(name => $listname, robot => $hostname);
	my $robot = $list->{'domain'};
	my $arcpath = Sympa::Configuration::get_robot_conf($robot,'arc_path');
	Sympa::Log::Syslog::do_log('debug',"Rebuilding $adrlist archive ($2)");

	my $mhonarc_ressources = Sympa::Tools::get_filename('etc',{},'mhonarc-ressources.tt2',$list->{'domain'}, $list, $Sympa::Configuration::Conf{'etc'});

	if (($list->{'admin'}{'web_archive_spam_protection'} ne 'none') && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
		set_hidden_mode($tag);
	} else {
		unset_hidden_mode();
	}

	Sympa::Log::Syslog::do_log('notice',"Rebuilding  $arc with M2H_ADDRESSMODIFYCODE : %s",$ENV{'M2H_ADDRESSMODIFYCODE'});

	if ($arc) {
		Sympa::Log::Syslog::do_log('notice',"Rebuilding  $arc of $adrlist archive");
		$arc =~ /^(\d{4})-(\d{2})$/ ;
		my $yyyy = $1 ;
		my $mm = $2 ;

		# remove empty directory
		my $arcdir = $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm ;
		my $arctxt = $arcdir.'/arctxt' ;
		if (opendir (DIR,$arctxt)) {
			my @files = (grep(/^\d+$/,(readdir DIR )));
			close (DIR);
			if ($#files == -1) {
				Sympa::Log::Syslog::do_log('notice', "Removing empty directory $arcdir");
				Sympa::Tools::File::remove_dir ($arcdir);
				next ;
			}

			## index file was removed ; recreate it
			my $index = $files[$#files];
			save_idx($arcdir.'/index', $index+1);
		}

		## recreate index file if needed
		unless (-f $arcdir.'/index') {
			create_idx($arcdir);
		}

		## Remove .mhonarc.db
		unlink $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm.'/.mhonarc.db';

		## Remove existing HTML files
		opendir HTML, "$arcpath/$adrlist/$yyyy-$mm";

		## Skip arctxt/ . and ..
		foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
			unlink $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm.'/'.$html_file;
		}
		closedir HTML;

		my $arcs_dir = Sympa::Archive::clean_archive_directory(
			'arc_root'       => $wwsconf->{'arc_path'},
			'dir_to_rebuild' => "/$adrlist/$arc/arctxt",
			'tmpdir'         => $Sympa::Configuration::Conf{'tmpdir'},
		);
		my $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'} if($arcs_dir);

		my $cmd = "$wwsconf->{'mhonarc'} -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\' -rcfile $mhonarc_ressources -outdir $arcpath/$adrlist/$yyyy-$mm  -definevars \"listname='$listname' hostname=$hostname yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$arcpath base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} $dir_to_rebuild";

		Sympa::Log::Syslog::do_log('debug',"System call : $cmd");
		my $exitcode = system($cmd);
		$exitcode = $exitcode / 256;

		# Delete temporary directory containing files with escaped HTML.
		if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
			Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
		}

		## Remove lock if required
		if ($exitcode == 75) {
			Sympa::Log::Syslog::do_log('notice', 'Removing lock directory %s', $arcpath.'/'.$adrlist.'/'.$arc.'/.mhonarc.lck');
			rmdir $arcpath.'/'.$adrlist.'/'.$arc.'/.mhonarc.lck';

			$exitcode= system($cmd);
			$exitcode = $exitcode / 256;
		}

		if ($exitcode) {
			Sympa::Log::Syslog::do_log('err',"Command $cmd failed with exit code $exitcode");
		}
	} else {
		Sympa::Log::Syslog::do_log('notice',"Rebuilding $adrlist archive completely");

		if (!opendir(DIR, "$arcpath/$adrlist" )) {
			Sympa::Log::Syslog::do_log('err',"unable to open $arcpath/$adrlist to rebuild archive");
			return ;
		}
		my @archives = (grep (/^\d{4}-\d{2}/, readdir(DIR)));
		close DIR ;

		foreach my $arc (@archives) {
			$arc =~ /^(\d{4})-(\d{2})$/ ;
			my $yyyy = $1 ;
			my $mm = $2 ;

			my $arcdir = $arcpath.'/'.$adrlist.'/'.$yyyy.'-'.$mm;

			## Remove .mhonarc.db
			unlink $arcdir.'/.mhonarc.db';

			## Remove existing HTML files
			opendir HTML, $arcdir;
			## Skip arctxt/ . and ..
			foreach my $html_file (grep !/^arctxt$|^index$|\.+$/, readdir(HTML)) {
				unlink $arcdir.'/'.$html_file;
			}
			closedir HTML;
			my $dir_to_rebuild = "$wwsconf->{'arc_path'}/$adrlist/$arc/arctxt";
			my $arcs_dir = Sympa::Archive::clean_archive_directory(
				'arc_root'       => $wwsconf->{'arc_path'},
				'dir_to_rebuild' => "/$adrlist/$arc/arctxt",
				'tmpdir'         => $Sympa::Configuration::Conf{'tmpdir'},
			);
			if($arcs_dir) {
				$dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'};
			}
			## recreate index file if needed
			unless (-f $arcdir.'/index') {
				create_idx($arcdir);
			}

			my $cmd = "$wwsconf->{'mhonarc'} -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\'  -rcfile $mhonarc_ressources -outdir $arcdir  -definevars \"listname=$listname hostname=$hostname yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$arcpath base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} $dir_to_rebuild";
			my $exitcode = system($cmd);
			$exitcode = $exitcode / 256;

			# Delete temporary directory containing files with escaped HTML.
			if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
				Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
			}

			## Remove lock if required
			if ($exitcode == 75) {
				Sympa::Log::Syslog::do_log('notice', 'Removing lock directory %s', $arcdir.'/.mhonarc.lck');
				rmdir $arcdir.'/.mhonarc.lck';

				$exitcode = system($cmd);
				$exitcode = $exitcode / 256;
			}
			if ($exitcode) {
				Sympa::Log::Syslog::do_log('err',"Command $cmd failed with exit code $exitcode");
			}

		}
	}
}


# Archives one message into one list archives directory.
#
# Parameters:
# * $file: a string containing the message filename.
# * $listname: a string containing the name of the list in which to archive the message
# * $hostname: a string containing the name of the virtual robot hosting the list.
# * $yyyy: a string containing the year of the date when the message is archived (i.e. now)
# * $mm: a string containing the month of the date when the message is archived (i.e. now)
# * $dd: a string containing the day of the date when the message is archived (i.e. now)
# * $hh: a string containing the hour of the date when the message is archived (i.e. now)
# * $min: a string containing the minute of the date when the message is archived (i.e. now)
# * $ss: a string containing the second of the date when the message is archived (i.e. now)
#
# Return value:
# undef if something goes wrong.
sub mail2arc {

	my $message_in_spool = shift;

	my $listname = $message_in_spool->{'list'};
	my $robot = $message_in_spool->{'robot'};
	my ($yyyy, $mm, $dd, $hh, $min, $ss) = @_;
	my $txtdate = Sympa::Tools::Time::epoch2yyyymmjj_hhmmss ($message_in_spool->{'date'});
	if ($txtdate =~ /(\d\d\d\d)\-(\d\d)\-(\d\d)\s*(\d\d)\:(\d\d)/){
		$yyyy = $1; $mm = $2; $dd = $3; $hh = $4; $min = $5; $ss = $6;
	} else {
		Sympa::Log::Syslog::do_log('err',"could not scan date");
		return undef;
	}

	my $newfile;

	my $list = Sympa::List->new(name => $listname, robot => $robot);
	my $arcpath = Sympa::Configuration::get_robot_conf($list->{'domain'},'arc_path');

	unless (defined $list) {
		Sympa::Log::Syslog::do_log('err', 'Unknown list %s@%s', $listname, $robot);
		return undef;
	}

	my $tag = get_tag($listname);

	if (($list->{'admin'}{'web_archive_spam_protection'} ne 'none') && ($list->{'admin'}{'web_archive_spam_protection'} ne 'cookie')) {
		set_hidden_mode($tag);
	} else {
		unset_hidden_mode();
	}

	Sympa::Log::Syslog::do_log('debug',"mail2arc  for %s yyyy:$yyyy, mm:$mm dd:$dd hh:$hh min$min ss:$ss", $list->get_list_id());
	#    chdir($wwsconf->{'arc_path'});


	if ($wwsconf->{'custom_archiver'}) {
		my $file = $Sympa::Configuration::Conf{'tmpdir'}."/arc.".$listname.'@'.$robot.'.'.$message_in_spool->{'messagekey'} ;
		open (DUMP, "> $file");
		printf DUMP $message_in_spool->{'messageasstring'};
		`$wwsconf->{'custom_archiver'} --list=$listname\@$robot --file=$file`;
		return 1;
	} else {
		my $basedir = $arcpath.'/'.$list->get_list_id();

		if (! -d $basedir) {
			unless (mkdir $basedir, 0775) {
				Sympa::Log::Syslog::do_log('err', 'Cannot create directory %s', $basedir);
				unless (Sympa::List::send_notify_to_listmaster('unable_to_create_dir',$robot,{'dir' => "$basedir"})) {
					Sympa::Log::Syslog::do_log('notice',"Unable to send notify 'unable_to_create_dir' to listmaster");
				}
			}
			Sympa::Log::Syslog::do_log('debug',"mkdir $basedir");
		}

		## Check quota
		if ($list->{'admin'}{'web_archive'}{'quota'}) {
			my $used = $list->get_arc_size("$arcpath") ;

			if ($used >= $list->{'admin'}{'web_archive'}{'quota'} * 1024){
				Sympa::Log::Syslog::do_log('err',"archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}");
				unless ($list->send_notify_to_owner('arc_quota_exceeded',{'size' => $used})) {
					Sympa::Log::Syslog::do_log('notice',"Unable to send notify 'arc_quota_exceeded' to $list->{'name'} owner");
				}
				return undef;
			}
			if ($used >= ($list->{'admin'}{'web_archive'}{'quota'} * 1024 * 0.95)){
				Sympa::Log::Syslog::do_log('err',"archived::mail2arc : web_arc Quota exceeded for list $list->{'name'}");
				unless ($list->send_notify_to_owner('arc_quota_95',{'size' => $used,
							'rate' => int($used * 100 / ($list->{'admin'}{'web_archive'}{'quota'} * 1024 ))})) {
					Sympa::Log::Syslog::do_log('notice',"Unable to send notify 'arc_quota_95' to $list->{'name'} owner");
				}
			}
		}

		my $monthdir = $basedir."/$yyyy-$mm";

		if (! -d $monthdir) {
			unless (mkdir ($monthdir, 0775)) {
				Sympa::Log::Syslog::do_log('err', 'Cannot create directory %s', $monthdir);
				return undef;
			}

			Sympa::Log::Syslog::do_log('debug',"mkdir $arcpath/%s/$yyyy-$mm", $list->get_list_id());

			if ($list->{'admin'}{'web_archive'}{'max_month'}){ # maybe need to remove some old archive
				if (opendir DIR,$arcpath.'/'.$list->get_list_id()) {
					my @archives = (sort {$a cmp $b} grep (/^\d{4}-\d{2}/, readdir(DIR)));
					closedir DIR;
					my $nb_month = $#archives + 1 ;
					my $i = 0 ;
					while ( $nb_month >  $list->{'admin'}{'web_archive'}{'max_month'}) {
						Sympa::Log::Syslog::do_log('info',"removing  $arcpath/%s/$archives[$i]", $list->get_list_id());
						Sympa::Tools::File::remove_dir ($arcpath.'/'.$list->get_list_id().'/'.$archives[$i]);
						$i ++; $nb_month --;
					}
				}
			}
		}

		my $arctxtdir = $monthdir."/arctxt";

		if (! -d $arctxtdir) {
			unless (mkdir ($arctxtdir, 0775)) {
				Sympa::Log::Syslog::do_log('err', 'Cannot create directory %s', $arctxtdir);
				return undef;
			}
			Sympa::Log::Syslog::do_log('debug',"mkdir $arctxtdir");
		}

		## fetch next message number in archive arctxt .
		if( -f $monthdir."/index" ){
			open(IDX,"<$monthdir/index") || Sympa::Log::Syslog::fatal_err("couldn't read index for $listname");
			$newfile = <IDX>;
			chomp($newfile);
			$newfile++;
			close IDX;
		} else {
			## recreate index file if needed and update it
			$newfile = create_idx($monthdir) + 1;
		}

		# savee arctxt dump of original message.
		my $file = $monthdir.'/arctxt/'.$newfile ;
		my $output = $Sympa::Configuration::Conf{'tmpdir'}.'/arc'.$newfile;
		open (DUMP, "> $file");
		printf DUMP $message_in_spool->{'messageasstring'};
		close DUMP;


		# prepare a temporary file with clean message content (htlm parts are cleaned)
		my $safe = Sympa::Archive::clean_archived_message(
			'input'  => $file,
			'output' => $output
		);
		unless ($safe) {
			Sympa::Log::Syslog::do_log('err',"Could not clean message, ignoring message");
			next;
		}

		my $mhonarc_ressources = Sympa::Tools::get_filename('etc',{},'mhonarc-ressources.tt2',$list->{'domain'}, $list, $Sympa::Configuration::Conf{'etc'});

		Sympa::Log::Syslog::do_log ('debug',"calling $wwsconf->{'mhonarc'} for list %s", $list->get_list_id() ) ;

		# call mhonarc on cleaned message source to make clean htlm view of message
		my $cmd = "$wwsconf->{'mhonarc'} -add -modifybodyaddresses -addressmodifycode \'$ENV{'M2H_ADDRESSMODIFYCODE'}\'  -rcfile $mhonarc_ressources -outdir $monthdir  -definevars \"listname='$listname' hostname=$robot yyyy=$yyyy mois=$mm yyyymm=$yyyy-$mm wdir=$wwsconf->{'arc_path'} base=$Sympa::Configuration::Conf{'wwsympa_url'}/arc tag=$tag\" -umask $Sympa::Configuration::Conf{'umask'} < $output";

		Sympa::Log::Syslog::do_log('debug',"System call : %s",$cmd);

		my $exitcode = system($cmd);
		$exitcode = $exitcode / 256;

		## Remove lock if required
		if ($exitcode == 75) {
			Sympa::Log::Syslog::do_log('notice', 'Removing lock directory %s', $monthdir.'/.mhonarc.lck');
			rmdir $monthdir.'/.mhonarc.lck';

			$exitcode = system($cmd);
			$exitcode = $exitcode / 256;
		}
		if ($exitcode) {
			Sympa::Log::Syslog::do_log('err',"Command $cmd failed with exit code $exitcode");
		}

		save_idx("$monthdir/index",$newfile);
	}
}


# Sets the value of $ENV{'M2H_ADDRESSMODIFYCODE'} and $ENV{'M2H_MODIFYBODYADDRESSES'}
#
# Parameters:
# * $tag: a string (containing the result of get_tag($listname))
sub set_hidden_mode {
	my $tag = shift; ## tag is used as variable elements in tags to prevent message contents to be parsed

	## $ENV{'M2H_MODIFYBODYADDRESSES'} Ã  positionner si le corps du message est parse
	$ENV{'M2H_ADDRESSMODIFYCODE'} = "s|^([^\@]+)\@([^\@]+)\$|\($tag\%hidden_head\%$tag\)\$1\($tag\%hidden_at\%$tag\)\$2\($tag\%hidden_end\%$tag\)|g";
	$ENV{'M2H_MODIFYBODYADDRESSES'} = 1;
}

# Empties $ENV{'M2H_ADDRESSMODIFYCODE'}.
sub unset_hidden_mode {

	## Be carefull, the .mhonarc.db file keeps track of previous M2H_ADDRESSMODIFYCODE setup
	$ENV{'M2H_ADDRESSMODIFYCODE'} = '';
}

# Saves the archives index file
#
# Parameters:
# * $index: a string corresponding to the file name to which save an index.
# * $lst: a string
sub save_idx {
	my ($index,$lst) = @_;
#    Sympa::Log::Syslog::do_log('notice', "save_idx($index,$lst)");

	open(INDEXF,">$index") || Sympa::Log::Syslog::fatal_err("couldn't overwrite index $index");
	print INDEXF "$lst\n";
	close INDEXF;
	#   Sympa::Log::Syslog::do_log('debug',"last arc entry for $index is $lst");
}

# Create the 'index' file for one archive subdir
sub create_idx {
	my $arc_dir = shift; ## corresponds to the yyyy-mm directory

	my $arc_txt_dir = $arc_dir.'/arctxt';

	unless (opendir (DIR, $arc_txt_dir)) {
		Sympa::Log::Syslog::do_log('err', "Failed to open directory '$arc_txt_dir'");
		return undef;
	}

	my @files = (sort { $a <=> $b;}  grep(/^\d+$/,(readdir DIR ))) ;
	my $index = $files[$#files];
	save_idx($arc_dir.'/index', $index);

	closedir DIR;

	return $index;
}

# Returns a tag derived from the list name.
#
# Parameters:
# * $listname: the list name
#
# Return value:
# A string>, corresponding to the 10 last characters of a 32 bytes string containing the MD5 digest of the concatenation of the following strings (in this order):
# * the cookie config parameter
# * a slash: "/"
# * the list name
sub get_tag {
	my $listname = shift;

	return (substr(Digest::MD5::md5_hex(join('/', $Sympa::Configuration::Conf{'cookie'}, $listname)), -10)) ;
}

# Checks if directory exists and we have write and read accec to it.
sub directory_check {
	my $dir = shift;
	unless (-d $dir) {
		printf STDERR "Creating missing %s directory\n", $dir;
		unless (mkdir $dir, 0775) {
			Sympa::Log::Syslog::do_log('err','Unable to create directory %s',$dir);
			return undef;
		}
		unless (Sympa::Tools::File::set_file_rights(file => $dir,
				user  => Sympa::Constants::USER,
				group => Sympa::Constants::GROUP,
				mode  => 0775,
			))
		{
			Sympa::Log::Syslog::do_log('err','Unable to set rights on %s',$dir);
			return undef;
		}
	}
	unless ((-r $dir) && (-w $dir)) {
		Sympa::Log::Syslog::do_log('err', 'Unsufficient access to %s directory', $dir);
		return undef;
	}
	return 1;
}
