#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997-1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997-2011 Comite Reseau des Universites
# Copyright (c) 2011-2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=encoding utf-8

=head1 NAME

archived, archived.pl - Mailing List Archiving Daemon for Sympa

=head1 SYNOPSIS

B<archived.pl>
    S<[ B<-d, --debug> ]>
    S<[ B<-F, --foreground> ]>
    S<[ B<--log-level>=I<level> ]>

B<archived.pl> B<-h, --help>

=head1 DESCRIPTION

B<Archived> is a program which scan permanently the outgoing B<Sympa> spool
and feeds the web archives, converting messages to the HTML format and
linking them. Original mails are also kept (in I<arctxt/> directory> for
later rebuilding of archives.

The HTML conversion is achieved by the means of the B<MHonArc> program.

Archives are accessed via B<wwsympa.fcgi> and B<sympa.pl>,
which proposes access control;
therefore archives should not be located in a public web directory.

=head1 OPTIONS

These programs follow the usual GNU command line syntax,
with long options starting with two dashes (`-').  A summary of
options is included below.

=over 5

=item B<-d>, B<--debug>

Run in debug mode.

=item B<-F>, B<--foreground>

Do not detach from TTY.

=item B<-h>, B<--help>

Print this help message.

=item B<--log_level>=I<level>

Set log level.

=back

=head1 FILES

F<--spooldir--/outgoing/> outgoing Sympa directory.

F<--defaultdir--/mhonarc-ressources.tt2> template of MHonArc resource file.

F<--CONFIG--> Sympa configuration file.

F<--piddir--/archived.pid> this file contains the process ID
of F<archived.pl>.

=head1 MORE DOCUMENTATION

The full documentation in HTML and PDF formats can be found in
L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 AUTHORS

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

Contact authors at <sympa-authors@listes.renater.fr>

This manual page was initially written by
JE<233>rE<244>me Marant <jerome.marant@IDEALX.org>
for the Debian GNU/Linux system.

=head1 COPYRIGHT

Copyright E<169> 1997,1998,1999,2000,2001 ComitE<233> RE<233>seau des UniversitE<233>s

Copyright E<169> 1997,1998,1999 Institut Pasteur & Christophe Wolfhugel

You may distribute this software under the terms of the GNU General
Public License Version 2 (L<http://www.gnu.org/copyleft/gpl.html>)

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license can be found under
L<http://www.gnu.org/licenses/fdl.html>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<bounced(8)>, L<mhonarc(1)>, L<sympa.conf(5)>.

=cut 

use strict;
use warnings;
use lib '--modulesdir--';

use DateTime;
use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;

use Sympa::List;
use Sympa::Log::Database;
use Sympa::Log::Syslog;
use Sympa::Mailer;
use Sympa::Message;
use Sympa::Tools::Daemon;
use Sympa::Tools::File;

my $daemon_name = Sympa::Tools::Daemon::get_daemon_name($0);
my $ip          = $ENV{'REMOTE_HOST'};

my %options;
unless (
    GetOptions(
        \%options,
        'debug|d',
        'foreground|F',
        'help|h',
        'log_level=s',
    )) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($options{'help'}) {
    pod2usage(0);
}

if ($options{'debug'}) {
    $options{'log_level'} = 2 unless ($options{'log_level'});
    $options{'foreground'} = 1;
}

$options{'log_to_stderr'} = 1 if $options{'foreground'};

# Load sympa.conf
unless (defined Sympa::Robot::get_robots()) {
    Sympa::Log::Syslog::fatal_err(
        'Unable to load sympa configuration, file %s has errors.',
        Sympa::Conf::get_sympa_conf());
}

## Check databse connectivity
unless (Sympa::DatabaseManager::check_db_connect()) {
    Sympa::Log::Syslog::fatal_err(
        'Database %s defined in sympa.conf has not the right structure or is unreachable.',
        Sympa::Site->db_name
    );
}

## Put ourselves in background if not in debug mode.
unless ($options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        ioctl(TTY, 0x20007471, 0);
        close(TTY);
    }
    setpgrp(0, 0);
    if ((my $child_pid = fork) != 0) {
        print STDOUT "Starting archive daemon, PID $_\n";

        exit(0);
    }
}

# check presence of a PID file from a previous execution
Sympa::Tools::Daemon::check_old_pid_file(
    name   => 'archived',
    piddir => Sympa::Constants::PIDDIR,
    tmpdir => Sympa::Site->tmpdir(),
);

# Create the PID file
Sympa::Tools::Daemon::write_pid(
    name   => 'archived',
    pid    => $PID,
    piddir => Sympa::Constants::PIDDIR,
    user   => Sympa::Constants::USER,
    group  => Sympa::Constants::GROUP,
);

# Redirect STDERR to a file, unless the process is running in foreground
unless ($options{'foreground'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(
        pid    => $PID,
        tmpdir => Sympa::Site->tmpdir(),
        user   => Sympa::Constants::USER,
        group  => Sympa::Constants::GROUP,
    );
}

# setting log_level using conf unless it is set by calling option
if ($options{'log_level'}) {
    Sympa::Log::Syslog::set_log_level($options{'log_level'});
    Sympa::Log::Syslog::do_log('info',
        "Configuration file read, log level set using options : $options{'log_level'}"
    );
} else {
    Sympa::Log::Syslog::set_log_level(Sympa::Site->log_level);
    Sympa::Log::Syslog::do_log('info',
        'Configuration file read, default log level %s',
        Sympa::Site->log_level);
}

Sympa::Log::Syslog::do_openlog(Sympa::Site->log_facility, Sympa::Site->log_socket_type,
    'archived');

## Set the User ID & Group ID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    Sympa::Log::Syslog::fatal_err(
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo."
    );
}

## Sets the UMASK
umask(oct(Sympa::Site->umask));

foreach my $robot (@{Sympa::Robot::get_robots()}) {
    my $arc_dir = $robot->arc_path;
    ## Create arc_path if required
    if ($arc_dir) {
        unless (directory_check($arc_dir)) {
            Sympa::Log::Syslog::do_log('err',
                'No vailable directory to store archives. Exiting.');
            exit -1;
        }
    } else {
        Sympa::Log::Syslog::do_log('err',
            'Robot %s has no archives directory. Check arc_path parameter in this robot.conf and in sympa.conf.'
        );
        exit -1;
    }
}

## Change to list root
unless (chdir(Sympa::Site->home)) {
    Sympa::Log::Syslog::do_log('err', 'unable to change directory');
    exit(-1);
}

Sympa::Language::SetLang(Sympa::Site->lang || 'en');

Sympa::Log::Syslog::do_log('notice', "archived %s Started",
    Sympa::Constants::VERSION);

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $spoolarchive = Sympa::Spool::File->new('outgoing');

my $mailer = Sympa::Mailer->new(
    db_type         => Sympa::Site->db_type(),
    nrcpt_by_domain => Sympa::Site->nrcpt_by_domain(),
);

## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {

    Sympa::List::init_list_cache();
    sleep 1;
    my $item = $spoolarchive->next;

    next unless $item;

    my @orders = split(/\n/, $item->{'messageasstring'});

    unless ($item->{'messageasstring'}) {
        $spoolarchive->move_to_bad($item->{'messagekey'});
        next;
    }

    if ($orders[0] =~ /^rebuild\s*$/) {
        Sympa::Log::Syslog::do_log('debug', "rebuild found ");
        if ($item->{'list'} && $item->{'robot'}) {
            rebuild($item->{'list'} . '@' . $item->{'robot'});
            $spoolarchive->remove_message($item->{'messagekey'});
        } else {
            Sympa::Log::Syslog::do_log('err',
                "unable to rebuild archive for unknown list/robot.Move to bad"
            );
            $spoolarchive->move_to_bad($item->{'messagekey'});
            next;
        }
    } elsif ($orders[0] =~ /^remove\.(\d\d\d\d\-\d\d)\.\d+$/) {
        my $yyyymm = $1;
        shift @orders;
        Sympa::Log::Syslog::do_log('debug', "removed found ");
        unless ($item->{'list'} && $item->{'robot'}) {
            Sympa::Log::Syslog::do_log('err',
                "unable to remove messages from archive for unknown list/robot.Move to bad"
            );
            $spoolarchive->move_to_bad($item->{'messagekey'});
            next;
        }
        my $listadress = $item->{'list'} . '@' . $item->{'robot'};

        my $arclistdir = $listadress . '.' . $yyyymm;
        my $arcpath    = Sympa::Site->arc_path . "/$listadress/$yyyymm";

        Sympa::Log::Syslog::do_log('debug',
            "start remove process :listadress :'$listadress' arclistdir '$arclistdir' arcpath '$arcpath'  yyyymm '$yyyymm'"
        );

        my $list;
        unless ($list = Sympa::List->new($listadress)) {
            Sympa::Log::Syslog::do_log('err', 'remove: unknown list %s',
                $listadress);
            $spoolarchive->move_to_bad($item->{'messagekey'});
            next;
        }
        Sympa::Log::Syslog::do_log('debug', "remove found : for $arclistdir");

        my $email_regexp = Sympa::Tools::get_regexp('email');

        foreach my $order (@orders) {
            unless ($order =~ /(.*)\|\|($email_regexp)/) {
                Sympa::Log::Syslog::do_log('err',
                    'Ignoring remove_order "%s", unrecognized format',
                    $order);
                next;
            }
            my $msgid  = $1;
            my $sender = $2;

            chomp $msgid;
            if ($msgid =~ /NO-ID-FOUND\.mhonarc\.org/) {
                Sympa::Log::Syslog::do_log('err', 'No message ID found');
                next;
            }

            my $file;
            unless ($file = Sympa::Archive::search_msgid("$arcpath/arctxt", $msgid))
            {
                Sympa::Log::Syslog::do_log('err',
                    'No message with message-id %s found in %s/arctxt',
                    $msgid, $arcpath);
                next;
            }

            unless ($list->am_i('privileged_owner', $sender)
                || $list->am_i('owner',  $sender)
                || $list->am_i('editor', $sender)
                || Sympa::List::is_listmaster($sender, $list->{'domain'})) {

                # if not list owner or list editor or listmaster,n check if
                # sender of remove order is sender of the message to remove

                my $new_message = Sympa::Message->new(
                    'file'       => "$arcpath/arctxt/$file",
                    'noxsympato' => 'noxsympato'
                );

                unless ($new_message) {
                    Sympa::Log::Syslog::do_log('err',
                        'Unable to load new message %s/arctxt/%s',
                        $arcpath, $file);
                    next;
                }
                my $messagesender = lc($new_message->get_sender_email || '');

                unless ($sender eq $messagesender) {
                    Sympa::Log::Syslog::do_log('err',
                        'Remove command by unauthorized sender');
                    next;
                }
            }

            # this point : requested command is from a authorized personn
            # (message sender or list admin or listmaster
            remove($arclistdir, $msgid);

            my $url_dir = $list->dir . '/urlized/' . $msgid;
            Sympa::Tools::File::remove_dir($url_dir);

            unless (-d "$arcpath/deleted") {
                unless (mkdir("$arcpath/deleted", 0777)) {
                    Sympa::Log::Syslog::do_log('info',
                        "remove_arc: unable to create $arcpath/deleted : $ERRNO");
                    last;
                }
            }

            unless (rename "$arcpath/arctxt/$file", "$arcpath/deleted/$file")
            {
                Sympa::Log::Syslog::do_log('info',
                    'Unable to rename message %s/arctxt/%s',
                    $arcpath, $file);
                next;
            }

            # remove directory if empty arctxt
            unless (opendir(DIR, "$arcpath/arctxt")) {
                Sympa::Log::Syslog::do_log('info',
                    'Unable to open dir %s/arctxt', $arcpath);
                next;
            }
            my @files = grep(/^\d+$/, readdir(DIR));
            closedir(DIR);
            if ($#files == -1) {
                Sympa::Tools::File::remove_dir($arcpath);
            }
        }
        $spoolarchive->remove_message($item->{'messagekey'});
    } else {
        Sympa::Log::Syslog::do_log('notice',
            'Archiving message %s for list %s@%s',
            $item->{'messagekey'}, $item->{'list'}, $item->{'robot'});
        unless (mail2arc($item)) {
            $spoolarchive->move_to_bad($item->{'messagekey'});
            Sympa::Log::Syslog::do_log('err',
                'archiving_failed for message %s',
                $item->{'messagekey'});
            unless ($item->{'robot_object'}
                and $item->{'robot_object'}
                ->send_notify_to_listmaster('archiving_failed')
                or !$item->{'robot_object'}
                and Sympa::Site->send_notify_to_listmaster('archiving_failed')) {
                Sympa::Log::Syslog::do_log('notice',
                    "Unable to send notify 'archiving_failed' to listmaster");
            }
        }
        unless ($spoolarchive->remove_message($item->{'messagekey'})) {
            Sympa::Log::Syslog::do_log(
                'err',
                "Couldn't remove message in archive spool %s. exiting to prevent infinite loop",
                $item->{'messagekey'}
            );
            last;
        }
    }
}

# Purge grouped notifications
Sympa::Site->send_notify_to_listmaster(undef, undef, undef, 1);

## Free zombie sendmail processes
$mailer->reaper();

Sympa::Log::Syslog::do_log('notice',
    'archived exited normally due to signal');
Sympa::Tools::Daemon::remove_pid(
    name   => 'archived',
    pid    => $PID,
    piddir => Sympa::Constants::PIDDIR,
    tmpdir => Sympa::Site->tmpdir(),
);

exit(0);

## When we catch SIGTERM, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

# remove($listname, $msgid, $robotname)
# Removes the message having the identifier $msgid from the list named $adrlist.
# Arguments:
# * $listname: the list name
# * $msgid: the message identifier
# * $robotname: the robot name
sub remove {
    my $adrlist = shift;
    my $msgid   = shift;
    my $robot   = shift;

    Sympa::Log::Syslog::do_log('debug', "remove ($adrlist, $msgid)");
    my $arc;

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
        $adrlist = $1;
        $arc     = $2;
    }

    Sympa::Log::Syslog::do_log('notice', 'Removing %s in list %s section %s',
        $msgid, $adrlist, $arc);

    Sympa::Log::Syslog::db_stat_log(
        {   'robot'     => $robot,
            'list'      => $adrlist,
            'operation' => 'remove archive',
            'parameter' => '',
            'mail'      => 'test@cru.fr',
            'client'    => $ip,
            'daemon'    => $daemon_name
        }
    );

    unless (
        Sympa::Log::Database::db_log(
            {   'robot'        => $robot,
                'list'         => $adrlist,
                'action'       => 'remove',
                'parameters'   => $msgid . ',' . $adrlist,
                'target_email' => '',
                'msg_id'       => $msgid,
                'status'       => 'succes',
                'error_type'   => '',
                'user_email'   => '',
                'client'       => $ip,
                'daemon'       => $daemon_name
            }
        )
        ) {
        Sympa::Log::Syslog::do_log('error',
            'archived::remove: unable to log event');
    }
    my $arcpath = Sympa::Conf::get_robot_conf($robot, 'arc_path');
    $arc =~ /^(\d{4})-(\d{2})$/;
    my $yyyy = $1;
    my $mm   = $2;

    $msgid =~ s/\$/\\\$/g;
    system Sympa::Site->mhonarc
        . "  -outdir $arcpath/$adrlist/$yyyy-$mm -rmm $msgid";
}

# rebuild($listname)
# Rebuilds archives for the list the name of which is given in the argument $adrlist.
# Arguments:
# * $listname: the list name
sub rebuild {
    my $adrlist = shift;
    my $arc;

    Sympa::Log::Syslog::do_log('debug2', "rebuild ($adrlist)");

    if ($adrlist =~ /^(.*)\.(\d{4}-\d{2})$/) {
        $adrlist = $1;
        $arc     = $2;
    }

    my ($listname, $hostname);
    if ($adrlist =~ /^(.*)\@(.*)$/) {
        $listname = $1;
        $hostname = $2;
    } else {
        Sympa::Log::Syslog::do_log('err',
            "Match of list address '$adrlist' failed");
        return undef;
    }

    my $list    = Sympa::List->new($listname, $hostname);
    my $robot   = $list->robot;
    my $arcpath = $robot->arc_path;
    my $tag     = Sympa::Archive::get_tag($list);
    Sympa::Log::Syslog::do_log('debug3', "Rebuilding %s archive (%s)",
        $adrlist, $2);

    my $mhonarc_ressources =
        $list->get_etc_filename('mhonarc-ressources.tt2');

    if (    $list->web_archive_spam_protection ne 'none'
        and $list->web_archive_spam_protection ne 'cookie') {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    Sympa::Log::Syslog::do_log('notice',
        "Rebuilding %s with M2H_ADDRESSMODIFYCODE : %s",
        $arc, $ENV{'M2H_ADDRESSMODIFYCODE'});

    if ($arc) {
        Sympa::Log::Syslog::do_log('notice', "Rebuilding %s of %s archive",
            $arc, $adrlist);
        $arc =~ /^(\d{4})-(\d{2})$/;
        my $yyyy = $1;
        my $mm   = $2;

        # remove empty directory
        my $arcdir = $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm;
        my $arctxt = $arcdir . '/arctxt';
        if (opendir(DIR, $arctxt)) {
            my @files = (grep(/^\d+$/, (readdir DIR)));
            close(DIR);
            if ($#files == -1) {
                Sympa::Log::Syslog::do_log('notice',
                    "Removing empty directory %s", $arcdir);
                Sympa::Tools::File::remove_dir($arcdir);
                next;
            }

            ## index file was removed ; recreate it
            my $index = $files[$#files];
            save_idx($arcdir . '/index', $index + 1);
        }

        ## recreate index file if needed
        unless (-f $arcdir . '/index') {
            create_idx($arcdir);
        }

        ## Remove .mhonarc.db
        unlink $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm
            . '/.mhonarc.db';

        ## Remove existing HTML files
        opendir HTML, "$arcpath/$adrlist/$yyyy-$mm";

        ## Skip arctxt/ . and ..
        foreach my $html_file (grep !/^arctxt$OUTPUT_AUTOFLUSH^index$OUTPUT_AUTOFLUSH\.+$/, readdir(HTML)) {
            unlink $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm . '/'
                . $html_file;
        }
        closedir HTML;

        my $arcs_dir =
            Sympa::Archive::clean_archive_directory($robot, "/$adrlist/$arc/arctxt");
        my $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'} if ($arcs_dir);

        my $cmd =
            sprintf
            '%s -modifybodyaddresses -addressmodifycode \'%s\' -rcfile %s -outdir %s/%s/%s-%s  -definevars \"listname=\'%s\' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s\" -umask %s %s',
            Sympa::Site->mhonarc, $ENV{'M2H_ADDRESSMODIFYCODE'},
            $mhonarc_ressources, $arcpath, $adrlist, $yyyy, $mm,
            $listname, $hostname, $yyyy, $mm, $yyyy, $mm, $arcpath,
            $robot->wwsympa_url, $tag, Sympa::Site->umask, $dir_to_rebuild;

        Sympa::Log::Syslog::do_log('debug', "System call : $cmd");
        my $exitcode = system($cmd);
        $exitcode = $exitcode >> 8;

        # Delete temporary directory containing files with escaped HTML.
        if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
            Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
        }

        ## Remove lock if required
        if ($exitcode == 75) {
            Sympa::Log::Syslog::do_log(
                'notice',
                'Removing lock directory %s',
                $arcpath . '/' . $adrlist . '/' . $arc . '/.mhonarc.lck'
            );
            rmdir $arcpath . '/' . $adrlist . '/' . $arc . '/.mhonarc.lck';

            $exitcode = system($cmd);
            $exitcode = $exitcode >> 8;
        }

        if ($exitcode) {
            Sympa::Log::Syslog::do_log('err',
                "Command $cmd failed with exit code $exitcode");
        }
    } else {
        Sympa::Log::Syslog::do_log('notice',
            "Rebuilding $adrlist archive completely");

        if (!opendir(DIR, "$arcpath/$adrlist")) {
            if (-d "$arcpath/$adrlist") {
                Sympa::Log::Syslog::do_log('err',
                    "unable to open $arcpath/$adrlist to rebuild archive");
                return undef;
            } else {
                Sympa::Log::Syslog::do_log('err',
                    "No archives found for list $adrlist (looked for in $arcpath/$adrlist)"
                );
                return 0;
            }
        }
        my @archives = (grep (/^\d{4}-\d{2}/, readdir(DIR)));
        close DIR;

        foreach my $arc (@archives) {
            $arc =~ /^(\d{4})-(\d{2})$/;
            my $yyyy = $1;
            my $mm   = $2;

            my $arcdir = $arcpath . '/' . $adrlist . '/' . $yyyy . '-' . $mm;

            ## Remove .mhonarc.db
            unlink $arcdir . '/.mhonarc.db';

            ## Remove existing HTML files
            opendir HTML, $arcdir;
            ## Skip arctxt/ . and ..
            foreach
                my $html_file (grep !/^arctxt$OUTPUT_AUTOFLUSH^index$OUTPUT_AUTOFLUSH\.+$/, readdir(HTML)) {
                unlink $arcdir . '/' . $html_file;
            }
            closedir HTML;
            my $dir_to_rebuild = $robot->arc_path . "/$adrlist/$arc/arctxt";
            my $arcs_dir       = Sympa::Archive::clean_archive_directory($robot,
                "/$adrlist/$arc/arctxt");
            if ($arcs_dir) {
                $dir_to_rebuild = $arcs_dir->{'dir_to_rebuild'};
            }
            ## recreate index file if needed
            unless (-f $arcdir . '/index') {
                create_idx($arcdir);
            }

            my $cmd =
                sprintf
                '%s -modifybodyaddresses -addressmodifycode \'%s\' -rcfile %s -outdir %s -definevars \"listname=%s hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s\" -umask %s %s',
                Sympa::Site->mhonarc, $ENV{'M2H_ADDRESSMODIFYCODE'},
                $mhonarc_ressources, $arcdir, $listname, $hostname,
                $yyyy, $mm, $yyyy, $mm, $arcpath, $robot->wwsympa_url,
                $tag, Sympa::Site->umask, $dir_to_rebuild;
            my $exitcode = system($cmd);
            $exitcode = $exitcode >> 8;

            # Delete temporary directory containing files with escaped HTML.
            if ($arcs_dir && -d $arcs_dir->{'cleaned_dir'}) {
                Sympa::Tools::File::del_dir($arcs_dir->{'cleaned_dir'});
            }

            ## Remove lock if required
            if ($exitcode == 75) {
                Sympa::Log::Syslog::do_log(
                    'notice',
                    'Removing lock directory %s',
                    $arcdir . '/.mhonarc.lck'
                );
                rmdir $arcdir . '/.mhonarc.lck';

                $exitcode = system($cmd);
                $exitcode = $exitcode >> 8;
            }
            if ($exitcode) {
                Sympa::Log::Syslog::do_log('err',
                    "Command $cmd failed with exit code $exitcode");
            }

        }
    }
}

# mail2arc($message)
# Archives one message into one list archives directory.
# Arguments:
# * $message: the message
sub mail2arc {
    my ($message) = @_;

    my $list  = $message->{'list_object'};
    my $robot = $message->{'robot_object'};

    my $dt = DateTime->from_epoch(epoch => $message->{'date'});
    my $yyyy = $dt->year();
    my $mm   = $dt->month();

    my $newfile;

    my $arcpath = $robot->arc_path;

    unless (ref $list and $list->isa('Sympa::List')) {
        Sympa::Log::Syslog::do_log(
            'err',
            'Unknown list %s',
            $message->{'list'}
        );
        return undef;
    }

    my $tag = Sympa::Archive::get_tag($list);

    if (    $list->web_archive_spam_protection ne 'none'
        and $list->web_archive_spam_protection ne 'cookie') {
        set_hidden_mode($tag);
    } else {
        unset_hidden_mode();
    }

    if (Sympa::Site->custom_archiver) {
        my $file =
              Sympa::Site->tmpdir . "/arc."
            . $list->get_id
            . $message->{'messagekey'};
        open DUMP, '>', $file;
        print DUMP $message->{'messageasstring'};
        my $cmd = sprintf '%s --list=%s --file=%s', Sympa::Site->custom_archiver,
            $list->get_id, $file;
        `$cmd`;
        return 1;
    } else {
        my $basedir = $arcpath . '/' . $list->get_id;

        if (!-d $basedir) {
            unless (mkdir $basedir, 0775) {
                Sympa::Log::Syslog::do_log('err',
                    'Cannot create directory %s', $basedir);
                unless (
                    $robot->send_notify_to_listmaster(
                        'unable_to_create_dir', {'dir' => "$basedir"}
                    )
                    ) {
                    Sympa::Log::Syslog::do_log('notice',
                        'Unable to send notify "unable_to_create_dir" to listmaster'
                    );
                }
            }
        }

        ## Check quota
        if ($list->web_archive->{'quota'}) {
            my $used = $list->get_arc_size("$arcpath");

            if ($used >= $list->web_archive->{'quota'} * 1024) {
                Sympa::Log::Syslog::do_log(
                    'err',
                    'archived::mail2arc : web_arc Quota exceeded for list %s',
                    $list
                );
                unless (
                    $list->send_notify_to_owner(
                        'arc_quota_exceeded', {'size' => $used}
                    )
                    ) {
                    Sympa::Log::Syslog::do_log(
                        'notice',
                        'Unable to send notify "arc_quota_exceeded" to %s owner',
                        $list
                    );
                }
                return undef;
            }
            if ($used >= ($list->web_archive->{'quota'} * 1024 * 0.95)) {
                Sympa::Log::Syslog::do_log(
                    'err',
                    'archived::mail2arc : web_arc Quota exceeded for list %s',
                    $list
                );
                unless (
                    $list->send_notify_to_owner(
                        'arc_quota_95',
                        {   'size' => $used,
                            'rate' => int(
                                $used * 100 /
                                    ($list->web_archive->{'quota'} * 1024)
                            )
                        }
                    )
                    ) {
                    Sympa::Log::Syslog::do_log('notice',
                        'Unable to send notify "arc_quota_95" to %s owner',
                        $list);
                }
            }
        }

        my $monthdir = $basedir . "/$yyyy-$mm";

        if (!-d $monthdir) {
            unless (mkdir($monthdir, 0775)) {
                Sympa::Log::Syslog::do_log('err',
                    'Cannot create directory %s', $monthdir);
                return undef;
            }

            if ($list->web_archive->{'max_month'}) {

                # maybe need to remove some old archive
                if (opendir DIR, $arcpath . '/' . $list->get_id) {
                    my @archives = (
                        sort { $a cmp $b }
                        grep (/^\d{4}-\d{2}/, readdir(DIR))
                    );
                    closedir DIR;
                    my $nb_month = $#archives + 1;
                    my $i        = 0;
                    while ($nb_month > $list->web_archive->{'max_month'}) {
                        Sympa::Log::Syslog::do_log('info',
                            'removing  %s/%s/%s',
                            $arcpath, $list->get_id, $archives[$i]);
                        Sympa::Tools::File::remove_dir($arcpath . '/'
                                . $list->get_id . '/'
                                . $archives[$i]);
                        $i++;
                        $nb_month--;
                    }
                }
            }
        }

        my $arctxtdir = $monthdir . "/arctxt";

        if (!-d $arctxtdir) {
            unless (mkdir($arctxtdir, 0775)) {
                Sympa::Log::Syslog::do_log('err',
                    'Cannot create directory %s', $arctxtdir);
                return undef;
            }
        }

        ## fetch next message number in archive arctxt .
        if (-f $monthdir . "/index") {
            open(IDX, '<', "$monthdir/index")
                or Sympa::Log::Syslog::fatal_err("couldn't read index for %s",
                $list->name);
            $newfile = <IDX>;
            chomp($newfile);
            $newfile++;
            close IDX;
        } else {
            ## recreate index file if needed and update it
            $newfile = create_idx($monthdir) + 1;
        }

        # savee arctxt dump of original message.
        my $file   = $monthdir . '/arctxt/' . $newfile;
        my $output = Sympa::Site->tmpdir . '/arc' . $newfile;
        open DUMP, '>', $file;
        print DUMP $message->{'messageasstring'};
        close DUMP;

        # prepare a temporary file with clean message content (htlm parts are
        # cleaned)
        my $safe = Sympa::Archive::clean_archived_message($robot, $file, $output);
        unless ($safe) {
            Sympa::Log::Syslog::do_log('err',
                "Could not clean message, ignoring it");
            return undef;
        }

        my $mhonarc_ressources =
            $list->get_etc_filename('mhonarc-ressources.tt2');

        # call mhonarc on cleaned message source to make clean htlm view of
        # message
        my $cmd = sprintf
            '%s -add -modifybodyaddresses -addressmodifycode \'%s\' -rcfile %s -outdir %s -definevars "listname=\'%s\' hostname=%s yyyy=%s mois=%s yyyymm=%s-%s wdir=%s base=%s/arc tag=%s" -umask %s < %s',
            Sympa::Site->mhonarc, $ENV{'M2H_ADDRESSMODIFYCODE'},
            $mhonarc_ressources, $monthdir, $list->name, $robot->domain,
            $yyyy, $mm, $yyyy, $mm, $robot->arc_path, $robot->wwsympa_url,
            $tag, Sympa::Site->umask, $output;

        my $exitcode = system($cmd);
        $exitcode = $exitcode >> 8;

        ## Remove lock if required
        if ($exitcode == 75) {
            Sympa::Log::Syslog::do_log(
                'notice',
                'Removing lock directory %s',
                $monthdir . '/.mhonarc.lck'
            );
            rmdir $monthdir . '/.mhonarc.lck';

            $exitcode = system($cmd);
            $exitcode = $exitcode >> 8;
        }
        if ($exitcode) {
            Sympa::Log::Syslog::do_log('err',
                "Command $cmd failed with exit code $exitcode");
            return undef;
        }

        save_idx("$monthdir/index", $newfile);
    }
    return 1;
}

# set_hidden_mode($tag)
# Exports M2H_ADDRESSMODIFYCODE and M2H_MODIFYBODYADDRESSES environment variables
# Arguments:
# * $tag: a character string
sub set_hidden_mode {
    ## tag is used as variable elements in tags to prevent message contents to
    ## be parsed
    my $tag = shift;

    ## $ENV{'M2H_MODIFYBODYADDRESSES'} à positionner si le corps du message
    ## est parse
    $ENV{'M2H_ADDRESSMODIFYCODE'} =
        "s|^([^\@]+)\@([^\@]+)\$OUTPUT_AUTOFLUSH\($tag\%hidden_head\%$tag\)\$1\($tag\%hidden_at\%$tag\)\$2\($tag\%hidden_end\%$tag\)|g";
    $ENV{'M2H_MODIFYBODYADDRESSES'} = 1;
}

# unset_hidden_mode()
# unset M2H_ADDRESSMODIFYCODE environment variable.
sub unset_hidden_mode {
    ## Be careful, the .mhonarc.db file keeps track of previous
    ## M2H_ADDRESSMODIFYCODE setup
    $ENV{'M2H_ADDRESSMODIFYCODE'} = '';
}

# save_idx($index, $listname)
# Saves the archives index file
# Arguments:
# * $index: the file name
# * $listname: the list name
sub save_idx {
    my ($index, $lst) = @_;

    #    Sympa::Log::Syslog::do_log('notice', "save_idx($index,$lst)");

    open(INDEXF, ">$index")
        || Sympa::Log::Syslog::fatal_err("couldn't overwrite index $index");
    print INDEXF "$lst\n";
    close INDEXF;

    #
    #   Sympa::Log::Syslog::do_log('debug',"last arc entry for $index is $lst");
}

# Create the 'index' file for one archive subdir
sub create_idx {
    my $arc_dir = shift;    ## corresponds to the yyyy-mm directory

    my $arc_txt_dir = $arc_dir . '/arctxt';

    unless (opendir(DIR, $arc_txt_dir)) {
        Sympa::Log::Syslog::do_log('err',
            "Failed to open directory '$arc_txt_dir'");
        return undef;
    }

    my @files = (sort { $a <=> $b; } grep(/^\d+$/, (readdir DIR)));
    my $index = $files[$#files];
    save_idx($arc_dir . '/index', $index);

    closedir DIR;

    return $index;
}

# Checks if directory exists and we have write and read accec to it.
sub directory_check {
    my $dir = shift;
    unless (-d $dir) {
        printf STDERR "Creating missing %s directory\n", $dir;
        unless (mkdir $dir, 0775) {
            Sympa::Log::Syslog::do_log('err', 'Unable to create directory %s',
                $dir);
            return undef;
        }
        unless (
            Sympa::Tools::File::set_file_rights(
                file  => $dir,
                user  => Sympa::Constants::USER,
                group => Sympa::Constants::GROUP,
                mode  => 0775,
            )
            ) {
            Sympa::Log::Syslog::do_log('err', 'Unable to set rights on %s',
                $dir);
            return undef;
        }
    }
    unless ((-r $dir) && (-w $dir)) {
        Sympa::Log::Syslog::do_log('err',
            'Unsufficient access to %s directory', $dir);
        return undef;
    }
    return 1;
}

=head1 AUTHORS 

=over 

=item * Serge Aumont <sa AT cru.fr> 

=item * Olivier SalaE<252>n <os AT cru.fr> 

=back 

=cut 
