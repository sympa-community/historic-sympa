#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014, 2015 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Worl Wide Sympa is a front-end to Sympa Mailing Lists Manager
## Copyright Comite Reseau des Universites

## Patch 2001.07.24 by nablaphi <nablaphi@bigfoot.com>
## Change the Getopt::Std to Getopt::Long

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use English qw(-no_match_vars);
use Getopt::Long;
use IO::Scalar;
use Mail::Address;
use MIME::Head;
use Pod::Usage;
use POSIX qw();

use Sympa::Alarm;
use Conf;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Sympa::List;
use Sympa::LockedFile;
use Log;
use Sympa::Mailer;
use Sympa::Message;
use Sympa::Regexps;
use Sympa::Scenario;
use SDM;
use tools;
use Sympa::Tools::Daemon;
use Sympa::Tools::Data;
use Sympa::Tracking;

## Equivalents relative to RFC 1893
my %equiv = (
    "user unknown"                                                => '5.1.1',
    "receiver not found"                                          => '5.1.1',
    "the recipient name is not recognized"                        => '5.1.1',
    "sorry, no mailbox here by that name"                         => '5.1.1',
    "utilisateur non recens\xE9 dans le carnet d'adresses public" => '5.1.1',
    "unknown address"                                             => '5.1.1',
    "unknown user"                                                => '5.1.1',
    "550"                                                         => '5.1.1',
    "le nom du destinataire n'est pas reconnu"                    => '5.1.1',
    "user not listed in public name & address book"               => '5.1.1',
    "no such address"                                             => '5.1.1',
    "not known at this site."                                     => '5.1.1',
    "user not known"                                              => '5.1.1',

    "user is over the quota. you can try again later." => '4.2.2',
    "quota exceeded"                                   => '4.2.2',
    "write error to mailbox, disk quota exceeded"      => '4.2.2',
    "user mailbox exceeds allowed size"                => '4.2.2',
    "insufficient system storage"                      => '4.2.2',
    "User's Disk Quota Exceeded:"                      => '4.2.2'
);

## Check options
my %options;
unless (
    GetOptions(
        \%main::options, 'config|f=s',   'debug|d', 'help|h',
        'log_level=s',   'foreground|F', 'version|v',
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1
    if ($main::options{'debug'} || $main::options{'foreground'});

my $daemon_name = Log::set_daemon($0);
my $ip          = $ENV{'REMOTE_HOST'};

# Load sympa.conf
unless (Conf::load()) {
    die sprintf
        "Unable to load sympa configuration, file %s has errors.\n",
        Conf::get_sympa_conf();
}

## Check databse connectivity
unless (SDM::check_db_connect()) {
    die sprintf
        "Database %s defined in sympa.conf has not the right structure or is unreachable.\n",
        $Conf::Conf{'db_name'};
}

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        ioctl(TTY, 0x20007471, 0);    # XXX s/b TIOCNOTTY()
        close(TTY);
    }
    setpgrp 0, 0;
    my $child_pid = fork;
    if ($child_pid) {
        Log::do_log('info', 'Starting bounced daemon, PID %s', $child_pid);
        exit 0;
    } elsif (not defined $child_pid) {
        die sprintf 'Cannot fork: %s', $ERRNO;
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the PID file
Sympa::Tools::Daemon::write_pid('bounced', $PID, $options);
unless ($options->{'stderr_to_tty'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(('pid' => $PID));
}

if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
        'info',
        'Configuration file read, log level set using options: %s',
        $main::options{'log_level'}
    );
} else {
    Log::set_log_level($Conf::Conf{'log_level'});
    Log::do_log(
        'info',
        'Configuration file read, default log level %s',
        $Conf::Conf{'log_level'}
    );
}

my $log_facility = $Conf::Conf{'log_facility'} || $Conf::Conf{'syslog'};
Log::do_openlog($log_facility, $Conf::Conf{'log_socket_type'}, 'bounced');

## Set the User ID & Group ID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs
## (effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    die
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo.\n";
}

## Sets the UMASK
umask(oct($Conf::Conf{'umask'}));

## Change to list root
unless (chdir($Conf::Conf{'home'})) {
    die sprintf "Unable to change directory to %s: %s", $Conf::Conf{'home'},
        $!;
}

Log::do_log('notice', 'Bounced %s Started', Sympa::Constants::VERSION());

## Catch signals, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'INT'}  = \&sigterm;
my $end = 0;

my $spool = $Conf::Conf{'queuebounce'};

Log::do_log('debug', 'Starting infinite loop');
## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {
    ## this sleep is important to be raisonably sure that sympa is not
    ## currently
    ## writting the file this deamon is openning.

    sleep $Conf::Conf{'sleep'};

    Sympa::List::init_list_cache();
    # Process grouped notifications
    Sympa::Alarm->instance->flush;

    my $dh;
    unless (opendir $dh, $spool) {
        die sprintf 'Can\'t open dir %s: %s', $spool, $ERRNO;
        # No return.
    }
    my @qfile =
        sort
        grep { !/,lock/ and !/\A(?:\.|T\.|BAD-)/ and -f ($spool . '/' . $_) }
        readdir $dh;
    closedir $dh;

    foreach my $filename (@qfile) {
        last if $end;

        my $lock_fh =
            Sympa::LockedFile->new($spool . '/' . $filename, -1, '+<');
        next unless $lock_fh;

        my $metadata = tools::unmarshal_metadata(
            $spool, $filename,
            qr{\A([^\s\@]+)(?:\@([\w\.\-]+))?\.(\d+)\.\w+(?:,.*)?\z},
            [qw(localpart domainpart date)]
        );
        next unless $metadata;

        my $msg_string = do { local $RS; <$lock_fh> };
        my $message = Sympa::Message->new($msg_string, %$metadata);
        unless ($message) {
            Log::do_log('notice', 'Ignoring malformed message %s', $message);
            quarantine($lock_fh);
            next;
        }

        unless (defined $message->{'message_id'}
            and length $message->{'message_id'}) {
            Log::do_log('err', 'Message %s has no message ID', $message);
            quarantine($lock_fh);
            next;
        }

        my ($listname, $robot);
        if (ref $message->{context} eq 'Sympa::List') {
            $listname = $message->{context}->{'name'};
            $robot    = $message->{context}->{'domain'};
        }

        my $entity = $message->as_entity;
        my $head   = $entity->head;

        ## Some MTAs decorate To: field of DSN as "mailbox <address>".
        ## Pick address only.
        my $to;
        my $to_header = $head->get('To', 0);
        if ($to_header) {
            my @to = Mail::Address->parse($to_header);
            if (@to and $to[0] and $to[0]->address) {
                $to = lc($to[0]->address);
            }
        }

        my $who;
        my $distribution_id;
        Log::do_log(
            'debug', 'Bounce for: %s: Conf{bounce_email_prefix}=%',
            $to,     $Conf::Conf{'bounce_email_prefix'}
        );

        my $to_re = '^'
            . quotemeta($Conf::Conf{'bounce_email_prefix'})
            . '[+](.*)\@(.*)$';
        if ($to and $to =~ $to_re) {
            # VERP in use.
            my $local_part = $1;
            my $robot      = $2;
            my $unique;
            if ($local_part =~ /^(.*)(\=\=([wr]))$/) {
                # VERP for welcome/remind probe in use.
                $local_part = $1;
                $unique     = $2;
            } elsif ($local_part =~ /^(.*)\=\=a\=\=(.*)\=\=(.*)\=\=(.*)$/) {
                # Tracking in use.
                $distribution_id = $4;
                $local_part =~ /^(.*)\=\=(.*)$/;
                $local_part = $1;
            }

            $local_part =~ s/\=\=a\=\=/\@/;
            $local_part =~ /^(.*)\=\=(.*)$/;
            $who      = $1;
            $listname = $2;

            Log::do_log('notice',
                'VERP in use: bounce related to %s for list %s@%s',
                $who, $listname, $robot);

            if ($unique and $unique =~ /[wr]/) {
                # in this case the bounce result from a remind or a welcome
                # message ;so try to remove the subscriber
                Log::do_log('debug',
                    "VERP for a service message, try to remove the subscriber"
                );
                my $list = Sympa::List->new($listname, $robot);
                unless ($list) {
                    Log::do_log('notice',
                        'Skipping bounce %s for unknown list %s@%s',
                        $message, $listname, $robot);
                    quarantine($lock_fh);
                    next;
                }
                # Overwrite context.
                $message->{context} = $list;

                my $result = Sympa::Scenario::request_action(
                    $list, 'del', 'smtp',
                    {   'sender' => $Conf::Conf{'listmasters'}[0],
                        'email'  => $who
                    }
                );
                my $action;
                $action = $result->{'action'} if (ref($result) eq 'HASH');

                if ($action =~ /do_it/i) {
                    if ($list->is_list_member($who)) {
                        my $u = $list->delete_list_member(
                            'users'   => [$who],
                            'exclude' => ' 1'
                        );
                        Log::do_log('notice',
                            "$who has been removed from $listname because welcome message bounced"
                        );
                        Log::db_log(
                            {   'robot'        => $list->{'domain'},
                                'list'         => $list->{'name'},
                                'action'       => 'del',
                                'target_email' => $who,
                                'status'       => 'error',
                                'error_type'   => 'welcome_bounced',
                                'daemon'       => 'bounced'
                            }
                        );

                        Log::db_stat_log(
                            {   'robot'     => $list->{'domain'},
                                'list'      => $list->{'name'},
                                'operation' => 'auto_del',
                                'parameter' => "",
                                'mail'      => $who,
                                'client'    => "",
                                'daemon'    => 'bounced.pl'
                            }
                        );

                        if ($action =~ /notify/) {
                            $list->send_notify_to_owner(
                                'automatic_del',
                                {   'who'    => $who,
                                    'by'     => 'bounce manager',
                                    'reason' => 'welcome'
                                }
                            );
                        }
                    }
                    remove($lock_fh);
                } else {
                    Log::do_log('notice',
                        "Unable to remove $who from $listname (welcome message bounced but del is closed)"
                    );
                    quarantine($lock_fh);
                }
                next;
            }    # close VERP + remind or welcome block
        }    # close VERP in use block

        my $list = Sympa::List->new($listname, $robot);
        unless ($list) {
            Log::do_log('err', 'Skipping bounce %s for unknown list %s@%s',
                $message, $listname, $robot);
            quarantine($lock_fh);
            next;
        }
        # Overwrite context.
        $message->{context} = $list;

        # ---
        # If the DSN notification is correct and the tracking mode is enable,
        # it will be inserted in the database
        my $tracking_in_use = 1
            if Sympa::Tools::Data::smart_eq(
            $list->{'admin'}{'tracking'}{'delivery_status_notification'},
            'on')
            or Sympa::Tools::Data::smart_eq(
            $list->{'admin'}{'tracking'}{'message_disposition_notification'},
            qr/\A(on|on_demand)\z/
            );

        my $eff_type = $entity->effective_type || '';
        my $report_type =
            lc($head->mime_attr('Content-Type.Report-Type') || '');

        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'delivery-status'
            and $tracking_in_use) {
            my @parts = $entity->parts();
            my $original_rcpt;
            my $final_rcpt;
            my $user_agent;
            my $version;
            my $dsn_status;
            my $listname;
            my $arrival_date;

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/delivery-status') {
                    next unless $p->bodyhandle;

                    my @fields = grep {$_} map {
                        my $str = $_ . "\n\n";
                        MIME::Head->read(IO::Scalar->new(\$str));
                        } split /(?:\A|\r\n|\n)[\r\n]+/,
                        $p->bodyhandle->as_string;
                    next unless @fields;

                    # Per-message fields.

                    #XXX $distribution_id is set using VERP nothing else.
                    # if ($fields[0]->get('Original-Envelope-Id')) {
                    #     $distribution_id =
                    #         $fields[0]->get('Original-Envelope-Id', 0);
                    #     chomp $distribution_id;
                    #     Log::do_log('debug2',
                    #         "Original Envelope ID Detected, value: %s",
                    #         $distribution_id);
                    # }
                    if ($fields[0]->get('Arrival-Date')) {
                        $arrival_date = $fields[0]->get('Arrival-Date', 0);
                        chomp $arrival_date;
                    }

                    # Per-recipient fields.

                    foreach my $fields (@fields) {
                        # Action Field MUST be present in a DSN report.
                        # Possible values: failed, delayed, delivered,
                        # relayed, expanded (RFC3464).
                        if ($fields->get('Action')) {
                            $dsn_status = lc($fields->get('Action', 0));
                            chomp $dsn_status;
                        }

                        #FIXME: Only the first occurrence is recognized.
                        if ($fields->get('Final-Recipient')
                            and not $final_rcpt) {
                            $final_rcpt =
                                lc($fields->get('Final-Recipient', 0));
                            chomp $final_rcpt;
                            my @rcpt;
                            if ($final_rcpt =~ /.*;.*/) {
                                @rcpt = split /;\s*/, $final_rcpt;
                                foreach my $rcpt (@rcpt) {
                                    if ($rcpt =~ /(\S+\@\S+)/) {
                                        ($rcpt) = $rcpt =~ /(\S+\@\S+)/;
                                        $final_rcpt = $rcpt;
                                    }
                                }
                            } else {
                                ($final_rcpt) = $final_rcpt =~ /(\S+\@\S+)/;
                            }
                            if ($final_rcpt =~ /<(\S+\@\S+)>/) {
                                ($final_rcpt) = $final_rcpt =~ /<(\S+\@\S+)>/;
                            }
                        }
                    }
                }
            }

            $original_rcpt = $who;

            Log::do_log(
                'debug2',
                '%s: DSN detected: dsn_status=%s; original_rcpt=%s; final_rcpt=%s; arrival_date=%s',
                $message,
                $dsn_status,
                $original_rcpt,
                $final_rcpt,
                $arrival_date
            );

            unless ($dsn_status =~ /failed/) {
                # DSN with status "failed" should not be removed because they
                # must be processed for classical bounce managment (not only
                # for tracking feature)
                Log::do_log('notice', 'Non failed DSN status %s',
                    $dsn_status);
                unless ($distribution_id) {
                    Log::do_log(
                        'err',
                        'Envelope ID not found in to address %s of DSN %s, will ignore',
                        $to,
                        $message
                    );
                    remove($lock_fh);
                    next;
                }
                unless ($original_rcpt) {
                    Log::do_log(
                        'err',
                        'Original recipient not found in DSN %s, will ignore',
                        $message
                    );
                    remove($lock_fh);
                    next;
                }
            }

            my $tracking = Sympa::Tracking->new($list);

            if ($tracking->store(
                    $message, $who,
                    envid        => $distribution_id,
                    type         => 'DSN',
                    status       => $dsn_status,
                    arrival_date => $arrival_date
                )
                ) {
                Log::do_log('notice', "DSN Correctly treated...");
            } else {
                Log::do_log('err',
                    'Not able to fill database with notification data');
            }
            unless ($dsn_status =~ /failed/) {
                remove($lock_fh);
                next;
            }
        }
        # ---
        # If the MDN notification is correct and the tracking mode is enabled,
        # it will be inserted in the database
        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'disposition-notification'
            and Sympa::Tools::Data::smart_eq(
                $list->{'admin'}{'tracking'}
                    {'message_disposition_notification'},
                qr/\A(on|on_demand)\z/
            )
            ) {

            my @parts = $entity->parts();
            my $original_rcpt;
            my $final_rcpt;
            my $user_agent;
            my $version;
            my $dsn_status;
            my $listname;
            my $date;
            my $mdn_status;

            $date = $head->get('Date');

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/disposition-notification') {
                    next unless $p->bodyhandle;

                    my @fields = grep {$_} map {
                        my $str = $_ . "\n\n";
                        MIME::Head->read(IO::Scalar->new(\$str));
                        } split /(?:\A|\r\n|\n)[\r\n]+/,
                        $p->bodyhandle->as_string;
                    next unless @fields;

                    foreach my $fields (@fields) {
                        # Disposition Field MUST be present in a MDN report.
                        # Possible values: displayed, deleted (RFC3798).
                        if ($fields->get('Disposition')) {
                            $mdn_status = lc($fields->get('Disposition', 0));
                            chomp $mdn_status;
                            if ($mdn_status =~ /.*\/.*/) {
                                my @results = split /\/\s*/, $mdn_status;
                                $mdn_status = $results[0];
                            }
                            $mdn_status = lc $mdn_status;
                        }
                        if ($fields->get('Final-Recipient')
                            and not $final_rcpt) {
                            $final_rcpt =
                                lc($fields->get('Final-Recipient', 0));
                            chomp $final_rcpt;
                            my @rcpt;
                            if ($final_rcpt =~ /.*;.*/) {
                                @rcpt = split /;\s*/, $final_rcpt;
                                foreach my $rcpt (@rcpt) {
                                    if ($rcpt =~ /(\S+\@\S+)/) {
                                        ($rcpt) = $rcpt =~ /(\S+\@\S+)/;
                                        $final_rcpt = $rcpt;
                                    }
                                }
                            } else {
                                ($final_rcpt) = $final_rcpt =~ /(\S+\@\S+)/;
                            }
                            if ($final_rcpt =~ /<(\S+\@\S+)>/) {
                                ($final_rcpt) = $final_rcpt =~ /<(\S+\@\S+)>/;
                            }
                        }
                    }
                }
            }

            # let's use VERP
            $original_rcpt = $who;

            Log::do_log(
                'debug2',
                '%s: MDN detected: mdn_status=%s; original_rcpt=%s; date=%s',
                $message,
                $mdn_status,
                $original_rcpt,
                $date
            );

            unless ($distribution_id) {
                Log::do_log(
                    'err',
                    'Envelope ID not found in to address %s of MDN %s, will ignore',
                    $to,
                    $message
                );
                remove($lock_fh);
                next;
            }
            unless ($original_rcpt) {
                Log::do_log('err',
                    'Original recipient not found in MDN %s, will ignore',
                    $message);
                remove($lock_fh);
                next;
            }
            unless ($mdn_status) {
                Log::do_log('err',
                    'MDN status not found in MDN %s, will ignore', $message);
                remove($lock_fh);
                next;
            }

            my $tracking = Sympa::Tracking->new($list);

            unless (
                $tracking->store(
                    $message, $who,
                    envid        => $distribution_id,
                    type         => 'MDN',
                    status       => $mdn_status,
                    arrival_date => $date
                )
                ) {
                Log::do_log('err',
                    'Not able to fill database with notification data');
            }
            Log::do_log('notice', "MDN Correctly treated...");
            remove($lock_fh);
            next;
        }

        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'feedback-report') {
            # This case a report Email Feedback Reports (RFC5965) mainly used
            # by AOL.
            Log::do_log('notice', 'Processing Email Feedback Report');
            my @parts = $entity->parts();
            my $original_rcpt;
            my $user_agent;
            my $version;
            my $feedback_type = '';
            my $listname;
            my $robot;

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/feedback-report') {
                    next unless $p->bodyhandle;

                    my @fields = grep {$_} map {
                        my $str = $_ . "\n\n";
                        MIME::Head->read(IO::Scalar->new(\$str));
                        } split /(?:\A|\r\n|\n)[\r\n]+/,
                        $p->bodyhandle->as_string;
                    next unless @fields;

                    foreach my $fields (@fields) {
                        if ($fields->get('Feedback-Type')) {
                            $feedback_type =
                                lc($fields->get('Feedback-Type', 0));
                            chomp $feedback_type;
                            $feedback_type = 'abuse'
                                if $feedback_type =~ /\A\s*abuse/i;
                        }

                        if ($fields->get('User-Agent')) {
                            $user_agent = $fields->get('User-Agent', 0);
                            chomp $user_agent;
                        }
                        if ($fields->get('Version')) {
                            $version = fields->get('Version', 0);
                            chomp $version;
                        }
                        my $email_regexp = Sympa::Regexps::email();
                        if (    $fields->get('Original-Rcpt-To')
                            and $fields->get('Original-Rcpt-To', 0) =~
                            /\A\s*$email_regexp\s*\z/i) {
                            $original_rcpt =
                                lc($fields->get('Original-Rcpt-To', 0));
                            chomp $original_rcpt;
                        }
                    }
                } elsif ($eff_type eq 'message/rfc822') {
                    # Log::do_log('notice',
                    #     "xxx processing  Email Feedback Report : message/rfc822 part");
                    my @subparts = $p->parts();
                    foreach my $subp (@subparts) {
                        # Log::do_log ('notice',"xxx subparts : subps");
                        my $subph = $subp->head;
                        $listname = $subph->get('X-Loop');
                    }
                    # Log::do_log('notice',
                    #     "xxx processing  Email Feedback Report : extract listname $listname");
                }
            }
            my $forward;
            ## RFC compliance remark: We do something if there is an abuse or
            ## an unsubscribe request.
            ## We don't throw an error if we find another kind of feedback
            ## (fraud, miscategorized, not-spam, virus or other)
            ## but we don't take action if we meet them yet. This is to be
            ## done, if relevant.
            if ($feedback_type =~
                /(abuse|opt-out|opt-out-list|fraud|miscategorized|not-spam|virus|other)/i
                and defined $version
                and defined $user_agent) {

                Log::do_log('debug',
                    "Email Feedback Report: $listname feedback-type: $feedback_type"
                );
                if (defined $original_rcpt) {
                    Log::do_log('debug', 'Recognized user: %s list',
                        $original_rcpt);
                    my @lists;

                    if ($feedback_type =~ /(opt-out-list|abuse)/i
                        and defined $listname) {
                        $listname = lc($listname);
                        chomp $listname;
                        $listname =~ /(.*)\@(.*)/;
                        $listname = $1;
                        $robot    = $2;
                        my $list = Sympa::List->new($listname, $robot);
                        unless ($list) {
                            Log::do_log(
                                'err',
                                'Skipping Feedback Report %s for unknown list %s@%s',
                                $message,
                                $listname,
                                $robot
                            );
                            quarantine($lock_fh);
                            next;
                        }
                        push @lists, $list;
                    } elsif ($feedback_type =~ /opt-out/
                        and defined $original_rcpt) {
                        @lists =
                            Sympa::List::get_which($original_rcpt, $robot,
                            'member');
                    } else {
                        Log::do_log(
                            'notice',
                            'Ignoring Feedback Report %s: Nothing to do for this feedback type.(feedback_type:%s, original_rcpt:%s, listname:%s)',
                            $message,
                            $feedback_type,
                            $original_rcpt,
                            $listname
                        );
                        quarantine($lock_fh);
                    }
                    foreach my $list (@lists) {
                        my $result =
                            Sympa::Scenario::request_action($list,
                            'unsubscribe', 'smtp',
                            {'sender' => $original_rcpt});
                        my $action;
                        $action = $result->{'action'}
                            if (ref($result) eq 'HASH');
                        if ($action =~ /do_it/i) {
                            if ($list->is_list_member($original_rcpt)) {
                                my $u = $list->delete_list_member(
                                    'users'   => [$original_rcpt],
                                    'exclude' => ' 1'
                                );

                                Log::do_log(
                                    'notice',
                                    '%s has been removed from %s because abuse feedback report',
                                    $original_rcpt,
                                    $list
                                );
                                $list->send_notify_to_owner(
                                    'automatic_del',
                                    {   'who' => $original_rcpt,
                                        'by'  => 'listmaster'
                                    }
                                );
                            } else {
                                Log::do_log(
                                    'err',
                                    'Ignore Feedback Report %s for list %s: user %s not subscribed',
                                    $message,
                                    $list,
                                    $original_rcpt
                                );
                                $list->send_notify_to_owner('warn-signoff',
                                    {'who' => $original_rcpt});
                            }
                        } else {
                            $forward = 'request';
                            Log::do_log(
                                'err',
                                'Ignore Feedback Report %s for list %s@%s: user %s is not allowed to unsubscribe',
                                $message,
                                $list,
                                $original_rcpt
                            );
                        }
                    }
                } else {
                    Log::do_log(
                        'err',
                        'Ignoring Feedback Report %s: Unknown Original-Rcpt-To field. Can\'t do anything. (feedback_type:%s, listname:%s)',
                        $message,
                        $feedback_type,
                        $listname
                    );
                    quarantine($lock_fh);
                    tools::send_notify_to_listmaster(
                        $robot,
                        'bounce_management_failed',
                        {   'file' => $lock_fh->basename,
                            'bad'  => "$spool/bad",
                            'error' =>
                                "Unknown Original-Rcpt-To field (feedback_type:$feedback_type, listname:$listname)",
                        }
                    );
                }
            } else {
                Log::do_log(
                    'err',
                    'Ignoring Feedback Report %s: Unknown format (feedback_type:%s, original_rcpt:%s, listname:%s)',
                    $message,
                    $feedback_type,
                    $original_rcpt,
                    $listname
                );
                quarantine($lock_fh);
                tools::send_notify_to_listmaster(
                    $robot,
                    'bounce_management_failed',
                    {   'file' => $lock_fh->basename,
                        'bad'  => "$spool/bad",
                        'error' =>
                            "Unknown format (feedback_type:$feedback_type, original_rcpt:$original_rcpt, listname:$listname)",
                    }
                );
            }
            if (-f "$spool/$filename") {
                remove($lock_fh);
            }
            next;
        }

        # Fin section feedback report
        # else (not welcome or remind)
        $list = Sympa::List->new($listname, $robot);
        unless ($list) {
            Log::do_log('err',
                'Skipping bouncefile %s for unknown list %s@%s',
                $message, $listname, $robot);
            quarantine($lock_fh);
            next;
        }
        # Overwrite context.
        $message->{context} = $list;

        Log::do_log('debug', 'Processing bounce %s for list %s',
            $message, $list);

        my (%hash, $from);

        # RFC3464 compliance check
        my $bounce_count = _parse_dsn($message, \%hash, \$from);

        unless ($bounce_count) {
            # Analysis of bounced message
            _anabounce($message, \%hash, \$from);
            # Voir pour appeler une methode de parsing des dsn qui maj la
            # bdd
            # updatedatabase(%hash);
        }

        my $tracking = Sympa::Tracking->new($list);

        my $adr_count;
        ## Bouncing addresses
        # Voir si pas mettre un test conditionnel sur le status code pour
        # detecter les dsn positifs et ne pas fausser les statistiques de
        # l'abonné.
        # Peut être possibilité de lancer la maj des tables pour chaque
        # recipient ici a condition d'avoir approfondi le parsing en
        # amont.
        while (my ($rcpt, $status) = each %hash) {
            $adr_count++;
            my $bouncefor = $who;
            $bouncefor ||= $rcpt;

            unless ($tracking->store($message, $bouncefor)) {
                quarantine($lock_fh);
                next;
            }
            next
                unless _update_subscriber_bounce_history($list, $rcpt,
                $bouncefor, _canonicalize_status($status));
        }

        ## No address found in the bounce itself
        unless ($adr_count) {
            if ($who) {
                # rcpt not recognized in the bounce but VERP was used
                # Status is undefined.
                _update_subscriber_bounce_history($list, 'unknown', $who);
                unless ($tracking->store($message, $who)) {
                    quarantine($lock_fh);
                } else {
                    remove($lock_fh);
                }
            } else {    # no VERP and no rcpt recognized
                my $escaped_from = tools::escape_chars($from);
                Log::do_log('info',
                    'No address found in message from %s for list %s',
                    $from, $list);
                quarantine($lock_fh);
                next;
            }
        }

        if (-f "$spool/$filename") {    #FIXME
            remove($lock_fh);
        }
    }

    ## Free zombie sendmail processes
    Sympa::Mailer->instance->reaper();
}

# Purge grouped notifications
Sympa::Alarm->instance->flush(purge => 1);

Log::do_log('notice', 'Bounced exited normally due to signal');
Sympa::Tools::Daemon::remove_pid('bounced', $PID);

exit(0);

## When we catch signal, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

## copy the bounce to the appropriate filename
# Moved: Use Sympa::Tracking::store().
#sub store_bounce;

# RFC3464 compliance check
sub _parse_dsn {
    my $message = shift;
    my $result  = shift;
    my $from    = shift;

    local $RS = "\n";

    my $nbrcpt;
    my $entity = $message->as_entity;

    unless ($entity) {
        return undef;
    }

    my @addrs = Mail::Address->parse($entity->head->get('From', 0));
    $$from = $addrs[0]->address if @addrs;

    foreach my $part ($entity->parts) {
        my $eff_type = $part->effective_type || '';
        next unless $eff_type eq 'message/delivery-status';
        next unless $part->bodyhandle;

        my @fields = grep {$_} map {
            my $str = $_ . "\n\n";
            MIME::Head->read(IO::Scalar->new(\$str));
        } split /(?:\A|\r\n|\n)[\r\n]+/, $part->bodyhandle->as_string;
        next unless @fields;

        foreach my $fields (@fields) {
            if (    $fields->get('Status')
                and $fields->get('Status', 0) =~
                /\A\s*(\d+\.\d+\.\d+)\s*\z/mi) {
                my $status = $1;
                my $recipient;
                if (    $fields->get('Original-Recipient')
                    and $fields->get('Original-Recipient', 0) =~
                    /\A\s*rfc822\s*;\s*(.*)\z/mi) {
                    $recipient = $1;
                    $recipient =~ s/\s+\z//;
                    if ($recipient =~ /\@.+:(.+)$/) {
                        $recipient = $1;
                    }
                    $recipient =~ s/^<(.*)>$/$1/;
                    $recipient = lc $recipient;
                } elsif ($fields->get('Final-Recipient')
                    and $fields->get('Final-Recipient', 0) =~
                    /\A\s*rfc822\s*;\s*(.*)\z/mi) {
                    $recipient = $1;
                    $recipient =~ s/\s+\z//;
                    if ($recipient =~ /\@.+:(.+)$/) {
                        $recipient = $1;
                    }
                    $recipient =~ s/^<(.*)>$/$1/;
                    $recipient = lc $recipient;
                }

                if ($recipient) {
                    $result->{$recipient} = $status;
                    $nbrcpt++;
                }
            }
        }
    }

    return $nbrcpt;
}

## Corrige une adresse SMTP
sub _corrige {

    my ($adr, $from) = @_;

    ## X400 address
    if ($adr =~ /^\//) {

        my (%x400, $newadr);

        my @detail = split /\//, $adr;
        foreach (@detail) {

            my ($var, $val) = split /=/;
            $x400{$var} = $val;
            #print "\t$var <=> $val\n";

        }

        $newadr = $x400{PN} || "$x400{s}";
        $newadr = "$x400{g}." . $newadr if $x400{g};
        my ($l, $d) = split /\@/, $from;

        $newadr .= "\@$d";

        return $newadr;

    } elsif ($adr =~ /\@/) {

        return $adr;

    } elsif ($adr =~ /\!/) {

        my ($dom, $loc) = split /\!/, $adr;
        return "$loc\@$dom";

    } else {

        my ($l, $d) = split /\@/, $from;
        my $newadr = "$adr\@$d";

        return $newadr;

    }
}

# Analyse d'un rapport de non-remise
# Param 1 : descripteur du fichier contenant le bounce
# //    2 : reference d'un hash pour retourner @ en erreur
# //    3 : reference d'un tableau pour retourner des stats
# //    4 : reference d'un tableau pour renvoyer le bounce
sub _anabounce {
    my $message = shift;
    my $result  = shift;
    my $from    = shift;

    my $msg_string = $message->as_string;
    my $fic        = IO::Scalar->new(\$msg_string);

    my $entete = 1;
    my $type;
    my %info;
    my ($qmail,                $type_9,      $type_18,
        $exchange,             $ibm_vm,      $lotus,
        $sendmail_5,           $yahoo,       $type_21,
        $exim,                 $vines,       $mercury_143,
        $altavista,            $mercury_131, $type_31,
        $type_32,              $exim_173,    $type_38,
        $type_39,              $type_40,     $pmdf,
        $following_recipients, $postfix,     $groupwise7
    );

    ## Le champ separateur de paragraphe est un ensemble
    ## de lignes vides
    local $RS = '';

    ## Parcour du bounce, paragraphe par paragraphe
    foreach (<$fic>) {
        if ($entete) {
            undef $entete;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            my ($champ_courant, %champ);
            foreach (@paragraphe) {
                if (/^(\S+):\s*(.*)$/) {
                    $champ_courant = $1;
                    $champ_courant =~ y/[A-Z]/[a-z]/;
                    $champ{$champ_courant} = $2;
                } elsif (/^\s+(.*)$/) {
                    $champ{$champ_courant} .= " $1";
                }

                ## Le champ From:
                if (defined $champ{from}) {
                    my @addrs = Mail::Address->parse($champ{from});
                    $$from = $addrs[0]->address if @addrs;
                }
            }
            local $RS = '';

            $champ{from} =~ s/^.*<(.+)[\>]$/$1/;
            $champ{from} =~ y/[A-Z]/[a-z]/;
            my ($local, $domaine) = split /\@/, $champ{from};

            if ($champ{subject} =~
                /^Returned mail: (Quota exceeded for user (\S+))$/) {

                $info{$2}{error} = $1;
                $type = 27;

            } elsif ($champ{subject} =~
                /^Returned mail: (message not deliverable): \<(\S+)\>$/) {

                $info{$2}{error} = $1;
                $type = 34;
            }

            unless (defined $champ{'x-failed-recipients'}) {
                ;
            } elsif ($champ{'x-failed-recipients'} =~ /^\s*(\S+)$/) {
                $info{$1}{error} = "";
            } elsif ($champ{'x-failed-recipients'} =~ /^\s*(\S+),/) {
                for my $xfr (split(/\s*,\s*/, $champ{'x-failed-recipients'}))
                {
                    $info{$xfr}{error} = "";
                }
            }
        } elsif (
            /^\s*-+ The following addresses (had permanent fatal errors|had transient non-fatal errors|have delivery notifications) -+/m
            ) {

            my $adr;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^(\S[^\(]*)/) {
                    $adr = $1;
                    my $error = $2;
                    $adr =~ s/^[\"\<](.+)[\"\>]\s*$/$1/;
                    #print "\tADR : #$adr#\n";
                    $info{$adr}{error} = $error;
                    $type = 1;

                } elsif (/^\s+\(expanded from: (.+)\)/) {
                    #print "\tEXPANDED $adr : $1\n";
                    $info{$adr}{expanded} = $1;
                    $info{$adr}{expanded} =~ s/^[\"\<](.+)[\"\>]$/$1/;
                }
            }
            local $RS = '';

        } elsif (/^\s+-+\sTranscript of session follows\s-+/m) {

            my $adr;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^(\d{3}\s)?(\S+|\".*\")\.{3}\s(.+)$/) {

                    $adr = $2;
                    my $cause = $3;
                    $cause =~ s/^(.*) [\(\:].*$/$1/;
                    foreach $a (split /,/, $adr) {

                        $a =~ s/^[\"\<]([^\"\>]+)[\"\>]$/$1/;
                        $info{$a}{error} = $cause;
                        $type = 2;

                    }
                } elsif (/^\d{3}\s(too many hops).*to\s(.*)$/i) {

                    $adr = $2;
                    my $cause = $1;
                    foreach $a (split /,/, $adr) {

                        $a =~ s/^[\"\<](.+)[\"\>]$/$1/;
                        $info{$a}{error} = $cause;
                        $type = 2;

                    }

                } elsif (/^\d{3}\s.*\s([^\s\)]+)\.{3}\s(.+)$/) {

                    $adr = $1;
                    my $cause = $2;
                    $cause =~ s/^(.*) [\(\:].*$/$1/;
                    foreach $a (split /,/, $adr) {

                        $a =~ s/^[\"\<](.+)[\"\>]$/$1/;
                        $info{$a}{error} = $cause;
                        $type = 2;

                    }
                }
            }
            local $RS = '';

            ## Rapport Compuserve
        } elsif (/^Receiver not found:/m) {

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                $info{$2}{error} = $1 if /^(.*): (\S+)/;
                $type = 3;

            }
            local $RS = '';

        } elsif (/^\s*-+ Special condition follows -+/m) {

            my ($cause, $adr);

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^(Unknown QuickMail recipient\(s\)):/) {
                    $cause = $1;
                    $type  = 4;

                } elsif (/^\s+(.*)$/ and $cause) {

                    $adr = $1;
                    $adr =~ s/^[\"\<](.+)[\"\>]$/$1/;
                    $info{$adr}{error} = $cause;
                    $type = 4;

                }
            }
            local $RS = '';

        } elsif (/^Your message add?ressed to .* couldn\'t be delivered/m) {

            my $adr;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^Your message add?ressed to (.*) couldn\'t be delivered, for the following reason :/
                    ) {
                    $adr = $1;
                    $adr =~ s/^[\"\<](.+)[\"\>]$/$1/;
                    $type = 5;

                } else {

                    /^(.*)$/;
                    $info{$adr}{error} = $1;
                    $type = 5;

                }
            }
            local $RS = '';

            ## Rapport X400
        } elsif (
            /^Your message was not delivered to:\s+(\S+)\s+for the following reason:\s+(.+)$/m
            ) {

            my ($adr, $error) = ($1, $2);
            $error =~ s/Your message.*$//;
            $info{$adr}{error} = $error;
            $type = 6;

            ## Rapport X400
        } elsif (
            /^Your message was not delivered to\s+(\S+)\s+for the following reason:\s+(.+)$/m
            ) {

            my ($adr, $error) = ($1, $2);
            $error =~ s/\(.*$//;
            $info{$adr}{error} = $error;
            $type = 6;

            ## Rapport X400
        } elsif (/^Original-Recipient: rfc822; (\S+)\s+Action: (.*)$/m) {

            $info{$1}{error} = $2;
            $type = 16;

            ## Rapport NTMail
        } elsif (/^The requested destination was:\s+(.*)$/m) {

            $type = 7;

        } elsif (($type == 7) && (/^\s+(\S+)/)) {

            undef $type;
            my $adr = $1;
            $adr =~ s/^[\"\<](.+)[\"\>]$/$1/;
            next unless $adr;
            $info{$adr}{'error'} = '';

            ## Rapport Qmail dans prochain paragraphe
        } elsif (/^Hi\. This is the qmail-send program/m) {

            $qmail = 1;

            ## Rapport Qmail
        } elsif ($qmail) {

            undef $qmail if /^[^<]/;

            if (/^<(\S+)>:\n(.*)/m) {

                $info{$1}{error} = $2;
                $type = 8;

            }
            local $RS = '';

            ## Sendmail
        } elsif (
            /^Your message was not delivered to the following recipients:/m) {

            $type_9 = 1;

        } elsif ($type_9) {

            undef $type_9;

            if (/^\s*(\S+):\s+(.*)$/m) {

                $info{$1}{error} = $2;
                $type = 9;

            }

            ## Rapport Exchange dans prochain paragraphe
        } elsif (/^The following recipient\(s\) could not be reached:/m
            or /^did not reach the following recipient\(s\):/m) {

            $exchange = 1;

            ## Rapport Exchange
        } elsif ($exchange) {

            undef $exchange;

            if (/^\s*(\S+).*\n\s+(.*)$/m) {

                $info{$1}{error} = $2;
                $type = 10;

            }

            ## IBM VM dans prochain paragraphe
        } elsif (
            /^Your mail item could not be delivered to the following users/m)
        {

            $ibm_vm = 1;

            ## Rapport IBM VM
        } elsif ($ibm_vm) {

            undef $ibm_vm;

            if (/^(.*)\s+\---->\s(\S+)$/m) {

                $info{$2}{error} = $1;
                $type = 12;

            }
            ## Rapport Lotus SMTP dans prochain paragraphe
        } elsif (/^-+\s+Failure Reasons\s+-+/m) {

            $lotus = 1;

            ## Rapport Lotus SMTP
        } elsif ($lotus) {

            undef $lotus;

            if (/^(.*)\n(\S+)$/m) {

                $info{$2}{error} = $1;
                $type = 13;

            }
            ## Rapport Sendmail 5 dans prochain paragraphe
        } elsif (/^\-+\sTranscript of session follows\s\-+/m) {

            $sendmail_5 = 1;

            ## Rapport  Sendmail 5
        } elsif ($sendmail_5) {

            undef $sendmail_5;

            if (/<(\S+)>\n\S+, (.*)$/m) {

                $info{$1}{error} = $2;
                $type = 14;

            }
            ## Rapport Smap
        } elsif (/^\s+-+ Transcript of Report follows -+/) {

            my $adr;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^Rejected-For: (\S+),/) {

                    $adr               = $1;
                    $info{$adr}{error} = "";
                    $type              = 17;

                } elsif (/^\s+explanation (.*)$/) {

                    $info{$adr}{error} = $1;

                }
            }
            local $RS = '';

        } elsif (/^\s*-+Message not delivered to the following:/) {

            $type_18 = 1;

        } elsif ($type_18) {

            undef $type_18;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^\s*(\S+)\s+(.*)$/) {

                    $info{$1}{error} = $2;
                    $type = 18;

                }
            }
            local $RS = '';

        } elsif (/unable to deliver following mail to recipient\(s\):/m) {

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^\d+ <(\S+)>\.{3} (.+)$/) {

                    $info{$1}{error} = $2;
                    $type = 19;

                }
            }
            local $RS = '';

            ## Rapport de Yahoo dans paragraphe suivant
        } elsif (/^Unable to deliver message to the following address\(es\)/m)
        {

            $yahoo = 1;

            ## Rapport Yahoo
        } elsif ($yahoo) {

            undef $yahoo;

            if (/^<(\S+)>:\s(.+)$/m) {

                $info{$1}{error} = $2;
                $type = 20;

            }

        } elsif (/^Content-Description: Session Transcript/m) {

            $type_21 = 1;

        } elsif ($type_21) {

            undef $type_21;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/<(\S+)>\.{3} (.*)$/) {

                    $info{$1}{error} = $2;
                    $type = 21;

                }
            }
            local $RS = '';

        } elsif (
            /^Your message has encountered delivery problems\s+to local user \S+\.\s+\(Originally addressed to (\S+)\)/m
            or
            /^Your message has encountered delivery problems\s+to (\S+)\.$/m
            or
            /^Your message has encountered delivery problems\s+to the following recipient\(s\):\s+(\S+)$/m
            ) {

            my $adr = $2 || $1;
            $info{$adr}{error} = "";
            $type = 22;

        } elsif (/^(The user return_address (\S+) does not exist)/) {

            $info{$2}{error} = $1;
            $type = 23;

            ## Rapport Exim paragraphe suivant
        } elsif (
            /^A message that you sent could not be delivered to all of its recipients/m
            or /^The following address\(es\) failed:/m) {

            $exim = 1;

            ## Rapport Exim
        } elsif ($exim) {

            undef $exim;

            if (/^\s*(\S+):\s+(.*)$/m) {

                $info{$1}{error} = $2;
                $type = 24;

            } elsif (/^\s*(\S+)$/m) {
                $info{$1}{error} = "";
            }

            ## Rapport VINES-ISMTP par. suivant
        } elsif (/^Message not delivered to recipients below/m) {

            $vines = 1;

            ## Rapport VINES-ISMTP
        } elsif ($vines) {

            undef $vines;

            if (/^\s+\S+:.*\s+(\S+)$/m) {

                $info{$1}{error} = "";
                $type = 25;

            }

            ## Rapport Mercury 1.43 par. suivant
        } elsif (
            /^The local mail transport system has reported the following problems/m
            ) {

            $mercury_143 = 1;

            ## Rapport Mercury 1.43
        } elsif ($mercury_143) {

            undef $mercury_143;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/<(\S+)>\s+(.*)$/) {

                    $info{$1}{error} = $2;
                    $type = 26;
                }
            }
            local $RS = '';

            ## Rapport de AltaVista Mail dans paragraphe suivant
        } elsif (/unable to deliver mail to the following recipient\(s\):/m) {

            $altavista = 1;

            ## Rapport AltaVista Mail
        } elsif ($altavista) {

            undef $altavista;

            if (/^(\S+):\n.*\n\s*(.*)$/m) {

                $info{$1}{error} = $2;
                $type = 27;

            }

            ## Rapport SMTP32
        } elsif (/^(User mailbox exceeds allowed size): (\S+)$/m) {

            $info{$2}{error} = $1;
            $type = 28;

        } elsif (/^The following recipients did not receive this message:$/m)
        {

            $following_recipients = 1;

        } elsif ($following_recipients) {

            undef $following_recipients;

            if (/^\s+<(\S+)>/) {

                $info{$1}{error} = "";
                $type = 29;

            }

            ## Rapport Mercury 1.31 par. suivant
        } elsif (
            /^One or more addresses in your message have failed with the following/m
            ) {

            $mercury_131 = 1;

            ## Rapport Mercury 1.31
        } elsif ($mercury_131) {

            undef $mercury_131;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/<(\S+)>\s+(.*)$/) {

                    $info{$1}{error} = $2;
                    $type = 30;
                }
            }
            local $RS = '';

        } elsif (/^The following recipients haven\'t received this message:/m)
        {

            $type_31 = 1;

        } elsif ($type_31) {

            undef $type_31;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/(\S+)$/) {

                    $info{$1}{error} = "";
                    $type = 31;
                }
            }
            local $RS = '';

        } elsif (/^The following destination addresses were unknown/m) {

            $type_32 = 1;

        } elsif ($type_32) {

            undef $type_32;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/<(\S+)>/) {

                    $info{$1}{error} = "";
                    $type = 32;
                }
            }
            local $RS = '';

        } elsif (/^-+Transcript of session follows\s-+$/m) {

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^(\S+)$/) {

                    $info{$1}{error} = "";
                    $type = 33;

                } elsif (/<(\S+)>\.{3} (.*)$/) {

                    $info{$1}{error} = $2;
                    $type = 33;

                }
            }
            local $RS = '';

            ## Rapport Bigfoot
        } elsif (/^The message you tried to send to <(\S+)>/m) {
            $info{$1}{error} = "destination mailbox unavailable";

        } elsif (/^The destination mailbox (\S+) is unavailable/m) {

            $info{$1}{error} = "destination mailbox unavailable";

        } elsif (
            /^The following message could not be delivered because the address (\S+) does not exist/m
            ) {

            $info{$1}{error} = "user unknown";

        } elsif (/^Error-For:\s+(\S+)\s/) {

            $info{$1}{error} = "";

            ## Rapport Exim 1.73 dans proc. paragraphe
        } elsif (
            /^The address to which the message has not yet been delivered is:/m
            ) {

            $exim_173 = 1;

            ## Rapport Exim 1.73
        } elsif ($exim_173) {

            undef $exim_173;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/(\S+)/) {

                    $info{$1}{error} = "";
                    $type = 37;
                }
            }
            local $RS = '';

        } elsif (
            /^This Message was undeliverable due to the following reason:/m) {

            $type_38 = 1;

        } elsif ($type_38) {

            undef $type_38 if /Recipient:/;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/\s+Recipient:\s+<(\S+)>/) {

                    $info{$1}{error} = "";
                    $type = 38;

                } elsif (/\s+Reason:\s+<(\S+)>\.{3} (.*)/) {

                    $info{$1}{error} = $2;
                    $type = 38;

                }
            }
            local $RS = '';

        } elsif (/Your message could not be delivered to:/m) {

            $type_39 = 1;

        } elsif ($type_39) {

            undef $type_39;

            if (/^(\S+)/) {

                $info{$1}{error} = "";
                $type = 39;

            }
        } elsif (/Session Transcription follow:/m) {

            if (/^<+\s+\d+\s+(.*) for \((.*)\)$/m) {

                $info{$2}{error} = $1;
                $type = 43;

            }

        } elsif (
            /^This message was returned to you for the following reasons:/m) {

            $type_40 = 1;

        } elsif ($type_40) {

            undef $type_40;

            if (/^\s+(.*): (\S+)/) {

                $info{$2}{error} = $1;
                $type = 40;

            }

            ## Rapport PMDF dans proc. paragraphe
        } elsif (
            /^Your message cannot be delivered to the following recipients:/m
            or
            /^Your message has been enqueued and undeliverable for \d day\s*to the following recipients/m
            ) {

            $pmdf = 1;

            ## Rapport PMDF
        } elsif ($pmdf) {

            my $adr;
            undef $pmdf;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/\s+Recipient address:\s+(\S+)/) {

                    $adr               = $1;
                    $info{$adr}{error} = "";
                    $type              = 41;

                } elsif (/\s+Reason:\s+(.*)$/) {

                    $info{$adr}{error} = $1;
                    $type = 41;

                }
            }
            local $RS = '';

            ## Rapport MDaemon
        } elsif (/^(\S+) - (no such user here)\.$/m) {

            $info{$1}{error} = $2;
            $type = 42;

            # Postfix dans le prochain paragraphe
        } elsif (/^This is the Postfix program/m
            || /^This is the mail system at host/m) {
            $postfix = 1;
            ## Rapport Postfix
        } elsif ($postfix) {

            undef $postfix
                if /THIS IS A WARNING/;    # Pas la peine de le traiter

            if (/^<(\S+)>:\s(.*)/m) {
                my ($addr, $error) = ($1, $2);

                if ($error =~ /^host\s[^:]*said:\s(\d+)/) {
                    $info{$addr}{error} = $1;
                } elsif ($error =~ /^([^:]+):/) {
                    $info{$addr}{error} = $1;
                } else {
                    $info{$addr}{error} = $error;
                }
            }
            local $RS = '';
        } elsif (
            /^The message that you sent was undeliverable to the following:/)
        {

            $groupwise7 = 1;

        } elsif ($groupwise7) {

            undef $groupwise7;

            ## Parcour du paragraphe
            my @paragraphe = split /\n/, $_;
            local $RS = "\n";
            foreach (@paragraphe) {

                if (/^\s+(\S*) \((.+)\)/) {

                    $info{$1}{error} = $2;

                }
            }

            local $RS = '';

            ## Wanadoo
        } elsif (/^(\S+); Action: Failed; Status: \d.\d.\d \((.*)\)/m) {
            $info{$1}{error} = $2;
        }
    }

    my $count = 0;
    ## On met les adresses au clair
    foreach my $a1 (keys %info) {

        next unless ($a1 and ref($info{$a1}));

        $count++;
        my ($a2, $a3);

        $a2 = $a1;

        unless (!$info{$a1}{expanded}
            or ($a1 =~ /\@/ and $info{$a1}{expanded} !~ /\@/)) {

            $a2 = $info{$a1}{expanded};

        }

        $a3 = _corrige($a2, $$from);
        $a3 =~ y/[A-Z]/[a-z]/;
        $a3 =~ s/^<(.*)>$/$1/;
        $result->{$a3} = lc($info{$a1}{error});
    }

    return $count;
}

# Set error message to a status RFC1893 compliant
sub _canonicalize_status {

    my $status = shift;

    if ($status !~ /^\d+\.\d+\.\d+$/) {
        if ($equiv{$status}) {
            $status = $equiv{$status};
        } else {
            return undef;
        }
    }
    return $status;
}

## update subscriber information
# $bouncefor : the email address the bounce is related for (may be extracted
#              using VERP)
# $rcpt : the email address recognized in the bounce itself. In most case
#         $rcpt eq $bouncefor
sub _update_subscriber_bounce_history {

    my $list      = shift;
    my $rcpt      = shift;
    my $bouncefor = shift;
    my $status    = shift;

    Log::do_log('debug', '(%s, %s, %s, %s)',
        $list->{'name'}, $rcpt, $bouncefor, $status);

    my $first = my $last = time;
    my $count = 0;

    my $user = $list->get_list_member($bouncefor);

    unless ($user) {
        Log::do_log('notice', 'Subscriber not found in list %s: %s',
            $list->{'name'}, $bouncefor);
        return undef;
    }

    if ($user->{'bounce'} =~ /^(\d+)\s\d+\s+(\d+)/) {
        ($first, $count) = ($1, $2);
    }
    $count++;
    if ($rcpt ne $bouncefor) {
        Log::do_log('notice',
            'Bouncing address identified with VERP: %s / %s',
            $rcpt, $bouncefor);
        Log::do_log('debug', '(%s, bounce-> %s %s %s %s, bounce_address->%s)',
            $bouncefor, $first, $last, $count, $status, $rcpt);
        $list->update_list_member(
            $bouncefor,
            {   'bounce'         => "$first $last $count $status",
                'bounce_address' => $rcpt
            }
        );
        Log::db_log(
            {   'robot'        => $list->{'domain'},
                'list'         => $list->{'name'},
                'action'       => 'get_bounce',
                'parameters'   => "address=$rcpt",
                'target_email' => $bouncefor,
                'msg_id'       => '',
                'status'       => 'error',
                'error_type'   => $status,
                'daemon'       => 'bounced'
            }
        );
    } else {
        $list->update_list_member($bouncefor,
            {'bounce' => "$first $last $count $status"});
        Log::do_log('notice', 'Received bounce for email address %s, list %s',
            $bouncefor, $list->{'name'});
        Log::db_log(
            {   'robot'        => $list->{'domain'},
                'list'         => $list->{'name'},
                'action'       => 'get_bounce',
                'target_email' => $bouncefor,
                'msg_id'       => '',
                'status'       => 'error',
                'error_type'   => $status,
                'daemon'       => 'bounced'
            }
        );
    }
}

# If bounce can't be handled correctly, saves it to the "bad" subdirectory of
# the bounce spool.
sub quarantine {
    my $lock_fh = shift;
    my $robot = shift || '*';

    my $bad_dir  = "$spool/bad";
    my $filename = $lock_fh->basename;

    if (-d $bad_dir) {
        unless ($lock_fh->rename($bad_dir . '/' . $filename)) {
            die sprintf
                'Unable to rename bad file %s to %s/%s: %s',
                $filename, $bad_dir, $filename, $lock_fh->last_error;
        }
        Log::do_log('notice', "Moving bad file %s to bad/", $filename);
    } else {
        Log::do_log('notice', 'Missing directory "%s"', $bad_dir);
        unless ($lock_fh->rename($spool . '/BAD-' . $filename)) {
            die sprintf
                'Unable to rename bad file %s to BAD-%s: %s',
                $filename, $filename, $lock_fh->last_error;
        }
        Log::do_log('notice', "Renaming bad file %s to BAD-%s",
            $filename, $filename);
    }
}

sub remove {
    my $lock_fh = shift;

    $lock_fh->unlink;
}

__END__

=encoding utf-8

=head1 NAME

bounced, bounced.pl - Mailing List Bounce Processing Daemon for Sympa

=head1 SYNOPSIS

S<B<bounced> [ B<--foreground> ] [ B<--debug> ]>

=head1 DESCRIPTION

Bounced is a program which scans permanently the bounce spool and
processes bounces (non-delivery messages), looking or bad addresses.
Bouncing addresses are tagged in database ; last bounce is kept for
each bouncing address.

List owners will latter access bounces information via WWSympa.

=head1 OPTIONS

These programs follow the usual GNU command line syntax,
with long options starting with two dashes (C<-->).  A summary of
options is included below.

=over 5

=item B<-F>, B<--foreground>

Do not detach TTY.

=item B<-f>, B<--config=>I<file>

Force bounced to use an alternative configuration file instead
of F<--CONFIG-->.

=item B<-d>, B<--debug>

Run the program in a debug mode.

=item B<-h>, B<--help>

Print this help message.

=item B<--log_level=>I<level>

Sets daemon log level.

=back

=head1 FILES

F<--CONFIG--> Sympa configuration file.

F<--libexecdir--/bouncequeue> bounce spooler, referenced from sendmail alias file

F<--spooldir--/bounce> incoming bounces directory

F<--piddir--/bounced.pid> this file contains the process ID
of F<bounced.pl>.

=head1 MORE DOCUMENTATION

The full documentation can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 HISTORY

This program was originally written by:

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

This manual page was initially written by
JE<233>rE<244>me Marant <jerome.marant@IDEALX.org>
for the Debian GNU/Linux system.

=head1 LICENSE

You may distribute this software under the terms of the GNU General
Public License Version 2.  For more details see F<README> file.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license can be found under
L<http://www.gnu.org/licenses/fdl.html>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa_msg(8)>, L<wwsympa(8)>, L<mhonarc(1)>, L<sympa.conf(5)>.

=cut
