#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997, 1998, 1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
# 2006, 2007, 2008, 2009, 2010, 2011 Comite Reseau des Universites
# Copyright (c) 2011, 2012, 2013, 2014, 2015 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

## Worl Wide Sympa is a front-end to Sympa Mailing Lists Manager
## Copyright Comite Reseau des Universites

## Patch 2001.07.24 by nablaphi <nablaphi@bigfoot.com>
## Change the Getopt::Std to Getopt::Long

use lib split(/:/, $ENV{SYMPALIB} || ''), '--modulesdir--';
use strict;
use warnings;
use English qw(-no_match_vars);
use Getopt::Long;
use Mail::Address;
use Pod::Usage;
use POSIX qw();

use Sympa::Alarm;
use Bounce;
use Conf;
use Sympa::Constants;
use Sympa::Crash;    # Show traceback.
use Sympa::List;
use Sympa::LockedFile;
use Log;
use Sympa::Mailer;
use Sympa::Message;
use Sympa::Regexps;
use Sympa::Scenario;
use SDM;
use tools;
use Sympa::Tools::Daemon;
use Sympa::Tools::Data;
use Sympa::Tracking;

## Equivalents relative to RFC 1893
my %equiv = (
    "user unknown"                                                => '5.1.1',
    "receiver not found"                                          => '5.1.1',
    "the recipient name is not recognized"                        => '5.1.1',
    "sorry, no mailbox here by that name"                         => '5.1.1',
    "utilisateur non recens\xE9 dans le carnet d'adresses public" => '5.1.1',
    "unknown address"                                             => '5.1.1',
    "unknown user"                                                => '5.1.1',
    "550"                                                         => '5.1.1',
    "le nom du destinataire n'est pas reconnu"                    => '5.1.1',
    "user not listed in public name & address book"               => '5.1.1',
    "no such address"                                             => '5.1.1',
    "not known at this site."                                     => '5.1.1',
    "user not known"                                              => '5.1.1',

    "user is over the quota. you can try again later." => '4.2.2',
    "quota exceeded"                                   => '4.2.2',
    "write error to mailbox, disk quota exceeded"      => '4.2.2',
    "user mailbox exceeds allowed size"                => '4.2.2',
    "insufficient system storage"                      => '4.2.2',
    "User's Disk Quota Exceeded:"                      => '4.2.2'
);

## Check options
my %options;
unless (
    GetOptions(
        \%main::options, 'config|f=s',   'debug|d', 'help|h',
        'log_level=s',   'foreground|F', 'version|v',
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($main::options{'help'}) {
    pod2usage(0);
} elsif ($main::options{'version'}) {
    printf "Sympa %s\n", Sympa::Constants::VERSION;
    exit 0;
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1
    if ($main::options{'debug'} || $main::options{'foreground'});

my $daemon_name = Log::set_daemon($0);
my $ip          = $ENV{'REMOTE_HOST'};

# Load sympa.conf
unless (Conf::load()) {
    die sprintf
        "Unable to load sympa configuration, file %s has errors.\n",
        Conf::get_sympa_conf();
}

##unshift @INC, $Conf::Conf{'wws_path'};

## Check databse connectivity
unless (SDM::check_db_connect()) {
    die sprintf
        "Database %s defined in sympa.conf has not the right structure or is unreachable.\n",
        $Conf::Conf{'db_name'};
}

## Put ourselves in background if not in debug mode.
unless ($main::options{'debug'} || $main::options{'foreground'}) {
    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
        ioctl(TTY, 0x20007471, 0);    # XXX s/b TIOCNOTTY()
        close(TTY);
    }
    setpgrp 0, 0;
    my $child_pid = fork;
    if ($child_pid) {
        Log::do_log('info', 'Starting bounced daemon, PID %s', $child_pid);
        exit 0;
    } elsif (not defined $child_pid) {
        die sprintf 'Cannot fork: %s', $ERRNO;
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the PID file
Sympa::Tools::Daemon::write_pid('bounced', $PID, $options);
unless ($options->{'stderr_to_tty'}) {
    Sympa::Tools::Daemon::direct_stderr_to_file(('pid' => $PID));
}

if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
        'info',
        'Configuration file read, log level set using options: %s',
        $main::options{'log_level'}
    );
} else {
    Log::set_log_level($Conf::Conf{'log_level'});
    Log::do_log(
        'info',
        'Configuration file read, default log level %s',
        $Conf::Conf{'log_level'}
    );
}

my $log_facility = $Conf::Conf{'log_facility'} || $Conf::Conf{'syslog'};
Log::do_openlog($log_facility, $Conf::Conf{'log_socket_type'}, 'bounced');

## Set the User ID & Group ID for the process
$GID = $EGID = (getgrnam(Sympa::Constants::GROUP))[2];
$UID = $EUID = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs
## (effective UID + real UID + saved UID)
POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (useful on OS X)
unless (($GID == (getgrnam(Sympa::Constants::GROUP))[2])
    && ($UID == (getpwnam(Sympa::Constants::USER))[2])) {
    die
        "Failed to change process user ID and group ID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via sudo.\n";
}

## Sets the UMASK
umask(oct($Conf::Conf{'umask'}));

## Change to list root
unless (chdir($Conf::Conf{'home'})) {
    die sprintf "Unable to change directory to %s: %s", $Conf::Conf{'home'},
        $!;
}

Log::do_log('notice', 'Bounced %s Started', Sympa::Constants::VERSION());

## Catch signals, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
$SIG{'INT'}  = \&sigterm;
my $end = 0;

my $spool = $Conf::Conf{'queuebounce'};

Log::do_log('debug', 'Starting infinite loop');
## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {
    ## this sleep is important to be raisonably sure that sympa is not
    ## currently
    ## writting the file this deamon is openning.

    sleep $Conf::Conf{'sleep'};

    Sympa::List::init_list_cache();
    # Process grouped notifications
    Sympa::Alarm->instance->flush;

    my $dh;
    unless (opendir $dh, $spool) {
        die sprintf 'Can\'t open dir %s: %s', $spool, $ERRNO;
        # No return.
    }
    my @qfile =
        sort
        grep { !/,lock/ and !/\A(?:\.|T\.|BAD-)/ and -f ($spool . '/' . $_) }
        readdir $dh;
    closedir $dh;

    foreach my $filename (@qfile) {
        last if $end;

        my $lock_fh =
            Sympa::LockedFile->new($spool . '/' . $filename, -1, '+<');
        next unless $lock_fh;

        my $metadata = tools::unmarshal_metadata(
            $spool, $filename,
            qr{\A([^\s\@]+)(?:\@([\w\.\-]+))?\.(\d+)\.\w+(?:,.*)?\z},
            [qw(localpart domainpart date)]
        );
        next unless $metadata;

        my $msg_string = do { local $RS; <$lock_fh> };
        my $message = Sympa::Message->new($msg_string, %$metadata);
        unless ($message) {
            Log::do_log('notice', 'Ignoring malformed message %s', $message);
            quarantine($lock_fh);
            next;
        }

        unless (defined $message->{'message_id'}
            and length $message->{'message_id'}) {
            Log::do_log('err', 'Message %s has no message ID', $message);
            quarantine($lock_fh);
            next;
        }

        my ($listname, $robot);
        if (ref $message->{context} eq 'Sympa::List') {
            $listname = $message->{context}->{'name'};
            $robot    = $message->{context}->{'domain'};
        }

        my $entity = $message->as_entity;
        my $head   = $entity->head;

        ## Some MTAs decorate To: field of DSN as "mailbox <address>".
        ## Pick address only.
        my $to;
        my $to_header = $head->get('To', 0);
        if ($to_header) {
            my @to = Mail::Address->parse($to_header);
            if (@to and $to[0] and $to[0]->address) {
                $to = lc($to[0]->address);
            }
        }

        my $who;
        my $distribution_id;
        Log::do_log(
            'debug', 'Bounce for: %s: Conf{bounce_email_prefix}=%',
            $to,     $Conf::Conf{'bounce_email_prefix'}
        );

        my $to_re = '^'
            . quotemeta($Conf::Conf{'bounce_email_prefix'})
            . '[+](.*)\@(.*)$';
        if ($to and $to =~ $to_re) {
            # VERP in use.
            my $local_part = $1;
            my $robot      = $2;
            my $unique;
            if ($local_part =~ /^(.*)(\=\=([wr]))$/) {
                # VERP for welcome/remind probe in use.
                $local_part = $1;
                $unique     = $2;
            } elsif ($local_part =~ /^(.*)\=\=a\=\=(.*)\=\=(.*)\=\=(.*)$/) {
                # Tracking in use.
                $distribution_id = $4;
                $local_part =~ /^(.*)\=\=(.*)$/;
                $local_part = $1;
            }

            $local_part =~ s/\=\=a\=\=/\@/;
            $local_part =~ /^(.*)\=\=(.*)$/;
            $who      = $1;
            $listname = $2;

            Log::do_log('notice',
                'VERP in use: bounce related to %s for list %s@%s',
                $who, $listname, $robot);

            if ($unique and $unique =~ /[wr]/) {
                # in this case the bounce result from a remind or a welcome
                # message ;so try to remove the subscriber
                Log::do_log('debug',
                    "VERP for a service message, try to remove the subscriber"
                );
                my $list = Sympa::List->new($listname, $robot);
                unless ($list) {
                    Log::do_log('notice',
                        'Skipping bounce %s for unknown list %s@%s',
                        $message, $listname, $robot);
                    quarantine($lock_fh);
                    next;
                }
                # Overwrite context.
                $message->{context} = $list;

                my $result = Sympa::Scenario::request_action(
                    $list, 'del', 'smtp',
                    {   'sender' => $Conf::Conf{'listmasters'}[0],
                        'email'  => $who
                    }
                );
                my $action;
                $action = $result->{'action'} if (ref($result) eq 'HASH');

                if ($action =~ /do_it/i) {
                    if ($list->is_list_member($who)) {
                        my $u = $list->delete_list_member(
                            'users'   => [$who],
                            'exclude' => ' 1'
                        );
                        Log::do_log('notice',
                            "$who has been removed from $listname because welcome message bounced"
                        );
                        Log::db_log(
                            {   'robot'        => $list->{'domain'},
                                'list'         => $list->{'name'},
                                'action'       => 'del',
                                'target_email' => $who,
                                'status'       => 'error',
                                'error_type'   => 'welcome_bounced',
                                'daemon'       => 'bounced'
                            }
                        );

                        Log::db_stat_log(
                            {   'robot'     => $list->{'domain'},
                                'list'      => $list->{'name'},
                                'operation' => 'auto_del',
                                'parameter' => "",
                                'mail'      => $who,
                                'client'    => "",
                                'daemon'    => 'bounced.pl'
                            }
                        );

                        if ($action =~ /notify/) {
                            $list->send_notify_to_owner(
                                'automatic_del',
                                {   'who'    => $who,
                                    'by'     => 'bounce manager',
                                    'reason' => 'welcome'
                                }
                            );
                        }
                    }
                    remove($lock_fh);
                } else {
                    Log::do_log('notice',
                        "Unable to remove $who from $listname (welcome message bounced but del is closed)"
                    );
                    quarantine($lock_fh);
                }
                next;
            }    # close VERP + remind or welcome block
        }    # close VERP in use block

        my $list = Sympa::List->new($listname, $robot);
        unless ($list) {
            Log::do_log('err', 'Skipping bounce %s for unknown list %s@%s',
                $message, $listname, $robot);
            quarantine($lock_fh);
            next;
        }
        # Overwrite context.
        $message->{context} = $list;

        # ---
        # If the DSN notification is correct and the tracking mode is enable,
        # it will be inserted in the database
        my $tracking_in_use = 1
            if Sympa::Tools::Data::smart_eq(
            $list->{'admin'}{'tracking'}{'delivery_status_notification'},
            'on')
            or Sympa::Tools::Data::smart_eq(
            $list->{'admin'}{'tracking'}{'message_disposition_notification'},
            qr/\A(on|on_demand)\z/
            );

        my $eff_type = $entity->effective_type || '';
        my $report_type =
            lc($head->mime_attr('Content-Type.Report-Type') || '');

        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'delivery-status'
            and $tracking_in_use) {
            my @parts = $entity->parts();
            my $original_rcpt;
            my $final_rcpt;
            my $user_agent;
            my $version;
            my $dsn_status;
            my $listname;
            my $arrival_date;

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/delivery-status') {
                    my @report = split(/\n/, $p->bodyhandle->as_string());
                    foreach my $line (@report) {
                        $line = lc($line);
                        # Action Field MUST be present in a DSN report.
                        # Possible values: failed, delayed, delivered,
                        # relayed, expanded (RFC3464).
                        if ($line =~ /action\:\s*(.+)/i) {
                            $dsn_status = $1;
                            chomp $dsn_status;
                        }

                        if (   ($line =~ /final\-recipient\:\s*(.+)\s*$/i)
                            && (not $final_rcpt)) {
                            $final_rcpt = $1;
                            chomp $final_rcpt;
                            my @rcpt;
                            if ($final_rcpt =~ /.*;.*/) {
                                @rcpt = split /;\s*/, $final_rcpt;
                                foreach my $rcpt (@rcpt) {
                                    if ($rcpt =~ /(\S+\@\S+)/) {
                                        ($rcpt) = $rcpt =~ /(\S+\@\S+)/;
                                        $final_rcpt = $rcpt;
                                    }
                                }
                            } else {
                                ($final_rcpt) = $final_rcpt =~ /(\S+\@\S+)/;
                            }
                        }
                        # # $distribution_id is set using VERP nothing else.
                        # if (    $line =~ /original\-envelope\-id\:\s*(.+)/i
                        #     and not $distribution_id) {
                        #     $distribution_id = $1;
                        #     chomp $distribution_id;
                        #     Log::do_log('debug2',
                        #         "Original Envelope-id Detected, value: %s",
                        #         $distribution_id);
                        # }
                        if ($line =~ /arrival\-date\:\s*(.+)/i) {
                            $arrival_date = $1;
                            chomp $arrival_date;
                        }
                    }
                }
            }

            $original_rcpt = $who;

            if ($final_rcpt =~ /<(\S+\@\S+)>/) {
                ($final_rcpt) = $final_rcpt =~ /<(\S+\@\S+)>/;
            }

            Log::do_log(
                'debug2',
                '%s: DSN detected: dsn_status=%s; original_rcpt=%s; final_rcpt=%s; arrival_date=%s',
                $message,
                $dsn_status,
                $original_rcpt,
                $final_rcpt,
                $arrival_date
            );

            unless ($dsn_status =~ /failed/) {
                # DSN with status "failed" should not be removed because they
                # must be processed for classical bounce managment (not only
                # for tracking feature)
                Log::do_log('notice', 'Non failed DSN status %s',
                    $dsn_status);
                unless ($distribution_id) {
                    Log::do_log(
                        'err',
                        'Envelope ID not found in to address %s of DSN %s, will ignore',
                        $to,
                        $message
                    );
                    remove($lock_fh);
                    next;
                }
                unless ($original_rcpt) {
                    Log::do_log(
                        'err',
                        'Original recipient not found in DSN %s, will ignore',
                        $message
                    );
                    remove($lock_fh);
                    next;
                }
            }

            my $tracking = Sympa::Tracking->new($list);

            if ($tracking->store(
                    $message, $who,
                    envid        => $distribution_id,
                    type         => 'DSN',
                    status       => $dsn_status,
                    arrival_date => $arrival_date
                )
                ) {
                Log::do_log('notice', "DSN Correctly treated...");
            } else {
                Log::do_log('err',
                    'Not able to fill database with notification data');
            }
            unless ($dsn_status =~ /failed/) {
                remove($lock_fh);
                next;
            }
        }
        # ---
        # If the MDN notification is correct and the tracking mode is enabled,
        # it will be inserted in the database
        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'disposition-notification'
            and Sympa::Tools::Data::smart_eq(
                $list->{'admin'}{'tracking'}
                    {'message_disposition_notification'},
                qr/\A(on|on_demand)\z/
            )
            ) {

            my @parts = $entity->parts();
            my $original_rcpt;
            my $final_rcpt;
            my $user_agent;
            my $version;
            my $dsn_status;
            my $listname;
            my $date;
            my $mdn_status;

            $date = $head->get('Date');

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/disposition-notification') {
                    my @report = split(/\n/, $p->bodyhandle->as_string());
                    foreach my $line (@report) {
                        $line = lc($line);
                        # Disposition Field MUST be present in a MDN report.
                        # Possible values: displayed, deleted (RFC3798).
                        if ($line =~ /disposition\:\s*(.+)\s*\;\s*(.+)/i) {
                            $mdn_status = $2;
                            if ($mdn_status =~ /.*\/.*/) {
                                my @results = split /\/\s*/, $mdn_status;
                                $mdn_status = $results[$0];
                                chomp $mdn_status;
                            }
                        }
                        if (   ($line =~ /final\-recipient\:\s*(.+)\s*$/i)
                            && (not $final_rcpt)) {
                            $final_rcpt = $1;
                            chomp $final_rcpt;
                            my @rcpt;
                            if ($final_rcpt =~ /.*;.*/) {
                                @rcpt = split /;\s*/, $final_rcpt;
                                foreach my $rcpt (@rcpt) {
                                    if ($rcpt =~ /(\S+\@\S+)/) {
                                        ($rcpt) = $rcpt =~ /(\S+\@\S+)/;
                                        $final_rcpt = $rcpt;
                                    }
                                }
                            } else {
                                ($final_rcpt) = $final_rcpt =~ /(\S+\@\S+)/;
                            }
                        }
                    }
                }
            }

            if ($original_rcpt =~ /<(\S+\@\S+)>/) {
                ($original_rcpt) = $original_rcpt =~ /<(\S+\@\S+)>/;
            }
            if ($final_rcpt =~ /<(\S+\@\S+)>/) {
                ($final_rcpt) = $final_rcpt =~ /<(\S+\@\S+)>/;
            }
            # let's use VERP
            $original_rcpt = $who;

            Log::do_log(
                'debug2',
                '%s: MDN detected: mdn_status=%s; original_rcpt=%s; date=%s',
                $message,
                $mdn_status,
                $original_rcpt,
                $date
            );

            unless ($distribution_id) {
                Log::do_log(
                    'err',
                    'Envelope ID not found in to address %s of MDN %s, will ignore',
                    $to,
                    $message
                );
                remove($lock_fh);
                next;
            }
            unless ($original_rcpt) {
                Log::do_log('err',
                    'Original recipient not found in MDN %s, will ignore',
                    $message);
                remove($lock_fh);
                next;
            }
            unless ($mdn_status) {
                Log::do_log('err',
                    'MDN status not found in MDN %s, will ignore', $message);
                remove($lock_fh);
                next;
            }

            my $tracking = Sympa::Tracking->new($list);

            unless (
                $tracking->store(
                    $message, $who,
                    envid        => $distribution_id,
                    type         => 'MDN',
                    status       => $mdn_status,
                    arrival_date => $date
                )
                ) {
                Log::do_log('err',
                    'Not able to fill database with notification data');
            }
            Log::do_log('notice', "MDN Correctly treated...");
            remove($lock_fh);
            next;
        }

        if (    $eff_type eq 'multipart/report'
            and $report_type eq 'feedback-report') {
            # This case a report Email Feedback Reports (RFC5965) mainly used
            # by AOL.
            Log::do_log('notice', 'Processing Email Feedback Report');
            my @parts = $entity->parts();
            my $original_rcpt;
            my $user_agent;
            my $version;
            my $feedback_type = '';
            my $listname;
            my $robot;

            foreach my $p (@parts) {
                my $eff_type = $p->effective_type || '';

                if ($eff_type eq 'message/feedback-report') {
                    my @report = split(/\n/, $p->bodyhandle->as_string());
                    foreach my $line (@report) {
                        $feedback_type = 'abuse'
                            if ($line =~ /Feedback\-Type\:\s*abuse/i);
                        if ($line =~ /Feedback\-Type\:\s*(.*)/i) {
                            $feedback_type = $1;
                        }

                        if ($line =~ /User\-Agent\:\s*(.*)/i) {
                            $user_agent = $1;
                        }
                        if ($line =~ /Version\:\s*(.*)/i) {
                            $version = $1;
                        }
                        my $email_regexp = Sympa::Regexps::email();
                        if ($line =~
                            /Original\-Rcpt\-To\:\s*($email_regexp)\s*$/i) {
                            $original_rcpt = $1;
                            chomp $original_rcpt;
                        }
                    }
                } elsif ($eff_type eq 'message/rfc822') {
                    # Log::do_log
                    # ('notice',"xxx processing  Email Feedback Report : message/rfc822 part");
                    my @subparts = $p->parts();
                    foreach my $subp (@subparts) {
                        # Log::do_log ('notice',"xxx subparts : subps");
                        my $subph = $subp->head;
                        $listname = $subph->get('X-Loop');
                    }
                    # Log::do_log
                    # ('notice',"xxx processing  Email Feedback Report : extract listname $listname");
                }
            }
            my $forward;
            ## RFC compliance remark: We do something if there is an abuse or
            ## an unsubscribe request.
            ## We don't throw an error if we find another kind of feedback
            ## (fraud, miscategorized, not-spam, virus or other)
            ## but we don't take action if we meet them yet. This is to be
            ## done, if relevant.
            if ((   $feedback_type =~
                    /(abuse|opt-out|opt-out-list|fraud|miscategorized|not-spam|virus|other)/i
                )
                && (defined $version)
                && (defined $user_agent)
                ) {

                Log::do_log('debug',
                    "Email Feedback Report: $listname feedback-type: $feedback_type"
                );
                if (defined $original_rcpt) {
                    Log::do_log('debug', 'Recognized user: %s list',
                        $original_rcpt);
                    my @lists;

                    if (   ($feedback_type =~ /(opt-out-list|abuse)/i)
                        && (defined $listname)) {
                        $listname = lc($listname);
                        chomp $listname;
                        $listname =~ /(.*)\@(.*)/;
                        $listname = $1;
                        $robot    = $2;
                        my $list = Sympa::List->new($listname, $robot);
                        unless ($list) {
                            Log::do_log(
                                'err',
                                'Skipping Feedback Report %s for unknown list %s@%s',
                                $message,
                                $listname,
                                $robot
                            );
                            quarantine($lock_fh);
                            next;
                        }
                        push @lists, $list;
                    } elsif ($feedback_type =~ /opt-out/
                        && (defined $original_rcpt)) {
                        @lists =
                            Sympa::List::get_which($original_rcpt, $robot,
                            'member');
                    } else {
                        Log::do_log(
                            'notice',
                            'Ignoring Feedback Report %s: Nothing to do for this feedback type.(feedback_type:%s, original_rcpt:%s, listname:%s)',
                            $message,
                            $feedback_type,
                            $original_rcpt,
                            $listname
                        );
                        quarantine($lock_fh);
                    }
                    foreach my $list (@lists) {
                        my $result =
                            Sympa::Scenario::request_action($list,
                            'unsubscribe', 'smtp',
                            {'sender' => $original_rcpt});
                        my $action;
                        $action = $result->{'action'}
                            if (ref($result) eq 'HASH');
                        if ($action =~ /do_it/i) {
                            if ($list->is_list_member($original_rcpt)) {
                                my $u = $list->delete_list_member(
                                    'users'   => [$original_rcpt],
                                    'exclude' => ' 1'
                                );

                                Log::do_log(
                                    'notice',
                                    '%s has been removed from %s because abuse feedback report',
                                    $original_rcpt,
                                    $list
                                );
                                $list->send_notify_to_owner(
                                    'automatic_del',
                                    {   'who' => $original_rcpt,
                                        'by'  => 'listmaster'
                                    }
                                );
                            } else {
                                Log::do_log(
                                    'err',
                                    'Ignore Feedback Report %s for list %s: user %s not subscribed',
                                    $message,
                                    $list,
                                    $original_rcpt
                                );
                                $list->send_notify_to_owner('warn-signoff',
                                    {'who' => $original_rcpt});
                            }
                        } else {
                            $forward = 'request';
                            Log::do_log(
                                'err',
                                'Ignore Feedback Report %s for list %s@%s: user %s is not allowed to unsubscribe',
                                $message,
                                $list,
                                $original_rcpt
                            );
                        }
                    }
                } else {
                    Log::do_log(
                        'err',
                        'Ignoring Feedback Report %s: Unknown Original-Rcpt-To field. Can\'t do anything. (feedback_type:%s, listname:%s)',
                        $message,
                        $feedback_type,
                        $listname
                    );
                    quarantine($lock_fh);
                    tools::send_notify_to_listmaster(
                        $robot,
                        'bounce_management_failed',
                        {   'file' => $lock_fh->basename,
                            'bad'  => "$spool/bad",
                            'error' =>
                                "Unknown Original-Rcpt-To field (feedback_type:$feedback_type, listname:$listname)",
                        }
                    );
                }
            } else {
                Log::do_log(
                    'err',
                    'Ignoring Feedback Report %s: Unknown format (feedback_type:%s, original_rcpt:%s, listname:%s)',
                    $message,
                    $feedback_type,
                    $original_rcpt,
                    $listname
                );
                quarantine($lock_fh);
                tools::send_notify_to_listmaster(
                    $robot,
                    'bounce_management_failed',
                    {   'file' => $lock_fh->basename,
                        'bad'  => "$spool/bad",
                        'error' =>
                            "Unknown format (feedback_type:$feedback_type, original_rcpt:$original_rcpt, listname:$listname)",
                    }
                );
            }
            if (-f "$spool/$filename") {
                remove($lock_fh);
            }
            next;
        }

        # Fin section feedback report
        # else (not welcome or remind)
        $list = Sympa::List->new($listname, $robot);
        unless ($list) {
            Log::do_log('err',
                'Skipping bouncefile %s for unknown list %s@%s',
                $message, $listname, $robot);
            quarantine($lock_fh);
            next;
        }
        # Overwrite context.
        $message->{context} = $list;

        Log::do_log('debug', 'Processing bounce %s for list %s',
            $message, $list);

        my (%hash, $from);

        ## RFC1891 compliance check
        my $bounce_count = Bounce::rfc1891($message, \%hash, \$from);

        unless ($bounce_count) {
            # Analysis of bounced message
            Bounce::anabounce($message, \%hash, \$from);
            # Voir pour appeler une methode de parsing des dsn qui maj la
            # bdd
            # updatedatabase(%hash);
        }

        my $tracking = Sympa::Tracking->new($list);

        my $adr_count;
        ## Bouncing addresses
        # Voir si pas mettre un test conditionnel sur le status code pour
        # detecter les dsn positifs et ne pas fausser les statistiques de
        # l'abonné.
        # Peut être possibilité de lancer la maj des tables pour chaque
        # recipient ici a condition d'avoir approfondi le parsing en
        # amont.
        while (my ($rcpt, $status) = each %hash) {
            $adr_count++;
            my $bouncefor = $who;
            $bouncefor ||= $rcpt;

            unless ($tracking->store($message, $bouncefor)) {
                quarantine($lock_fh);
                next;
            }
            next
                unless
                update_subscriber_bounce_history(
                    $list, $rcpt, $bouncefor, canonicalize_status($status)
                );
        }

        ## No address found in the bounce itself
        unless ($adr_count) {
            if ($who) {
                # rcpt not recognized in the bounce but VERP was used
                # Status is undefined.
                update_subscriber_bounce_history($list, 'unknown', $who);
                unless ($tracking->store($message, $who)) {
                    quarantine($lock_fh);
                } else {
                    remove($lock_fh);
                }
            } else {    # no VERP and no rcpt recognized
                my $escaped_from = tools::escape_chars($from);
                Log::do_log('info',
                    'No address found in message from %s for list %s',
                    $from, $list);
                quarantine($lock_fh);
                next;
            }
        }

        if (-f "$spool/$filename") {    #FIXME
            remove($lock_fh);
        }
    }

    ## Free zombie sendmail processes
    Sympa::Mailer->instance->reaper();
}

# Purge grouped notifications
Sympa::Alarm->instance->flush(purge => 1);

Log::do_log('notice', 'Bounced exited normally due to signal');
Sympa::Tools::Daemon::remove_pid('bounced', $PID);

exit(0);

## When we catch signal, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

## copy the bounce to the appropriate filename
# Moved: Use Sympa::Tracking::store().
#sub store_bounce;

## Set error message to a status RFC1893 compliant
sub canonicalize_status {

    my $status = shift;

    if ($status !~ /^\d+\.\d+\.\d+$/) {
        if ($equiv{$status}) {
            $status = $equiv{$status};
        } else {
            return undef;
        }
    }
    return $status;
}

## update subscriber information
# $bouncefor : the email address the bounce is related for (may be extracted
#              using VERP)
# $rcpt : the email address recognized in the bounce itself. In most case
#         $rcpt eq $bouncefor

sub update_subscriber_bounce_history {

    my $list      = shift;
    my $rcpt      = shift;
    my $bouncefor = shift;
    my $status    = shift;

    Log::do_log('debug', '(%s, %s, %s, %s)',
        $list->{'name'}, $rcpt, $bouncefor, $status);

    my $first = my $last = time;
    my $count = 0;

    my $user = $list->get_list_member($bouncefor);

    unless ($user) {
        Log::do_log('notice', 'Subscriber not found in list %s: %s',
            $list->{'name'}, $bouncefor);
        return undef;
    }

    if ($user->{'bounce'} =~ /^(\d+)\s\d+\s+(\d+)/) {
        ($first, $count) = ($1, $2);
    }
    $count++;
    if ($rcpt ne $bouncefor) {
        Log::do_log('notice',
            'Bouncing address identified with VERP: %s / %s',
            $rcpt, $bouncefor);
        Log::do_log('debug', '(%s, bounce-> %s %s %s %s, bounce_address->%s)',
            $bouncefor, $first, $last, $count, $status, $rcpt);
        $list->update_list_member(
            $bouncefor,
            {   'bounce'         => "$first $last $count $status",
                'bounce_address' => $rcpt
            }
        );
        Log::db_log(
            {   'robot'        => $list->{'domain'},
                'list'         => $list->{'name'},
                'action'       => 'get_bounce',
                'parameters'   => "address=$rcpt",
                'target_email' => $bouncefor,
                'msg_id'       => '',
                'status'       => 'error',
                'error_type'   => $status,
                'daemon'       => 'bounced'
            }
        );
    } else {
        $list->update_list_member($bouncefor,
            {'bounce' => "$first $last $count $status"});
        Log::do_log('notice', 'Received bounce for email address %s, list %s',
            $bouncefor, $list->{'name'});
        Log::db_log(
            {   'robot'        => $list->{'domain'},
                'list'         => $list->{'name'},
                'action'       => 'get_bounce',
                'target_email' => $bouncefor,
                'msg_id'       => '',
                'status'       => 'error',
                'error_type'   => $status,
                'daemon'       => 'bounced'
            }
        );
    }
}

# If bounce can't be handled correctly, saves it to the "bad" subdirectory of
# the bounce spool.
sub quarantine {
    my $lock_fh = shift;
    my $robot = shift || '*';

    my $bad_dir  = "$spool/bad";
    my $filename = $lock_fh->basename;

    if (-d $bad_dir) {
        unless ($lock_fh->rename($bad_dir . '/' . $filename)) {
            die sprintf
                'Unable to rename bad file %s to %s/%s: %s',
                $filename, $bad_dir, $filename, $lock_fh->last_error;
        }
        Log::do_log('notice', "Moving bad file %s to bad/", $filename);
    } else {
        Log::do_log('notice', 'Missing directory "%s"', $bad_dir);
        unless ($lock_fh->rename($spool . '/BAD-' . $filename)) {
            die sprintf
                'Unable to rename bad file %s to BAD-%s: %s',
                $filename, $filename, $lock_fh->last_error;
        }
        Log::do_log('notice', "Renaming bad file %s to BAD-%s",
            $filename, $filename);
    }
}

sub remove {
    my $lock_fh = shift;

    $lock_fh->unlink;
}

__END__

=encoding utf-8

=head1 NAME

bounced, bounced.pl - Mailing List Bounce Processing Daemon for Sympa

=head1 SYNOPSIS

S<B<bounced> [ B<--foreground> ] [ B<--debug> ]>

=head1 DESCRIPTION

Bounced is a program which scans permanently the bounce spool and
processes bounces (non-delivery messages), looking or bad addresses.
Bouncing addresses are tagged in database ; last bounce is kept for
each bouncing address.

List owners will latter access bounces information via WWSympa.

=head1 OPTIONS

These programs follow the usual GNU command line syntax,
with long options starting with two dashes (C<-->).  A summary of
options is included below.

=over 5

=item B<-F>, B<--foreground>

Do not detach TTY.

=item B<-f>, B<--config=>I<file>

Force bounced to use an alternative configuration file instead
of F<--CONFIG-->.

=item B<-d>, B<--debug>

Run the program in a debug mode.

=item B<-h>, B<--help>

Print this help message.

=item B<--log_level=>I<level>

Sets daemon log level.

=back

=head1 FILES

F<--CONFIG--> Sympa configuration file.

F<--libexecdir--/bouncequeue> bounce spooler, referenced from sendmail alias file

F<--spooldir--/bounce> incoming bounces directory

F<--piddir--/bounced.pid> this file contains the process ID
of F<bounced.pl>.

=head1 MORE DOCUMENTATION

The full documentation can be
found in L<http://www.sympa.org/manual/>.

The mailing lists (with web archives) can be accessed at
L<http://listes.renater.fr/sympa/lists/informatique/sympa>.

=head1 HISTORY

This program was originally written by:

=over 4

=item Serge Aumont

ComitE<233> RE<233>seau des UniversitE<233>s

=item Olivier SalaE<252>n

ComitE<233> RE<233>seau des UniversitE<233>s

=back

This manual page was initially written by
JE<233>rE<244>me Marant <jerome.marant@IDEALX.org>
for the Debian GNU/Linux system.

=head1 LICENSE

You may distribute this software under the terms of the GNU General
Public License Version 2.  For more details see F<README> file.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts and no Back-Cover Texts.  A
copy of the license can be found under
L<http://www.gnu.org/licenses/fdl.html>.

=head1 BUGS

Report bugs to Sympa bug tracker.
See L<http://www.sympa.org/tracking>.

=head1 SEE ALSO

L<sympa(8)>, L<wwsympa(8)>, L<mhonarc(1)>, L<sympa.conf(5)>.

=cut
