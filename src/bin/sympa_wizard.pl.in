#!--PERL--
# -*- indent-tabs-mode: nil; -*-
# vim:ft=perl:et:sw=4
# $Id$

# Sympa - SYsteme de Multi-Postage Automatique
#
# Copyright (c) 1997-1999 Institut Pasteur & Christophe Wolfhugel
# Copyright (c) 1997-2011 Comite Reseau des Universites
# Copyright (c) 2011-2014 GIP RENATER
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=encoding utf-8

=head1 NAME

sympa_wizard, sympa_wizard.pl - Help Performing Sympa Initial Setup
    
=head1 SYNOPSIS

S<B<sympa_wizard.pl>>
    S<[B<--check>]>
    S<[B<--create> [B<--target=>I<file>]]>
    S<[B<-h, --help>]>
    S<[B<-v, --version>]>

=head1 OPTIONS

=over 4

=item sympa_wizard.pl

Edit current Sympa configuration.

=item sympa_wizard.pl --check

Check CPAN modules needed for running Sympa.

=item sympa_wizard.pl --create [--target file]

Creates a new F<sympa.conf> configuration file.

=item sympa_wizard.pl --help

Display usage instructions.

=item sympa_wizard.pl --version

Print version number.

=back

=head1 AUTHORS

=over 4

=item Serge Aumont <sa@cru.fr>

=item Olivier SalaE<252>n <os@cru.fr>

=back

=cut

use strict;
use warnings;
use lib '--modulesdir--';

use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage;
use Sys::Hostname qw(hostname);

use Sympa::Constants;
use Sympa::Language;
use Sympa::Tools::Text;

## check if CPAN modules might be missing
my $modfail;

BEGIN {
    eval { require Sympa::Site; };
    $modfail = 1 if $EVAL_ERROR;
}

# Detect console encoding.
if (-t) {
    no warnings;

    eval { require Encode::Locale; };
    unless ($EVAL_ERROR
        or Encode::resolve_alias($Encode::Locale::ENCODING_CONSOLE_IN) eq
        'ascii'
        or Encode::resolve_alias($Encode::Locale::ENCODING_CONSOLE_OUT) eq
        'ascii') {
        binmode(STDIN,  ':encoding(console_in):bytes');
        binmode(STDOUT, ':encoding(console_out):bytes');
        binmode(STDERR, ':encoding(console_out):bytes');
    }
}

# Set language context if possible.
if ($modfail) {
    no warnings;

    *Sympa::Language::gettext = sub {shift};

    eval { require Text::Wrap; };
    if ($EVAL_ERROR) {
        *Sympa::Tools::Text::wrap_text = sub {"$_[1]$_[0]\n"};
    } else {
        $Text::Wrap::columns = 78;
        *Sympa::Tools::Text::wrap_text =
            sub { Text::Wrap::wrap($_[1], $_[2], $_[0]) . "\n"; };
    }
} else {
    my $lang = $ENV{'LANGUAGE'} || $ENV{'LC_ALL'} || $ENV{'LANG'};
    $lang =~ s/\..*// if $lang;
    $lang = 'en' unless $lang and $lang ne 'C' and $lang ne 'POSIX';
    Sympa::Language::SetLang($lang);
}

## sympa configuration file
my $sympa_conf = Sympa::Constants::CONFIG;

## version string.
my $version_string =
    sprintf Sympa::Language::gettext('Sympa version is %s.') . "\n",
    Sympa::Constants::VERSION;

my %options;
unless (
    GetOptions(
        \%options,
        'target=s',
        'create:s',    # parameter is optional
        'check',
        'help|h',
        'version|v'
    )
    ) {
    pod2usage(-exitval => 1, -output => \*STDERR);
}

if ($options{help}) {
    pod2usage();
} elsif ($options{'version'}) {
    print $version_string;
} elsif (defined $options{create}) {
    create_configuration();
} elsif ($options{check}) {
    check_cpan();
} else {
    edit_configuration();
}

exit 0;

sub create_configuration {
    require Sympa::ConfDef;

    my $conf;
    if ($options{create} eq '' or $options{create} eq 'sympa.conf') {
        $conf = $options{target} ? $options{target} : $sympa_conf;
    } else {
        pod2usage(
            sprintf Sympa::Language::gettext('%s is not a valid argument.'),
            $options{'create'});
        exit 1;
    }

    if (-f $conf) {
        printf STDERR
            Sympa::Language::gettext('%s file already exists.') . "\n",
            $conf;
        exit 1;
    }

    unless (open NEWF, '>', $conf) {
        die sprintf Sympa::Language::gettext('Unable to open %s: %s') . "\n",
            $conf, $ERRNO;
    }

    # print NEWF
    # Sympa::Tools::Text::wrap_text(Sympa::Language::gettext("Configuration file for Sympa\nMany parameters are optional.\nPlease refer to the documentation for a detailed list of parameters."),
    # '## ', '## ') . "\n\n";

    my $title;
    foreach my $param (@Sympa::ConfDef::params) {
        unless ($param->{'name'}) {
            $title = Sympa::Language::gettext($param->{'gettext_id'})
                if $param->{'gettext_id'};
            next;
        }

        next unless $param->{'file'};
        next unless defined $param->{'default'} or defined $param->{'sample'};

        if ($title) {
            printf NEWF Sympa::Language::gettext('###\\\\\\\\ %s ////###')
                . "\n\n",
                $title;
            undef $title;
        }

        print NEWF Sympa::Tools::Text::wrap_text(
            Sympa::Language::gettext($param->{'gettext_id'}),
            '## ', '## ')
            if (defined $param->{'gettext_id'});

        print NEWF Sympa::Tools::Text::wrap_text(
            Sympa::Language::gettext($param->{'gettext_comment'}),
            '## ', '## ')
            if (defined $param->{'gettext_comment'});

        if (defined $param->{'sample'}) {
            printf NEWF "#%s\t%s\n\n", $param->{'name'}, $param->{'sample'};
        } elsif (defined $param->{'default'}) {
            printf NEWF "%s\t%s\n\n", $param->{'name'}, $param->{'default'};
        }
    }

    close NEWF;
    printf STDERR Sympa::Language::gettext('%s file has been created.')
        . "\n",
        $conf;
}

sub edit_configuration {
    die Sympa::Language::gettext('You must run as superuser.') . "\n"
        if $UID;
    die Sympa::Language::gettext(
        "Installation of Sympa has not been completed.\nRun sympa_wizard.pl --check."
        )
        . "\n"
        if $modfail;

    require Sympa::Robot;

    # complement required fields.
    foreach my $param (@Sympa::ConfDef::params) {
        next unless $param->{'name'};
        if ($param->{'name'} eq 'domain') {
            $param->{'default'} = hostname();
        } elsif ($param->{'name'} eq 'wwsympa_url') {
            $param->{'default'} = sprintf 'http://%s/sympa', hostname();
        }
    }

    ## Load sympa config (but not using database)
    unless (
        defined Sympa::Robot::get_robots('config_file' => $sympa_conf,
            'no_db' => 1)) {
        Sympa::Log::Syslog::fatal_err(
            Sympa::Language::gettext(
                'Unable to load sympa configuration.  File %s or one of the virtual host robot.conf files contain errors.'
            ),
            $sympa_conf
        );
    }

    my $new_sympa_conf = '/tmp/sympa.conf';
    my $somechange     = 0;

    my @new_sympa_conf;
    my $title = undef;

    # dynamic defaults
    my $domain    = hostname();
    my $http_host = "http://$domain";

    ## Edition mode
    foreach my $param (@Sympa::ConfDef::params) {
        unless ($param->{'name'}) {
            $title = Sympa::Language::gettext($param->{'gettext_id'})
                if $param->{'gettext_id'};
            next;
        }

        my $file  = $param->{'file'};
        my $name  = $param->{'name'};
        my $query = $param->{'gettext_id'} || '';
        $query = Sympa::Language::gettext($query) if $query;
        my $advice = $param->{'gettext_comment'};
        $advice = Sympa::Language::gettext($advice) if $advice;
        my $sample = $param->{'sample'};
        my $current_value;

        next unless $file;
        if ($file eq 'sympa.conf' or $file eq 'wwsympa.conf') {
            $current_value = Sympa::Site->$name;
            $current_value = '' unless defined $current_value;
        } else {
            next;
        }

        if ($title) {
            ## write to conf file
            push @new_sympa_conf,
                sprintf(
                Sympa::Language::gettext('###\\\\\\\\ %s ////###') . "\n\n",
                $title
                );
        }

        my $new_value = '';
        if ($param->{'edit'} and $param->{'edit'} eq '1') {
            print "\n\n** $title **\n" if $title;

            print "\n";
            print Sympa::Tools::Text::wrap_text($query || '', '* ', '  ');
            print Sympa::Tools::Text::wrap_text($advice, '  ... ', '  ') if $advice;
            printf(Sympa::Language::gettext('%s [%s] : '),
                $name, $current_value);
            $new_value = <STDIN>;
            chomp $new_value;
        }
        if ($new_value eq '') {
            $new_value = $current_value;
        }

        undef $title;

        ## Skip empty parameters
        next if $new_value eq '' and !$sample;

        ## param is an ARRAY
        if (ref($new_value) eq 'ARRAY') {
            $new_value = join ',', @{$new_value};
        }

        unless ($file eq 'sympa.conf' or $file eq 'wwsympa.conf') {
            printf STDERR Sympa::Language::gettext(
                'Incorrect parameter definition: %s')
                . "\n",
                $file;
        }

        if ($new_value eq '') {
            next unless $sample;

            push @new_sympa_conf,
                Sympa::Tools::Text::wrap_text($query, '## ', '## ');

            if (defined $advice and length $advice) {
                push @new_sympa_conf,
                    Sympa::Tools::Text::wrap_text($advice, '## ', '## ');
            }

            push @new_sympa_conf, "# $name\t$sample\n\n";
        } else {
            push @new_sympa_conf,
                Sympa::Tools::Text::wrap_text($query, '## ', '## ');
            if (defined $advice and length $advice) {
                push @new_sympa_conf,
                    Sympa::Tools::Text::wrap_text($advice, '## ', '## ');
            }

            if ($current_value ne $new_value) {
                push @new_sympa_conf,
                    sprintf(
                    '# ' . Sympa::Language::gettext('was %s %s') . "\n",
                    $name, $current_value);
                $somechange = 1;
            }

            push @new_sympa_conf, "$name\t$new_value\n\n";
        }
    }

    if ($somechange) {

        my $date =
            Sympa::Language::gettext_strftime("%d.%b.%Y-%H.%M.%S",
            localtime(time));

        ## Keep old config file
        unless (rename $sympa_conf, $sympa_conf . '.' . $date) {
            warn sprintf
                Sympa::Language::gettext('Unable to rename %s: %s'),
                $sympa_conf, $ERRNO;
        }

        ## Write new config file
        my $umask = umask 037;
        unless (open(SYMPA, "> $sympa_conf")) {
            umask $umask;
            die sprintf
                Sympa::Language::gettext('Unable to open %s: %s'),
                $sympa_conf, $ERRNO;
        }
        umask $umask;
        chown [getpwnam(Sympa::Constants::USER)]->[2],
            [getgrnam(Sympa::Constants::GROUP)]->[2], $sympa_conf;

        print SYMPA @new_sympa_conf;
        close SYMPA;

        printf Sympa::Language::gettext(
            "%s have been updated.\nPrevious version has been saved as %s.%s."
            )
            . "\n",
            $sympa_conf, $sympa_conf, $date;
    }
}

sub check_cpan {
    require CPAN;
    require Sympa::ModDef;

    print '#' x 78 . "\n";
    print Sympa::Tools::Text::wrap_text(
        Sympa::Language::gettext(
            "This process will help you install all Perl (CPAN) modules required by Sympa software.\nSympa requires from 50 to 65 additional Perl modules to run properly.  The whole installation process should take around 15 minutes.\nYou will first have to configure the CPAN shell itself and select your favourite CPAN server.\nNote that you might prefer to install the required Perl modules using your favourite DEB/RPM mechanism.\nFeel free to interrupt the process if needed ; you can restart it safely afterward."
            )
            . "\n",
        '# ', '# '
    );
    print '#' x 78 . "\n";
    print Sympa::Language::gettext('Strike the Enter key to continue...')
        . "\n";

    my $rep = <STDIN>;

    ### main:
    print Sympa::Language::gettext('******* Check Perl for Sympa ********')
        . "\n";
    ### REQ perl version
    print "\n";
    print Sympa::Language::gettext(
        "Checking for Perl version:\n-----------------------------")
        . "\n";
    my $rpv = $Sympa::ModDef::cpan_modules{"perl"}{'required_version'};
    if ($] >= $rpv) {
        printf Sympa::Language::gettext(
            'Your version of Perl is OK (%s >= %s).')
            . "\n",
            $], $rpv;
    } else {
        printf Sympa::Language::gettext(
            "Your version of Perl is TOO OLD (%s < %s).\nPlease INSTALL a new one!"
            )
            . "\n",
            $], $rpv;
    }

    print "\n";
    print Sympa::Language::gettext(
        "Checking for REQUIRED modules:\n----------------------------------------------------------"
    ) . "\n";
    check_modules('y', \%Sympa::ModDef::cpan_modules, 'mandatory');
    print "\n";
    print Sympa::Language::gettext(
        "Checking for OPTIONAL modules:\n----------------------------------------------------------"
    ) . "\n";
    check_modules('n', \%Sympa::ModDef::cpan_modules, 'optional');

    print Sympa::Tools::Text::wrap_text(
        Sympa::Language::gettext(
            "******* NOTE *******\nYou can retrieve all these modules from any CPAN server (for example ftp://ftp.pasteur.fr/pub/computing/CPAN/CPAN.html)."
            )
            . "\n"
    );
###--------------------------
    # reports modules status
    # $moddef::cpan_modules is the cpan_modules structure
    # $type is the type of modules (mandatory | optional) that should be
    # installed
###--------------------------
}

sub check_modules {
    my ($default, $cpan_modules, $type) = @_;

    print Sympa::Language::gettext(
        'Perl module                from CPAN                STATUS')
        . "\n";
    print Sympa::Language::gettext(
        '-----------                ---------                ------')
        . "\n";

    foreach my $mod (sort keys %$cpan_modules) {

        ## Only check modules of the expected type
        if ($type eq 'mandatory') {
            next unless ($cpan_modules->{$mod}{mandatory});
        } elsif ($type eq 'optional') {
            next if ($cpan_modules->{$mod}{mandatory});
        }

        ## Skip perl itself to prevent a huge upgrade
        next if ($mod eq 'perl');

        printf('%-26s %-24s ', $mod, $cpan_modules->{$mod}{package_name});

        eval "require $mod";
        if ($EVAL_ERROR) {
            ### not installed
            print Sympa::Language::gettext('not found on this system.')
                . "\n";
            install_module($mod, {'default' => $default}, $cpan_modules);
        } else {

            my ($vs, $v);

            ## MHonArc module does not provide its version the standard way
            if ($mod =~ /^MHonArc/i) {
                require "mhamain.pl";
                $v = $mhonarc::VERSION;
            } else {
                $vs = "$mod" . "::VERSION";
                {
                    no strict 'refs';
                    $v = $$vs;
                }
            }

            my $rv = $cpan_modules->{$mod}{required_version} || '1.0';
            ### OK: check version
            if ($v ge $rv) {
                printf Sympa::Language::gettext('OK (%-6s >= %s).') . "\n",
                    $v, $rv;
                next;
            } else {
                printf
                    Sympa::Language::gettext('too old (%s < %s).') . "\n",
                    $v, $rv;
                printf Sympa::Language::gettext(
                    '>>>>>>> You must update "%s" to version "%s" <<<<<<')
                    . "\n",
                    $mod, $cpan_modules->{$mod}{required_version};
                install_module($mod, {'default' => $default}, $cpan_modules);
            }
        }
    }
}

##----------------------
# Install a CPAN module
##----------------------
sub install_module {
    my ($module, $options, $cpan_modules) = @_;

    my $default = $options->{'default'};

    unless ($ENV{'FTP_PASSIVE'} and $ENV{'FTP_PASSIVE'} eq 1) {
        $ENV{'FTP_PASSIVE'} = 1;
        print Sympa::Language::gettext('Setting FTP Passive mode.') . "\n";
    }

    unless ($EUID == 0) {
        printf Sympa::Language::gettext(
            '## You need root privileges to install %s module. ##')
            . "\n",
            $module;
        print Sympa::Language::gettext(
            '## Press the Enter key to continue checking modules. ##')
            . "\n";
        my $t = <STDIN>;
        return undef;
    }

    unless ($options->{'force'}) {
        print Sympa::Tools::Text::wrap_text(
            sprintf(
                Sympa::Language::gettext('-> Usage of this module: %s')
                    . "\n",
                Sympa::Language::gettext(
                    $cpan_modules->{$module}{'gettext_id'}
                )
            ),
            '', '   '
        ) if $cpan_modules->{$module}{'gettext_id'};
        print Sympa::Tools::Text::wrap_text(
            sprintf(
                Sympa::Language::gettext('-> Prerequisites: %s') . "\n",
                Sympa::Language::gettext(
                    $cpan_modules->{$module}{'gettext_comment'}
                )
            ),
            '', '   '
        ) if $cpan_modules->{$module}{'gettext_comment'};
        printf Sympa::Language::gettext('-> Install module "%s"? [%s] '),
            $module, $default;
        my $answer = <STDIN>;
        chomp $answer;
        $answer ||= $default;
        return unless ($answer =~ /^y$/i);
    }

    # This is required on RedHat 9 for DBD::mysql installation
    my $lang = $ENV{'LANG'};
    $ENV{'LANG'} = 'C' if ($ENV{'LANG'} =~ /UTF\-8/);

    ## disable timeout to prevent timeout during modules installation
    $CPAN::Config->{'inactivity_timeout'} = 0;
    $CPAN::Config->{'colorize_output'}    = 1;
    ## automatically installed prerequisites without asking
    $CPAN::Config->{'build_requires_install_policy'} = 'yes';
    ## build prerequisites automatically
    $CPAN::Config->{'prerequisites_policy'} = 'follow';
    ## minimum verbosity during module loading
    $CPAN::Config->{'load_module_verbosity'} = 'none';
    ## minimum verbosity with tar command
    $CPAN::Config->{'tar_verbosity'} = 'none';

    #CPAN::Shell->clean($module) if ($options->{'force'});

    CPAN::Shell->make($module);

    if ($options->{'force'}) {
        CPAN::Shell->force('test', $module);
    } else {
        CPAN::Shell->test($module);
    }

    CPAN::Shell->install($module);
    ##FIXME: Could use CPAN::Shell->force('install') if make test failed

    # Restore lang
    $ENV{'LANG'} = $lang if (defined $lang);

    ## Check if module has been successfuly installed
    unless (eval "require $module") {

        ## Prevent recusive calls if already in force mode
        if ($options->{'force'}) {
            printf Sympa::Language::gettext(
                "Installation of %s still FAILED. You should download the tar.gz from http://search.cpan.org and install it manually.\nHit the Enter key."
                ),
                $module;
            my $answer = <STDIN>;
        } else {
            printf Sympa::Language::gettext(
                'Installation of %s FAILED. Do you want to force the installation of this module? (y/N) '
                ),
                $module;
            my $answer = <STDIN>;
            chomp $answer;
            if ($answer =~ /^y/i) {
                install_module($module, {'force' => 1}, $cpan_modules);
            }
        }
    }
}
