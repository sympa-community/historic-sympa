#!--PERL--
# bounced.pl - This script runs as a daemon ; it does the incoming 
# non-delivery reports analysis and storage
# RCS Identication ; $Revision$ ; $Date$
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


## Worl Wide Sympa is a front-end to Sympa Mailing Lists Manager
## Copyright Comite Reseau des Universites

## Patch 2001.07.24 by nablaphi <nablaphi@bigfoot.com>
## Change the Getopt::Std to Getopt::Long

## Options :  F         -> do not detach TTY
##         :  d		-> debug -d is equiv to -dF
## Now, it is impossible to use -dF but you have to write it -d -F

use lib '--modulesdir--';
use strict;

use FileHandle;
#use Getopt::Std;
use Getopt::Long;
use POSIX;

use List;
#use Conf; # used in List - Site
#use Log; # used in Conf
#use mail; # used in List

#use tt2; # used in List
#use tools; # used in Conf
#use Sympa::Constants; # used in Conf - confdef
use tracking;

## Equivalents relative to RFC 1893
my %equiv = ( "user unknown" => '5.1.1',
	      "receiver not found" => '5.1.1',
	      "the recipient name is not recognized" => '5.1.1',
	      "sorry, no mailbox here by that name" => '5.1.1',
	      "utilisateur non recens\xE9 dans le carnet d'adresses public" => '5.1.1',
	      "unknown address" => '5.1.1',
	      "unknown user" => '5.1.1',
	      "550" => '5.1.1',
	      "le nom du destinataire n'est pas reconnu" => '5.1.1',
	      "user not listed in public name & address book" => '5.1.1',
	      "no such address" => '5.1.1',
	      "not known at this site." => '5.1.1',
	      "user not known" => '5.1.1',
	      
	      "user is over the quota. you can try again later." => '4.2.2',
	      "quota exceeded" => '4.2.2',
	      "write error to mailbox, disk quota exceeded" => '4.2.2',
	      "user mailbox exceeds allowed size" => '4.2.2',
	      "insufficient system storage" => '4.2.2',
	      "User's Disk Quota Exceeded:" => '4.2.2');


use Bounce;
use BounceMessage;
#use wwslib; # no longer used

#getopts('dF');
## Check options
my %options;
unless (&GetOptions(\%main::options, 'debug|d','log_level=s','foreground|F')) {
    &Log::fatal_err("Unknown options.");
}

# $main::options{'debug2'} = 1 if ($main::options{'debug'});

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'debug'} || $main::options{'foreground'});

my $daemon_name = &Log::set_daemon($0);
my $ip = $ENV{'REMOTE_HOST'};

# Load sympa.conf
unless (defined Robot::get_robots()) {
    Log::fatal_err(
	'Unable to load sympa configuration, file %s has errors.',
	Conf::get_sympa_conf()
    );
}

##unshift @INC, Site->wws_path;

## Check databse connectivity
unless (&SDM::check_db_connect()) {
    &Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', Site->db_name);
}

## Put ourselves in background if not in debug mode. 
unless ($main::options{'debug'} || $main::options{'foreground'}) {

    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
       ioctl(TTY, 0x20007471, 0);         # XXX s/b &TIOCNOTTY
#	ioctl(TTY, &TIOCNOTTY, 0);
	close(TTY);
    }
    setpgrp(0, 0);
    if ((my $child_pid = fork) != 0) {
	print STDOUT "Starting bounce daemon, pid $_\n";

	exit(0);
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the pidfile
&tools::write_pid(Site->bounced_pidfile, $$, $options);
unless ($options->{'stderr_to_tty'}) {
    &tools::direct_stderr_to_file(('pid' => $$));
}

if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
	'info', 'Configuration file read, log level set using options : %s',
	$main::options{'log_level'}
    ); 
} else {
    Log::set_log_level(Site->log_level);
    Log::do_log(
	'info', 'Configuration file read, default log level %s',
	Site->log_level
    ); 
}

&Log::do_openlog(Site->log_facility, Site->log_socket_type, 'bounced');

## Set the UserID & GroupID for the process
$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
$< = $> = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
    &Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct(Site->umask));

## Change to list root
unless (chdir(Site->home)) {
    &Log::do_log('info', 'Unable to change directory');
    exit (-1);
}

my $pinfo = &List::_apply_defaults();

&Log::do_log('notice', "bounced Started");

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $spool = new Sympaspool('bounce');


&Log::do_log('debug','starting infinite loop');
## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {
    
    sleep Site->sleep;
    
    &List::init_list_cache();
    # Process grouped notifications
    Site->send_notify_to_listmaster(undef, undef, 1, undef);

    my $spooled_bounce;
    while ($spooled_bounce = $spool->next){
	my $bounce;
	unless ($bounce = new BounceMessage({'message_in_spool' => $spooled_bounce})) {
	    Log::do_log('err','Message %s: badly formatted bounce message. Ignoring.',$spooled_bounce->{'messagekey'});
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	    next;
	}
	Log::do_log('info','Processing bounce %s (key %s) for list %s@%s',$bounce->get_msg_id,$spooled_bounce->{'messagekey'},$spooled_bounce->{'list'},$spooled_bounce->{'robot'});
	
	my $list = $bounce->{'list'};
	&Log::do_log('debug', 'bounce for :%s:  Site->bounce_email_prefix=%s',
	    $bounce->{'to'}, Site->bounce_email_prefix);
		
	$bounce->{'to'} =~ s/<//;
	$bounce->{'to'} =~ s/>//;
	if ($bounce->is_verp_in_use) { #VERP in use
	    $bounce->analyze_verp_header();
	    if ($bounce->failed_on_first_try) { # in this case the bounce result from a remind or a welcome message ;so try to remove the subscriber
		Log::do_log('debug', "VERP for a service message, trying to remove the subscriber");
		unless($bounce->update_list($bounce->{'listname'},$bounce->{'robotname'})) {
		    &Log::do_log('notice','Skipping bounce where messagekey = %s for unknown list %s@%s',$bounce->{'messagekey'},$bounce->{'listname'},$bounce->{'robotname'});
		    $spool->move_to_bad($bounce->{'messagekey'});
		    next;
		}
		unless ($bounce->delete_bouncer) {
		    &Log::do_log ('notice',"Unable to remove $bounce->{'who'} from $bounce->{'listname'} (welcome message bounced but del is closed)");
		    $spool->move_to_bad($bounce->{'messagekey'});
		}
		$spool->remove_message({'messagekey'=>$bounce->{'messagekey'}});
		next;
	    }# close VERP + remind or welcome block
	}# close VERP in use block

	my $list = new List ($bounce->{'listname'}, $bounce->{'robotname'});
	unless($list) {
	    &Log::do_log('err','Skipping bounce where messagekey= %s for unknown list %s@%s',$bounce->{'messagekey'},$bounce->{'listname'},$bounce->{'robotname'});
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	    next;
	}
	
	#----------------------------------------------------------------------------------------------------------------------
	# If the DSN notification is correct and the tracking mode is enable, it will be inserted in the database
	my $tracking_in_use = $bounce->tracking_is_used;
	if($bounce->is_dsn) {
	    unless ($bounce->process_dsn) {
		Log::do_log('err','Delivery status notification processing for bounce %s (key %s) failed. Stopping here.',$bounce->get_msg_id,$bounce->{'messagekey'});
		$spool->move_to_bad($bounce->{'messagekey'});
		next;
	    }
	    unless($bounce->{'dsn_status'} =~ /failed/) { 
		if ($spool->remove_message({'messagekey'=>$bounce->{'messagekey'}})){
		    Log::do_log('debug2', "DSN Correctly removed...");
		}
		next;
	    }
	}
	#-----------------------------------------------------------------------------------------------------------------------------------
	# If the MDN notification is correct and the tracking mode is enabled, it will be inserted in the database
	if($bounce->is_mdn) {
	    if($bounce->process_mdn) {
		&Log::do_log('notice', "MDN Correctly treated...");
	    }else{
		&Log::do_log('err', "Failed to treat MDN");
	    }
	    if( $spool->remove_message({'messagekey'=>$bounce->{'messagekey'}})){
		&Log::do_log('debug2', "MDN Correctly removed...");
	    }
	    next;
	}
	
	if($bounce->is_email_feedback_report) {
	    # this case a report Email Feedback Reports http://www.shaftek.org/publications/drafts/abuse-report/draft-shafranovich-feedback-report-01.txt mainly use by AOL
	    if($bounce->process_email_feedback_report) {
		Log::do_log ('notice','Feedback Report %s correctly treated. original_rcpt:%s, listname:%s)',$bounce->{'feedback_type'}, $bounce->{'original_rcpt'}, $bounce->{'listname'} );
		$spool->remove_message({'messagekey'=>$bounce->{'messagekey'}});
	    }else{
		Log::do_log ('err','Ignoring Feedback Report %s : Unknown format (bounce where messagekey=%s), original_rcpt:%s, listname:%s)',$bounce->{'messagekey'}, $bounce->{'feedback_type'}, $bounce->{'original_rcpt'}, $bounce->{'listname'} );		
		$spool->move_to_bad($bounce->{'messagekey'});
	    }
	    next;		
	}
	# else (not welcome or remind) 
	my $list = new List ($bounce->{'listname'}, $bounce->{'robotname'});
	if (! $list) {
	    &Log::do_log('err','Skipping bounce messagekey=%s for unknown list %s@%s',$bounce->{'messagekey'},$bounce->{'listname'},$bounce->{'robotname'});
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	    next;
	}else{
	    &Log::do_log('debug',"Processing bounce messagekey=%s for list $bounce->{'listname'}",$bounce->{'messagekey'});      
	    
	    my (%hash, $from);
	    my $bounce_dir = $list->get_bounce_dir();
	    
	    ## RFC1891 compliance check
	    my $bounce_count = &rfc1891($bounce, \%hash, \$from);
	    
	    unless ($bounce_count) {
		## Analysis of bounced message
		&anabounce($bounce, \%hash, \$from);
		# Voir pour appeler une methode de parsing des dsn qui maj la bdd
		# &updatedatabase(%hash);
	    }
	    
	    ## Bounce directory
	    if (! -d $bounce_dir) {
		unless (mkdir $bounce_dir, 0777) {
		    Site->send_notify_to_listmaster('bounce_intern_error',
			{'error' => "Failed to list create bounce directory $bounce_dir"});
		    &Log::do_log('err', 'Could not create %s: %s bounced dir, check bounce_path in wwsympa.conf', $bounce_dir, $!);
		exit;
		} 
	    }
	    
	    my $adr_count;
	    ## Bouncing addresses
	    # Voir si pas mettre un test conditionnel sur le status code pour detecter les dsn positifs et ne pas fausser les statistiques de l'abonné.
	    # Peut être possibilité de lancer la maj des tables pour chaque recipient ici a condition d'avoir approfondi le parsing en amont.
	    while (my ($rcpt, $status) = each %hash) {
		$adr_count++;
		my $bouncefor = $bounce->{'who'};
		$bouncefor ||= $rcpt;
	    
		next unless (&store_bounce ($bounce_dir,$bounce,$bouncefor));
		next unless (&update_subscriber_bounce_history($list, $rcpt, $bouncefor, &canonicalize_status ($status)));
	    }
	    
	    ## No address found in the bounce itself
	    unless ($adr_count) {
		
		if ( $bounce->{'who'} ) {	# rcpt not recognized in the bounce but VERP was used
		    &store_bounce ($bounce_dir,$bounce,$bounce->{'who'});
		    &update_subscriber_bounce_history($list, 'unknown', $bounce->{'who'}); # status is undefined 
		}else{          # no VERP and no rcpt recognized		
		    my $escaped_from = &tools::escape_chars($from);
		    &Log::do_log('info', 'error: no address found in message from %s for list %s',$from, $list);
		    $spool->move_to_bad($spooled_bounce->{'messagekey'});
		    next;
		}
	    }
	}
	
	unless ($spool->remove_message({'messagekey'=>$bounce->{'messagekey'}})) {
	    &Log::do_log ('err',"Could not remove messafe from spool bounce (messaegkey = %s)",$bounce->{'messagekey'});
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	    last;
	}
	## Free zombie sendmail processes
	#    &mail::reaper;
    }
}

# Purge grouped notifications
Site->send_notify_to_listmaster(undef, undef, undef, 1);

&Log::do_log('notice', 'bounced exited normally due to signal');
&tools::remove_pid(Site->bounced_pidfile, $$);

exit(0);


## When we catch SIGTERM, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}

## copy the bounce to the appropriate filename
sub store_bounce {

    my $bounce_dir = shift; 
    my $bounce= shift;
    my $rcpt=shift;
    
    &Log::do_log('trace', 'store_bounce(%s,%s,%s)', $bounce, $bounce_dir,$rcpt);

    my $queue = Site->queuebounce;

    my $filename = &tools::escape_chars($rcpt);    
    
    unless (open ARC, ">$bounce_dir/$filename") {
	&Log::do_log('notice', "Unable to write $bounce_dir/$filename");
	$spool->move_to_bad($bounce->{'messagekey'});
	return undef;
    }
    print ARC $bounce->get_message_as_string;
    close ARC;
    close BOUNCE; 
}


## Set error message to a status RFC1893 compliant
sub canonicalize_status {

    my $status =shift;
    
    if ($status !~ /^\d+\.\d+\.\d+$/) {
	if ($equiv{$status}) {
	    $status = $equiv{$status};
	}else {
	    return undef;
	}
    }
    return $status;
}


## update subscriber information
# $bouncefor : the email address the bounce is related for (may be extracted using verp)
# $rcpt : the email address recognized in the bounce itself. In most case $rcpt eq $bouncefor

sub update_subscriber_bounce_history {

    my $list = shift;
    my $rcpt = shift;
    my $bouncefor = shift;
    my $status = shift;
    
    &Log::do_log ('trace','&update_subscriber_bounce_history (%s,%s,%s,%s)', $list, $rcpt, $bouncefor, $status); 

    my $first = my $last = time;
    my $count = 0;
    
    my $user = $list->get_list_member($bouncefor);
    
    unless ($user) {
	&Log::do_log ('notice', 'Subscriber not found in list %s : %s', $list, $bouncefor); 		    
	return undef;
    }
    
    if ($user->{'bounce'} =~ /^(\d+)\s\d+\s+(\d+)/) {
	($first, $count) = ($1, $2);
    }
    $count++;
    if ($rcpt ne $bouncefor) {
	&Log::do_log('notice','Bouncing address identified with VERP : %s / %s', $rcpt, $bouncefor);
	&Log::do_log ('debug','&update_subscribe (%s, bounce-> %s %s %s %s,bounce_address->%s)',$bouncefor,$first,$last,$count,$status,$rcpt); 
	$list->update_list_member($bouncefor,{'bounce' => "$first $last $count $status",
				       'bounce_address' => $rcpt});
	&Log::db_log({'robot' => $list->domain, 'list' => $list->name, 'action' => 'get_bounce','parameters' => "address=$rcpt",
		      'target_email' => $bouncefor,'msg_id' => '','status' => 'error','error_type' => $status,
		      'daemon' => 'bounced'});
    }else{
	$list->update_list_member($bouncefor,{'bounce' => "$first $last $count $status"});
	&Log::do_log('notice','Received bounce for email address %s, list %s', $bouncefor, $list);
	&Log::db_log({'robot' => $list->domain, 'list' => $list->name, 'action' => 'get_bounce',
		      'target_email' => $bouncefor,'msg_id' => '','status' => 'error','error_type' => $status,
		      'daemon' => 'bounced'});
    }
}
