#!--PERL--
# bounced.pl - This script runs as a daemon ; it does the incoming 
# non-delivery reports analysis and storage
# RCS Identication ; $Revision$ ; $Date$
#
# Sympa - SYsteme de Multi-Postage Automatique
# Copyright (c) 1997, 1998, 1999, 2000, 2001 Comite Reseau des Universites
# Copyright (c) 1997,1998, 1999 Institut Pasteur & Christophe Wolfhugel
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


## Worl Wide Sympa is a front-end to Sympa Mailing Lists Manager
## Copyright Comite Reseau des Universites

## Patch 2001.07.24 by nablaphi <nablaphi@bigfoot.com>
## Change the Getopt::Std to Getopt::Long

## Options :  F         -> do not detach TTY
##         :  d		-> debug -d is equiv to -dF
## Now, it is impossible to use -dF but you have to write it -d -F

use lib '--modulesdir--';
use strict;

use FileHandle;
use Getopt::Long;
use POSIX;

use List;
use tracking;
use BounceMessage;

## Check options
my %options;
unless (&GetOptions(\%main::options, 'debug|d','log_level=s','foreground|F')) {
    &Log::fatal_err("Unknown options.");
}

if ($main::options{'debug'}) {
    $main::options{'log_level'} = 2 unless ($main::options{'log_level'});
}

$main::options{'foreground'} = 1 if ($main::options{'debug'});
$main::options{'log_to_stderr'} = 1 if ($main::options{'debug'} || $main::options{'foreground'});

my $daemon_name = &Log::set_daemon($0);
my $ip = $ENV{'REMOTE_HOST'};

# Load sympa.conf
unless (defined Robot::get_robots()) {
    Log::fatal_err(
	'Unable to load sympa configuration, file %s has errors.',
	Conf::get_sympa_conf()
    );
}

##unshift @INC, Site->wws_path;

## Check databse connectivity
unless (SDM::check_db_connect()) {
    Log::fatal_err('Database %s defined in sympa.conf has not the right structure or is unreachable.', Site->db_name);
}

## Put ourselves in background if not in debug mode. 
unless ($main::options{'debug'} || $main::options{'foreground'}) {

    open(STDERR, ">> /dev/null");
    open(STDOUT, ">> /dev/null");
    if (open(TTY, "/dev/tty")) {
       ioctl(TTY, 0x20007471, 0);         # XXX s/b &TIOCNOTTY
#	ioctl(TTY, &TIOCNOTTY, 0);
	close(TTY);
    }
    setpgrp(0, 0);
    if ((my $child_pid = fork) != 0) {
	print STDOUT "Starting bounce daemon, pid $_\n";

	exit(0);
    }
}

## If process is running in foreground, don't write STDERR to a dedicated file
my $options;
$options->{'stderr_to_tty'} = 1 if ($main::options{'foreground'});

## Create and write the pidfile
tools::write_pid(Site->bounced_pidfile, $$, $options);
unless ($options->{'stderr_to_tty'}) {
    tools::direct_stderr_to_file(('pid' => $$));
}

if ($main::options{'log_level'}) {
    Log::set_log_level($main::options{'log_level'});
    Log::do_log(
	'info', 'Configuration file read, log level set using options : %s',
	$main::options{'log_level'}
    ); 
} else {
    Log::set_log_level(Site->log_level);
    Log::do_log(
	'info', 'Configuration file read, default log level %s',
	Site->log_level
    ); 
}

&Log::do_openlog(Site->log_facility, Site->log_socket_type, 'bounced');

## Set the UserID & GroupID for the process
$( = $) = (getgrnam(Sympa::Constants::GROUP))[2];
$< = $> = (getpwnam(Sympa::Constants::USER))[2];

## Required on FreeBSD to change ALL IDs(effective UID + real UID + saved UID)
&POSIX::setuid((getpwnam(Sympa::Constants::USER))[2]);
&POSIX::setgid((getgrnam(Sympa::Constants::GROUP))[2]);

## Check if the UID has correctly been set (usefull on OS X)
unless (($( == (getgrnam(Sympa::Constants::GROUP))[2]) && ($< == (getpwnam(Sympa::Constants::USER))[2])) {
    Log::fatal_err("Failed to change process userID and groupID. Note that on some OS Perl scripts can't change their real UID. In such circumstances Sympa should be run via SUDO.");
}

## Sets the UMASK
umask(oct(Site->umask));

## Change to list root
unless (chdir(Site->home)) {
    Log::do_log('info', 'Unable to change directory');
    exit (-1);
}

Log::do_log('notice', "bounced Started");

## Catch SIGTERM, in order to exit cleanly, whenever possible.
$SIG{'TERM'} = 'sigterm';
my $end = 0;

my $spool = new Sympaspool('bounce');


Log::do_log('debug','starting infinite loop');
## infinite loop scanning the queue (unless a sig TERM is received
while (!$end) {
    
    sleep Site->sleep;
    
    List::init_list_cache();
    # Process grouped notifications
    Site->send_notify_to_listmaster(undef, undef, 1, undef);

    my $spooled_bounce;
    while ($spooled_bounce = $spool->next){
	my $bounce;
	unless ($bounce = new BounceMessage({'message_in_spool' => $spooled_bounce})) {
	    Log::do_log('err','Message %s: badly formatted bounce message. Ignoring.',$spooled_bounce->{'messagekey'});
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	    next;
	}
	if ($bounce->process) {
	    unless ($spool->remove_message({'messagekey'=>$bounce->{'messagekey'}})) {
		Log::do_log ('err',"Could not remove message from spool bounce (messaegkey = %s)",$bounce->{'messagekey'});
		$spool->move_to_bad($spooled_bounce->{'messagekey'});
		last;
	    }
	}else {
	    $spool->move_to_bad($spooled_bounce->{'messagekey'});
	}
	## Free zombie sendmail processes
	mail::reaper;
    }
}

# Purge grouped notifications
Site->send_notify_to_listmaster(undef, undef, undef, 1);

Log::do_log('notice', 'bounced exited normally due to signal');
tools::remove_pid(Site->bounced_pidfile, $$);

exit(0);


## When we catch SIGTERM, just change the value of the loop
## variable.
sub sigterm {
    $end = 1;
}
